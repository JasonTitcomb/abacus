// ┌────────────────────────────────────────────────────────────────────────┐ \\
// │ Abacus - Fast, efficient, cross precision, maths library               │ \\
// ├────────────────────────────────────────────────────────────────────────┤ \\
// │ Brought to you by:                                                     │ \\
// │          _________                    .__               __             │ \\
// │         /   _____/__ __  ____    ____ |__|____    _____/  |_           │ \\
// │         \_____  \|  |  \/    \  / ___\|  \__  \  /    \   __\          │ \\
// │         /        \  |  /   |  \/ /_/  >  |/ __ \|   |  \  |            │ \\
// │        /_______  /____/|___|  /\___  /|__(____  /___|  /__|            │ \\
// │                \/           \//_____/         \/     \/                │ \\
// │                                                                        │ \\
// ├────────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright © 2013 A.J.Pook (http://abacus3d.github.com)                 │ \\
// ├────────────────────────────────────────────────────────────────────────┤ \\
// │ Permission is hereby granted, free of charge, to any person obtaining  │ \\
// │ a copy of this software and associated documentation files (the        │ \\
// │ "Software"), to deal in the Software without restriction, including    │ \\
// │ without limitation the rights to use, copy, modify, merge, publish,    │ \\
// │ distribute, sublicense, and/or sellcopies of the Software, and to      │ \\
// │ permit persons to whom the Software is furnished to do so, subject to  │ \\
// │ the following conditions:                                              │ \\
// │                                                                        │ \\
// │ The above copyright notice and this permission notice shall be         │ \\
// │ included in all copies or substantial portions of the Software.        │ \\
// │                                                                        │ \\
// │ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,        │ \\
// │ EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF     │ \\
// │ MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. │ \\
// │ IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY   │ \\
// │ CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,   │ \\
// │ TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE       │ \\
// │ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                 │ \\
// └────────────────────────────────────────────────────────────────────────┘ \\


using System;
using System.Globalization;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.ConstrainedExecution;
using NUnit.Framework;
using System.Runtime.CompilerServices;

namespace Abacus.Tests
{
    /// <summary>
    /// todo
    /// </summary>
    static class Settings
    {
        internal const UInt32 NumTests = 10000;
    }


    /// <summary>
    /// todo
    /// </summary>
    [TestFixture]
    public class RealMaths
    {
        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Zero_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }
        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Half_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }
        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_One_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_E_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }
        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Log10E_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }
        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Log2E_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Pi_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_PiOver2_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_PiOver4_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Tau_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Epsilon_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Root2_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Root3_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_IsZero_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_FromString_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_FromFraction_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_ToRadians_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_ToDegrees_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Sqrt_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Sin_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Cos_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Tan_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Abs_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_ArcSin_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_ArcCos_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_ArcTan_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Min_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Max_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_WithinEpsilon_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Sign_SinglePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Zero_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }
        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Half_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }
        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_One_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_E_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }
        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Log10E_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }
        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Log2E_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Pi_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_PiOver2_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_PiOver4_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Tau_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Epsilon_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Root2_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Root3_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_IsZero_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_FromString_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_FromFraction_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_ToRadians_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_ToDegrees_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Sqrt_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Sin_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Cos_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Tan_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Abs_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_ArcSin_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_ArcCos_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_ArcTan_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Min_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Max_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_WithinEpsilon_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Sign_DoublePrecision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Zero_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }
        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Half_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }
        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_One_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_E_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }
        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Log10E_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }
        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Log2E_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Pi_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_PiOver2_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_PiOver4_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Tau_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Epsilon_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Root2_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestConstant_Root3_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_IsZero_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_FromString_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_FromFraction_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_ToRadians_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_ToDegrees_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Sqrt_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Sin_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Cos_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Tan_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Abs_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_ArcSin_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_ArcCos_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_ArcTan_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Min_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Max_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_WithinEpsilon_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Sign_Fixed32Precision_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

    }

    /// <summary>
    ///This is a test class for Fixed32Test and is intended
    ///to contain all Fixed32Test Unit Tests
    ///</summary>
    [TestFixture]
    public class Fixed32Tests
    {
        [Test]
        public void TestMaxRange()
        {
            double max = System.Math.Pow(2.0, Fixed32.m) - System.Math.Pow(2.0, -Fixed32.n);
            Assert.That(Fixed32.MaxValue.ToDouble(), Is.EqualTo(max));
        }

        [Test]
        public void TestMinRange()
        {
            double min = -System.Math.Pow(2.0, Fixed32.m);
            Assert.That(Fixed32.MinValue.ToDouble(), Is.EqualTo(min));
        }

        [Test]
        public void TestResolution()
        {
            // we should be able to represent this exactly
            double res = (double)-System.Math.Pow(2.0, -Fixed32.n);
            Fixed32 f = (Fixed32) res;
            Assert.That((double)f, Is.EqualTo(res));
        
            // but not this
            double res2 = res / 2;
            Fixed32 f2 = (Fixed32) res2;
            Assert.That((double)f2, Is.Not.EqualTo(res2));
        }

        [Test]
        public void TestToDouble ()
        {
            double[] values = { 0.0, 1.0, 1.0 / 3, -1, -1.0 / 3 };

            foreach (double value in values) {
                Fixed32 f = new Fixed32 (value);
                double d = f.ToDouble ();
                double error = System.Math.Abs (d - value);
                Assert.That (error < 0.001);
            }
        }

        
        [Test]
        public void TestToString ()
        {
            Assert.That (new Fixed32 (0).ToString (), Is.EqualTo ("0"));
            Assert.That (new Fixed32 (3.03125).ToString (), Is.EqualTo ("3.03125"));
            Assert.That (string.Format ("{0:0.000}", new Fixed32 (3.141593)), Is.EqualTo ("3.142"));
        }

        [Test]
        public void TestConstructFromString ()
        {
            Fixed32 zero = 0;
            Fixed32 one = 1;
            Assert.That (Fixed32.Parse("0"), Is.EqualTo (zero));
            Assert.That (Fixed32.Parse("-0"), Is.EqualTo (zero));
            Assert.That (Fixed32.Parse("0."), Is.EqualTo (zero));
            Assert.That (Fixed32.Parse("0.0"), Is.EqualTo (zero));
            Assert.That (Fixed32.Parse("0.00"), Is.EqualTo (zero));

            Assert.That (Fixed32.Parse("1"), Is.EqualTo (one));
            Assert.That (Fixed32.Parse("1."), Is.EqualTo (one));
            Assert.That (Fixed32.Parse("1.0"), Is.EqualTo (one));
            Assert.That (Fixed32.Parse("-1"), Is.EqualTo (new Fixed32 (-1)));
            Assert.That (Fixed32.Parse("-1."), Is.EqualTo (new Fixed32 (-1)));
            Assert.That (Fixed32.Parse("-1.0"), Is.EqualTo (new Fixed32 (-1)));

            Assert.That (Fixed32.Parse("0.500"), Is.EqualTo (one / new Fixed32(2)));
            Assert.That (Fixed32.Parse("-0.500"), Is.EqualTo (-one / new Fixed32(2)).Within(Fixed32.Epsilon));

            Assert.That (Fixed32.Parse("-0.005"), Is.EqualTo (-one / new Fixed32(200)));
            Assert.That (Fixed32.Parse("-0.344999432563782"), Is.EqualTo (new Fixed32 (-0.344999432563782d)));
            Assert.That (Fixed32.Parse("0.938602924346924"), Is.EqualTo (new Fixed32 (0.938602924346924d)));

            Assert.That (Fixed32.Parse("100.001"), Is.EqualTo (new Fixed32 (100) + one / new Fixed32(1000)));

            
        }

        [Test]
        public void TestSin ()
        {
            double t = 0.1;

            Fixed32 zero = 0;
            Fixed32 one = 1;
            Fixed32 two = 2;
            Fixed32 three = 3;
            Fixed32 pi; global::Abacus.RealMaths.Pi(out pi);
            Fixed32 tau; global::Abacus.RealMaths.Tau(out tau);

            double p1 = Fixed32.Sin(zero).ToDouble();
            double e1 = zero.ToDouble();
            Assert.That(p1, Is.EqualTo(e1).Within(t));

            double p2 = Fixed32.Sin(pi / two).ToDouble();
            double e2 = one.ToDouble();
            Assert.That(p2, Is.EqualTo(e2).Within(t));

            double p3 = Fixed32.Sin(pi).ToDouble();
            double e3 = zero.ToDouble();
            Assert.That(p3, Is.EqualTo(e3).Within(t));

            double p4 = Fixed32.Sin(three * pi / two).ToDouble();
            double e4 = -one.ToDouble();
            Assert.That(p4, Is.EqualTo(e4).Within(t));

            double p5 = Fixed32.Sin(tau).ToDouble();
            double e5 = zero.ToDouble();
            Assert.That(p5, Is.EqualTo(e5).Within(t));

            for (float f = 0.0f; f < System.Math.PI * 2.0f; f += 0.1f)
            {
                Assert.That(System.Math.Sin(f), Is.EqualTo(Fixed32.Sin(new Fixed32(f)).ToDouble()).Within(t));
            }
        }

        [Test]
        public void TestCos ()
        {
            Fixed32 zero = 0;
            Fixed32 one = 1;
            Fixed32 two = 2;
            Fixed32 three = 3;
            Fixed32 pi; global::Abacus.RealMaths.Pi(out pi);
            Fixed32 tau; global::Abacus.RealMaths.Tau(out tau);

            Assert.That (Fixed32.Cos (zero), Is.EqualTo (one));
            Assert.That (Fixed32.Cos (pi / two), Is.EqualTo (zero));
            Assert.That (Fixed32.Cos (pi), Is.EqualTo (-one));
            Assert.That(Fixed32.Cos(three * pi / two), Is.EqualTo(zero));
            Assert.That (Fixed32.Cos (tau), Is.EqualTo (one));

            const float epsilon = 0.0001f;
            for (float f = 0.0f; f < System.Math.PI * 2.0f; f += 0.1f) {
                float singleResult = (float) System.Math.Cos(f);
                float fixedResult = Fixed32.Cos(new Fixed32(f)).ToSingle();

                Assert.That(
                    singleResult, 
                    Is.EqualTo(fixedResult).Within(epsilon),
                    string.Format("was: {0}, should have been: {1}", fixedResult, singleResult));
            }
        }

        [Test]
        public void Test_Operators_Addition ()
        {
            throw new InconclusiveException ("Not Implemented");
        }

        [Test]
        public void Test_Operators_Subtraction ()
        {
            throw new InconclusiveException ("Not Implemented");
        }

        /// <summary>
        /// Make sure tiny multiplies work properly - these inputs are so small
        /// they underflow to zero
        /// </summary>
        [Test]
        public void Test_Operators_Multiplication_i ()
        {
            int[] values = { 2, 1, 0, -1, -2 };

            foreach (int value in values) {
                Fixed32 f = Fixed32.CreateFromRaw (value);
                Fixed32 fsq = f * f;
                Assert.That (fsq, Is.EqualTo (new Fixed32(0)));
            }
        }


        /// <summary>
        /// Make sure signs are handled correctly during multiplication
        /// </summary>
        [Test]
        public void Test_Operators_Multiplication_ii ()
        {

            Fixed32 one = 1;
            Fixed32 negOne = -one;

            Assert.That (one * one, Is.EqualTo (one));
            Assert.That (negOne * one, Is.EqualTo (negOne));
            Assert.That (one * negOne, Is.EqualTo (negOne));
            Assert.That (negOne * negOne, Is.EqualTo (one));
        }


        [Test]
        public void Test_Operators_Multiplication_iii ()
        {
            double[] values = { 0.9, 0.5, 0.1, 0.01, 0.001, -0.001, -0.01, -0.1, -0.5, -0.9 };

            foreach (double value in values)
            {
                Fixed32 f = new Fixed32 (value);
                Fixed32 fsq = f * f;

                // Actually we tolerate a slight rounding error here.  We shouldn't have to, but it's not crucial to fix it.
                long diff = System.Math.Abs (new Fixed32 (value * value).RawValue - fsq.RawValue);
                Assert.That (diff < 2);
           }
        }

        [Test]
        public void Test_Operators_Multiplication_iv ()
        {
            Fixed32 a = Fixed32.MaxValue / 2;
            a -= 1;

            Assert.That((a * 2) + 1, Is.Not.EqualTo(Fixed32.MaxValue));


            /*
            long basevalue = 1000000;
            Fixed32 f = new Fixed32 (basevalue);
            Fixed32 g = new Fixed32 (basevalue);
            Fixed32 h = new Fixed32 (basevalue * basevalue);
            Assert.That (f * g, Is.EqualTo (h));

            // This is testing the test, really, to make sure 'basevalue' was
            // large enough to trigger overflow in the first place.
            Fixed32 bad_h = Fixed32.CreateFromRaw ((f.RawValue * g.RawValue) >> Fixed32.n);
            Assert.That (bad_h, Is.Not.EqualTo (h));
             *
             */
        }

        [Test]
        public void Test_Operators_Multiplication_v()
        {
            Assert.That((Fixed32.MaxValue - 10) * (Fixed32.MaxValue - 10), Is.EqualTo(Fixed32.MaxValue));
            Assert.That(Fixed32.MaxValue * Fixed32.MaxValue, Is.EqualTo(Fixed32.MaxValue));

            Assert.That(Fixed32.MinValue * Fixed32.MinValue, Is.EqualTo(Fixed32.MaxValue));

            Assert.That(Fixed32.MaxValue * Fixed32.MinValue, Is.EqualTo(Fixed32.MinValue));
        }

        /// <summary>
        /// Check that division doesn't get rounded to integers
        /// </summary>
        [Test]
        public void Test_Operators_Division ()
        {
            const long numerator = 1;
            const long denominator = 10;

            Fixed32 f = new Fixed32 (numerator);
            Fixed32 g = new Fixed32 (denominator);
            Fixed32 h = new Fixed32 (((double)numerator) / denominator);

            Assert.That (f / g, Is.EqualTo (h));
        }

        [Test]
        public void Test_Operators_LessThan ()
        {
            Fixed32 f = new Fixed32 (419);

            int i = 1000;
            Assert.That (f < i);
        }

        [Test]
        public void Test_Operators_GreaterThan ()
        {
            throw new InconclusiveException ("Not Implemented");
        }

    }

    /// <summary>
    /// todo
    /// </summary>
    [TestFixture]
    public class PackUtils
    {
        /*
        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestPacking_Signed_i ()
        {
            var rand = new System.Random();

            UInt32 bitmask = 0xffffffff;

            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                Single s = (Single)rand.NextDouble();

                UInt32 p = global::Abacus.PackUtils.PackSigned (bitmask, s);

                Single u = global::Abacus.PackUtils.UnpackSigned (bitmask, p);

                Assert.That (u, Is.EqualTo(s));
            }
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestPacking_Signed_ii ()
        {
            var rand = new System.Random();
            var buff = new Byte[4];
            UInt32 bitmask = 0xffffffff;

            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                rand.NextBytes(buff);
                UInt32 p = BitConverter.ToUInt32(buff, 0);

                Single u = global::Abacus.PackUtils.UnpackSigned (bitmask, p);

                UInt32 rp = global::Abacus.PackUtils.PackSigned (bitmask, u);

                Assert.That (rp, Is.EqualTo(p));
            }
        }*/

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestPacking_SignedNormalised_i ()
        {
            var rand = new System.Random();

            UInt32 bitmask = 0xffffffff;

            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                Single s = (Single)rand.NextDouble();

                if (rand.Next(0, 1) == 1) s = -s;

                UInt32 p = global::Abacus.PackUtils.PackSignedNormalised (bitmask, s);

                Single u = global::Abacus.PackUtils.UnpackSignedNormalised (bitmask, p);

                Assert.That (u, Is.EqualTo(s));
            }
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestPacking_UnsignedNormalisedValue_i ()
        {
            var rand = new System.Random();

            UInt32 bitmask = 0xffffffff;

            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                Single s = (Single)rand.NextDouble();

                UInt32 p = global::Abacus.PackUtils.PackUnsignedNormalisedValue (bitmask, s);

                Single u = global::Abacus.PackUtils.UnpackUnsignedNormalisedValue (bitmask, p);

                Assert.That (u, Is.EqualTo(s));
            }
        }
    }


}

namespace Abacus.Packed.Tests
{
    using Abacus.Tests;
    /// <summary>
    /// Tests the Alpha_8 packed data type.
    /// </summary>
    [TestFixture]
    public class Alpha_8Tests
    {
        /// <summary>
        /// Iterates over every possible Alpha_8 value and makes sure that
        /// unpacking them and then re-packing that result yeilds the 
        /// original packed value.
        /// </summary>
        [Test]
        public void TestAllPossibleValues_i()
        {   
            Byte packed = Byte.MinValue;
            while ( packed < Byte.MaxValue )
            {
                ++packed;
                var packedObj = new Alpha_8();
                packedObj.PackedValue = packed;
                Single unpacked;
                packedObj.UnpackTo(out unpacked);
                var newPackedObj = new Alpha_8(unpacked);
                Assert.That(newPackedObj.PackedValue, Is.EqualTo(packed));
            }
        }

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i()
        {
            var testCase = new Alpha_8();
            testCase.PackFrom(0.656f);
            String s = testCase.ToString ();
            Assert.That(s, Is.EqualTo("A7"));
        }

        /// <summary>
        /// Makes sure that the hashing function is good by testing 
        /// all scenarios and ensuring that there are no collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            HashSet<Int32> hs = new HashSet<Int32>();
            Byte packed = Byte.MinValue;
            while ( packed < Byte.MaxValue )
            {
                ++packed;
                var packedObj = new Alpha_8();
                packedObj.PackedValue = packed;
                Int32 hc = packedObj.GetHashCode ();
                Assert.That(!hs.Contains(hc));
                hs.Add(hc);
            }
        }
    }

    /// <summary>
    /// Tests the Bgr_5_6_5 packed data type.
    /// </summary>
    [TestFixture]
    public class Bgr_5_6_5Tests
    {
        /// <summary>
        /// Iterates over every possible Bgr_5_6_5 value and makes sure that
        /// unpacking them and then re-packing that result yeilds the 
        /// original packed value.
        /// </summary>
        [Test]
        public void TestAllPossibleValues_i()
        {
            UInt16 packed = UInt16.MinValue;
            while ( packed < UInt16.MaxValue )
            {
                ++packed;
                var packedObj = new Bgr_5_6_5();
                packedObj.PackedValue = packed;
                SinglePrecision.Vector3 unpacked;
                packedObj.UnpackTo(out unpacked);
                var newPackedObj = new Bgr_5_6_5(ref unpacked);
                Assert.That(newPackedObj.PackedValue, Is.EqualTo(packed));
            }
        }

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i()
        {
            var testCase = new Bgr_5_6_5();
            var f = new SinglePrecision.Vector3(0.656f, 0.125f, 0.861f);
            testCase.PackFrom(ref f);
            String s = testCase.ToString ();
            Assert.That(s, Is.EqualTo("A11B"));
        }

        /// <summary>
        /// Makes sure that the hashing function is good by testing 
        /// all scenarios and ensuring that there are no collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            HashSet<Int32> hs = new HashSet<Int32>();
            UInt16 packed = UInt16.MinValue;
            while ( packed < UInt16.MaxValue )
            {
                ++packed;
                var packedObj = new Bgr_5_6_5();
                packedObj.PackedValue = packed;
                Int32 hc = packedObj.GetHashCode ();
                Assert.That(!hs.Contains(hc));
                hs.Add(hc);
            }
        }
    }

    /// <summary>
    /// Tests the Bgra16 packed data type.
    /// </summary>
    [TestFixture]
    public class Bgra16Tests
    {
        /// <summary>
        /// Iterates over every possible Bgra16 value and makes sure that
        /// unpacking them and then re-packing that result yeilds the 
        /// original packed value.
        /// </summary>
        [Test]
        public void TestAllPossibleValues_i()
        {
            UInt16 packed = UInt16.MinValue;
            while ( packed < UInt16.MaxValue )
            {
                ++packed;
                var packedObj = new Bgra16();
                packedObj.PackedValue = packed;
                SinglePrecision.Vector4 unpacked;
                packedObj.UnpackTo(out unpacked);
                var newPackedObj = new Bgra16(ref unpacked);
                Assert.That(newPackedObj.PackedValue, Is.EqualTo(packed));
            }
        }

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i()
        {
            var testCase = new Bgra16();
            var f = new SinglePrecision.Vector4(0.656f, 0.125f, 0.222f, 0.861f);
            testCase.PackFrom(ref f);
            String s = testCase.ToString ();
            Assert.That(s, Is.EqualTo("DA23"));
        }

        /// <summary>
        /// Makes sure that the hashing function is good by testing 
        /// all scenarios and ensuring that there are no collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            HashSet<Int32> hs = new HashSet<Int32>();
            UInt16 packed = UInt16.MinValue;
            while ( packed < UInt16.MaxValue )
            {
                ++packed;
                var packedObj = new Bgra16();
                packedObj.PackedValue = packed;
                Int32 hc = packedObj.GetHashCode ();
                Assert.That(!hs.Contains(hc));
                hs.Add(hc);
            }
        }
    }

    /// <summary>
    /// Tests the Bgra_5_5_5_1 packed data type.
    /// </summary>
    [TestFixture]
    public class Bgra_5_5_5_1Tests
    {
        /// <summary>
        /// Iterates over every possible Bgra_5_5_5_1 value and makes sure that
        /// unpacking them and then re-packing that result yeilds the 
        /// original packed value.
        /// </summary>
        [Test]
        public void TestAllPossibleValues_i()
        {
            UInt16 packed = UInt16.MinValue;
            while ( packed < UInt16.MaxValue )
            {
                ++packed;
                var packedObj = new Bgra_5_5_5_1();
                packedObj.PackedValue = packed;
                SinglePrecision.Vector4 unpacked;
                packedObj.UnpackTo(out unpacked);
                var newPackedObj = new Bgra_5_5_5_1(ref unpacked);
                Assert.That(newPackedObj.PackedValue, Is.EqualTo(packed));
            }
        }

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i()
        {
            var testCase = new Bgra_5_5_5_1();
            var f = new SinglePrecision.Vector4(0.656f, 0.125f, 0.222f, 0.861f);
            testCase.PackFrom(ref f);
            String s = testCase.ToString ();
            Assert.That(s, Is.EqualTo("D087"));
        }

        /// <summary>
        /// Makes sure that the hashing function is good by testing 
        /// all scenarios and ensuring that there are no collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            HashSet<Int32> hs = new HashSet<Int32>();
            UInt16 packed = UInt16.MinValue;
            while ( packed < UInt16.MaxValue )
            {
                ++packed;
                var packedObj = new Bgra_5_5_5_1();
                packedObj.PackedValue = packed;
                Int32 hc = packedObj.GetHashCode ();
                Assert.That(!hs.Contains(hc));
                hs.Add(hc);
            }
        }
    }
    /// <summary>
    /// Tests the Byte4 packed data type.
    /// </summary>
    [TestFixture]
    public class Byte4Tests
    {
        /// <summary>
        /// Iterates over a random selection of values within the range of
        /// possible Byte4 values and makes sure that unpacking them and 
        /// then re-packing that result yeilds the original packed value.
        /// </summary>
        [Test]
        public void TestRandomValues_i()
        {
            var rand = new System.Random();
            var buff = new Byte[4];

            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                rand.NextBytes(buff);
                UInt32 packed = BitConverter.ToUInt32(buff, 0);
                var packedObj = new Byte4();
                packedObj.PackedValue = packed;
                SinglePrecision.Vector4 unpacked;
                packedObj.UnpackTo(out unpacked);
                var newPackedObj = new Byte4(ref unpacked);
                Assert.That(newPackedObj.PackedValue, Is.EqualTo(packed));
            }
        }

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i()
        {
            var testCase = new Byte4();
            var f = new SinglePrecision.Vector4(0.656f, 0.125f, 0.222f, 0.861f);
            testCase.PackFrom(ref f);
            String s = testCase.ToString ();
            Assert.That(s, Is.EqualTo("01000001"));
        }

        /// <summary>
        /// Makes sure that the hashing function is good by testing 
        /// random scenarios and ensuring that there are no more than a 
        /// reasonable number of collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            HashSet<Int32> hs = new HashSet<Int32>();
            var rand = new System.Random();
            var buff = new Byte[4];
            UInt32 collisions = 0;
            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                rand.NextBytes(buff);
                BitConverter.ToUInt32(buff, 0);
                UInt32 packed = BitConverter.ToUInt32(buff, 0);
                var packedObj = new Byte4();
                packedObj.PackedValue = packed;
                Int32 hc = packedObj.GetHashCode ();
                if(hs.Contains(hc)) ++collisions;
                hs.Add(hc);
            }
            Assert.That(collisions, Is.LessThan(10));
        }
    }

    /// <summary>
    /// Tests the NormalisedByte2 packed data type.
    /// </summary>
    [TestFixture]
    public class NormalisedByte2Tests
    {
        /// <summary>
        /// Iterates over every possible NormalisedByte2 value and makes sure that
        /// unpacking them and then re-packing that result yeilds the
        /// original packed value.
        /// </summary>
        [Test]
        public void TestAllPossibleValues_i()
        {
            UInt16 packed = UInt16.MinValue;
            while ( packed < UInt16.MaxValue )
            {
                ++packed;
                // Cannot guarantee that this packed value is valid.   
                try
                {
                    var packedObj = new NormalisedByte2();
                    packedObj.PackedValue = packed;
                    SinglePrecision.Vector2 unpacked;
                    packedObj.UnpackTo(out unpacked);
                    var newPackedObj = new NormalisedByte2(ref unpacked);
                    Assert.That(newPackedObj.PackedValue, Is.EqualTo(packedObj.PackedValue));
                }
                catch(ArgumentException)
                {
                    continue;
                }
            }
        }

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i()
        {
            var testCase = new NormalisedByte2();
            var f = new SinglePrecision.Vector2(0.222f, 0.861f);
            testCase.PackFrom(ref f);
            String s = testCase.ToString ();
            Assert.That(s, Is.EqualTo("6D1C"));
        }

        /// <summary>
        /// Makes sure that the hashing function is good by testing
        /// all scenarios and ensuring that there are no collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            HashSet<Int32> hs = new HashSet<Int32>();
            UInt16 packed = UInt16.MinValue;
            while ( packed < UInt16.MaxValue )
            {
                ++packed;
                var packedObj = new NormalisedByte2();
                packedObj.PackedValue = packed;
                Int32 hc = packedObj.GetHashCode ();
                Assert.That(!hs.Contains(hc));
                hs.Add(hc);
            }
        }
    }

    /// <summary>
    /// Tests the NormalisedByte4 packed data type.
    /// </summary>
    [TestFixture]
    public class NormalisedByte4Tests
    {
        /// <summary>
        /// Iterates over a random selection of values within the range of
        /// possible NormalisedByte4 values and makes sure that unpacking them and 
        /// then re-packing that result yeilds the original packed value.
        /// </summary>
        [Test]
        public void TestRandomValues_i()
        {
            var rand = new System.Random();
            var buff = new Byte[4];
            
            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                rand.NextBytes(buff);
                UInt32 packed = BitConverter.ToUInt32(buff, 0);
                
                // Cannot guarantee that this packed value is valid.   
                try
                {
                    var packedObj = new NormalisedByte4();
                    packedObj.PackedValue = packed;
                    SinglePrecision.Vector4 unpacked;
                    packedObj.UnpackTo(out unpacked);
                    var newPackedObj = new NormalisedByte4(ref unpacked);
                    Assert.That(newPackedObj.PackedValue, Is.EqualTo(packed));
                }
                catch(ArgumentException)
                {
                    continue;
                }
            }
        }

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i()
        {
            var testCase = new NormalisedByte4();
            var f = new SinglePrecision.Vector4(0.656f, 0.125f, 0.222f, 0.861f);
            testCase.PackFrom(ref f);
            String s = testCase.ToString ();
            Assert.That(s, Is.EqualTo("6D1C1053"));
        }

        /// <summary>
        /// Makes sure that the hashing function is good by testing 
        /// random scenarios and ensuring that there are no more than a 
        /// reasonable number of collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            HashSet<Int32> hs = new HashSet<Int32>();
            var rand = new System.Random();
            var buff = new Byte[4];
            UInt32 collisions = 0;
            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                rand.NextBytes(buff);
                UInt32 packed = BitConverter.ToUInt32(buff, 0);
                var packedObj = new NormalisedByte4();
                packedObj.PackedValue = packed;
                Int32 hc = packedObj.GetHashCode ();
                if(hs.Contains(hc)) ++collisions;
                hs.Add(hc);
            }
            Assert.That(collisions, Is.LessThan(10));
        }
    }

    /// <summary>
    /// Tests the NormalisedShort2 packed data type.
    /// </summary>
    [TestFixture]
    public class NormalisedShort2Tests
    {
        /// <summary>
        /// Iterates over a random selection of values within the range of
        /// possible NormalisedShort2 values and makes sure that unpacking them and 
        /// then re-packing that result yeilds the original packed value.
        /// </summary>
        [Test]
        public void TestRandomValues_i()
        {
            var rand = new System.Random();
            var buff = new Byte[4];
            
            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                rand.NextBytes(buff);
                UInt32 packed = BitConverter.ToUInt32(buff, 0);
                
                // Cannot guarantee that this packed value is valid.   
                try
                {
                    var packedObj = new NormalisedShort2();
                    packedObj.PackedValue = packed;
                    SinglePrecision.Vector2 unpacked;
                    packedObj.UnpackTo(out unpacked);
                    var newPackedObj = new NormalisedShort2(ref unpacked);
                    Assert.That(newPackedObj.PackedValue, Is.EqualTo(packed));
                }
                catch(ArgumentException)
                {
                    continue;
                }
            }
        }

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i()
        {
            var testCase = new NormalisedShort2();
            var f = new SinglePrecision.Vector2(0.656f, 0.861f);
            testCase.PackFrom(ref f);
            String s = testCase.ToString ();
            Assert.That(s, Is.EqualTo("6E3453F7"));
        }

        /// <summary>
        /// Makes sure that the hashing function is good by testing 
        /// random scenarios and ensuring that there are no more than a 
        /// reasonable number of collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            HashSet<Int32> hs = new HashSet<Int32>();
            var rand = new System.Random();
            var buff = new Byte[4];
            UInt32 collisions = 0;
            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                rand.NextBytes(buff);
                UInt32 packed = BitConverter.ToUInt32(buff, 0);
                var packedObj = new NormalisedShort2();
                packedObj.PackedValue = packed;
                Int32 hc = packedObj.GetHashCode ();
                if(hs.Contains(hc)) ++collisions;
                hs.Add(hc);
            }
            Assert.That(collisions, Is.LessThan(10));
        }
    }

    /// <summary>
    /// Tests the NormalisedShort4 packed data type.
    /// </summary>
    [TestFixture]
    public class NormalisedShort4Tests
    {
        /// <summary>
        /// Iterates over a random selection of values within the range of
        /// possible NormalisedShort4 values and makes sure that unpacking them and 
        /// then re-packing that result yeilds the original packed value.
        /// </summary>
        [Test]
        public void TestRandomValues_i()
        {
            var rand = new System.Random();
            var buff = new Byte[8];
            
            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                rand.NextBytes(buff);
                UInt64 packed = BitConverter.ToUInt64(buff, 0);
                
                // Cannot guarantee that this packed value is valid.   
                try
                {
                    var packedObj = new NormalisedShort4();
                    packedObj.PackedValue = packed;
                    SinglePrecision.Vector4 unpacked;
                    packedObj.UnpackTo(out unpacked);
                    var newPackedObj = new NormalisedShort4(ref unpacked);
                    Assert.That(newPackedObj.PackedValue, Is.EqualTo(packed));
                }
                catch(ArgumentException)
                {
                    continue;
                }
            }
        }

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i()
        {
            var testCase = new NormalisedShort4();
            var f = new SinglePrecision.Vector4(0.656f, 0.125f, 0.222f, 0.861f);
            testCase.PackFrom(ref f);
            String s = testCase.ToString ();
            Assert.That(s, Is.EqualTo("6E341C6A100053F7"));
        }

        /// <summary>
        /// Makes sure that the hashing function is good by testing 
        /// random scenarios and ensuring that there are no more than a 
        /// reasonable number of collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            HashSet<Int32> hs = new HashSet<Int32>();
            var rand = new System.Random();
            var buff = new Byte[8];
            UInt32 collisions = 0;
            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                rand.NextBytes(buff);
                UInt64 packed = BitConverter.ToUInt64(buff, 0);
                var packedObj = new NormalisedShort4();
                packedObj.PackedValue = packed;
                Int32 hc = packedObj.GetHashCode ();
                if(hs.Contains(hc)) ++collisions;
                hs.Add(hc);
            }
            Assert.That(collisions, Is.LessThan(10));
        }
    }

    /// <summary>
    /// Tests the Rg32 packed data type.
    /// </summary>
    [TestFixture]
    public class Rg32Tests
    {
        /// <summary>
        /// Iterates over a random selection of values within the range of
        /// possible Rg32 values and makes sure that unpacking them and 
        /// then re-packing that result yeilds the original packed value.
        /// </summary>
        [Test]
        public void TestRandomValues_i()
        {
            var rand = new System.Random();
            var buff = new Byte[4];
            
            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                rand.NextBytes(buff);
                UInt32 packed = BitConverter.ToUInt32(buff, 0);
                var packedObj = new Rg32();
                packedObj.PackedValue = packed;
                SinglePrecision.Vector2 unpacked;
                packedObj.UnpackTo(out unpacked);
                var newPackedObj = new Rg32(ref unpacked);
                Assert.That(newPackedObj.PackedValue, Is.EqualTo(packed));
            }
        }

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i()
        {
            var testCase = new Rg32();
            var f = new SinglePrecision.Vector2(0.222f, 0.861f);
            testCase.PackFrom(ref f);
            String s = testCase.ToString ();
            Assert.That(s, Is.EqualTo("DC6A38D5"));
        }

        /// <summary>
        /// Makes sure that the hashing function is good by testing 
        /// random scenarios and ensuring that there are no more than a 
        /// reasonable number of collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            HashSet<Int32> hs = new HashSet<Int32>();
            var rand = new System.Random();
            var buff = new Byte[4];
            UInt32 collisions = 0;
            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                rand.NextBytes(buff);
                UInt32 packed = BitConverter.ToUInt32(buff, 0);
                var packedObj = new Rgba64();
                packedObj.PackedValue = packed;
                Int32 hc = packedObj.GetHashCode ();
                if(hs.Contains(hc)) ++collisions;
                hs.Add(hc);
            }
            Assert.That(collisions, Is.LessThan(10));
        }
    }

    /// <summary>
    /// Tests the Rgba32 packed data type.
    /// </summary>
    [TestFixture]
    public class Rgba32Tests
    {
        /// <summary>
        /// Iterates over a random selection of values within the range of
        /// possible Rgba32 values and makes sure that unpacking them and
        /// then re-packing that result yeilds the original packed value.
        /// </summary>
        [Test]
        public void TestRandomValues_i()
        {
            var rand = new System.Random();
            var buff = new Byte[4];

            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                rand.NextBytes(buff);
                UInt32 packed = BitConverter.ToUInt32(buff, 0);
                var packedObj = new Rgba32();
                packedObj.PackedValue = packed;
                SinglePrecision.Vector4 unpacked;
                packedObj.UnpackTo(out unpacked);
                var newPackedObj = new Rgba32(ref unpacked);
                Assert.That(newPackedObj.PackedValue, Is.EqualTo(packed));
            }
        }

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i()
        {
            var testCase = new Rgba32();
            var f = new SinglePrecision.Vector4(0.656f, 0.125f, 0.222f, 0.861f);
            testCase.PackFrom(ref f);
            String s = testCase.ToString ();
            Assert.That(s, Is.EqualTo("{R:167 G:32 B:57 A:220}"));
        }

        /// <summary>
        /// Makes sure that the hashing function is good by testing
        /// random scenarios and ensuring that there are no more than a
        /// reasonable number of collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            HashSet<Int32> hs = new HashSet<Int32>();
            var rand = new System.Random();
            var buff = new Byte[4];
            UInt32 collisions = 0;
            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                rand.NextBytes(buff);
                UInt32 packed = BitConverter.ToUInt32(buff, 0);
                var packedObj = new Rgba32();
                packedObj.PackedValue = packed;
                Int32 hc = packedObj.GetHashCode ();
                if(hs.Contains(hc)) ++collisions;
                hs.Add(hc);
            }
            Assert.That(collisions, Is.LessThan(10));
        }

        /// <summary>
        /// Tests that the Transparent constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Transparent_i ()
        {
            var val = Rgba32.Transparent;
            Assert.That(val.R, Is.EqualTo(0));
            Assert.That(val.G, Is.EqualTo(0));
            Assert.That(val.B, Is.EqualTo(0));
            Assert.That(val.A, Is.EqualTo(0));
        }

        /// <summary>
        /// Tests that the AliceBlue constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_AliceBlue_i ()
        {
            var val = Rgba32.AliceBlue;
            Assert.That(val.R, Is.EqualTo(240));
            Assert.That(val.G, Is.EqualTo(248));
            Assert.That(val.B, Is.EqualTo(255));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the AntiqueWhite constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_AntiqueWhite_i ()
        {
            var val = Rgba32.AntiqueWhite;
            Assert.That(val.R, Is.EqualTo(250));
            Assert.That(val.G, Is.EqualTo(235));
            Assert.That(val.B, Is.EqualTo(215));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Aqua constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Aqua_i ()
        {
            var val = Rgba32.Aqua;
            Assert.That(val.R, Is.EqualTo(0));
            Assert.That(val.G, Is.EqualTo(255));
            Assert.That(val.B, Is.EqualTo(255));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Aquamarine constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Aquamarine_i ()
        {
            var val = Rgba32.Aquamarine;
            Assert.That(val.R, Is.EqualTo(127));
            Assert.That(val.G, Is.EqualTo(255));
            Assert.That(val.B, Is.EqualTo(212));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Azure constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Azure_i ()
        {
            var val = Rgba32.Azure;
            Assert.That(val.R, Is.EqualTo(240));
            Assert.That(val.G, Is.EqualTo(255));
            Assert.That(val.B, Is.EqualTo(255));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Beige constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Beige_i ()
        {
            var val = Rgba32.Beige;
            Assert.That(val.R, Is.EqualTo(245));
            Assert.That(val.G, Is.EqualTo(245));
            Assert.That(val.B, Is.EqualTo(220));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Bisque constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Bisque_i ()
        {
            var val = Rgba32.Bisque;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(228));
            Assert.That(val.B, Is.EqualTo(196));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Black constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Black_i ()
        {
            var val = Rgba32.Black;
            Assert.That(val.R, Is.EqualTo(0));
            Assert.That(val.G, Is.EqualTo(0));
            Assert.That(val.B, Is.EqualTo(0));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the BlanchedAlmond constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_BlanchedAlmond_i ()
        {
            var val = Rgba32.BlanchedAlmond;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(235));
            Assert.That(val.B, Is.EqualTo(205));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Blue constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Blue_i ()
        {
            var val = Rgba32.Blue;
            Assert.That(val.R, Is.EqualTo(0));
            Assert.That(val.G, Is.EqualTo(0));
            Assert.That(val.B, Is.EqualTo(255));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the BlueViolet constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_BlueViolet_i ()
        {
            var val = Rgba32.BlueViolet;
            Assert.That(val.R, Is.EqualTo(138));
            Assert.That(val.G, Is.EqualTo(43));
            Assert.That(val.B, Is.EqualTo(226));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Brown constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Brown_i ()
        {
            var val = Rgba32.Brown;
            Assert.That(val.R, Is.EqualTo(165));
            Assert.That(val.G, Is.EqualTo(42));
            Assert.That(val.B, Is.EqualTo(42));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the BurlyWood constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_BurlyWood_i ()
        {
            var val = Rgba32.BurlyWood;
            Assert.That(val.R, Is.EqualTo(222));
            Assert.That(val.G, Is.EqualTo(184));
            Assert.That(val.B, Is.EqualTo(135));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the CadetBlue constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_CadetBlue_i ()
        {
            var val = Rgba32.CadetBlue;
            Assert.That(val.R, Is.EqualTo(95));
            Assert.That(val.G, Is.EqualTo(158));
            Assert.That(val.B, Is.EqualTo(160));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Chartreuse constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Chartreuse_i ()
        {
            var val = Rgba32.Chartreuse;
            Assert.That(val.R, Is.EqualTo(127));
            Assert.That(val.G, Is.EqualTo(255));
            Assert.That(val.B, Is.EqualTo(0));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Chocolate constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Chocolate_i ()
        {
            var val = Rgba32.Chocolate;
            Assert.That(val.R, Is.EqualTo(210));
            Assert.That(val.G, Is.EqualTo(105));
            Assert.That(val.B, Is.EqualTo(30));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Coral constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Coral_i ()
        {
            var val = Rgba32.Coral;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(127));
            Assert.That(val.B, Is.EqualTo(80));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the CornflowerBlue constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_CornflowerBlue_i ()
        {
            var val = Rgba32.CornflowerBlue;
            Assert.That(val.R, Is.EqualTo(100));
            Assert.That(val.G, Is.EqualTo(149));
            Assert.That(val.B, Is.EqualTo(237));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Cornsilk constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Cornsilk_i ()
        {
            var val = Rgba32.Cornsilk;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(248));
            Assert.That(val.B, Is.EqualTo(220));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Crimson constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Crimson_i ()
        {
            var val = Rgba32.Crimson;
            Assert.That(val.R, Is.EqualTo(220));
            Assert.That(val.G, Is.EqualTo(20));
            Assert.That(val.B, Is.EqualTo(60));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Cyan constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Cyan_i ()
        {
            var val = Rgba32.Cyan;
            Assert.That(val.R, Is.EqualTo(0));
            Assert.That(val.G, Is.EqualTo(255));
            Assert.That(val.B, Is.EqualTo(255));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the DarkBlue constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_DarkBlue_i ()
        {
            var val = Rgba32.DarkBlue;
            Assert.That(val.R, Is.EqualTo(0));
            Assert.That(val.G, Is.EqualTo(0));
            Assert.That(val.B, Is.EqualTo(139));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the DarkCyan constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_DarkCyan_i ()
        {
            var val = Rgba32.DarkCyan;
            Assert.That(val.R, Is.EqualTo(0));
            Assert.That(val.G, Is.EqualTo(139));
            Assert.That(val.B, Is.EqualTo(139));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the DarkGoldenrod constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_DarkGoldenrod_i ()
        {
            var val = Rgba32.DarkGoldenrod;
            Assert.That(val.R, Is.EqualTo(184));
            Assert.That(val.G, Is.EqualTo(134));
            Assert.That(val.B, Is.EqualTo(11));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the DarkGrey constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_DarkGrey_i ()
        {
            var val = Rgba32.DarkGrey;
            Assert.That(val.R, Is.EqualTo(169));
            Assert.That(val.G, Is.EqualTo(169));
            Assert.That(val.B, Is.EqualTo(169));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the DarkGreen constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_DarkGreen_i ()
        {
            var val = Rgba32.DarkGreen;
            Assert.That(val.R, Is.EqualTo(0));
            Assert.That(val.G, Is.EqualTo(100));
            Assert.That(val.B, Is.EqualTo(0));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the DarkKhaki constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_DarkKhaki_i ()
        {
            var val = Rgba32.DarkKhaki;
            Assert.That(val.R, Is.EqualTo(189));
            Assert.That(val.G, Is.EqualTo(183));
            Assert.That(val.B, Is.EqualTo(107));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the DarkMagenta constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_DarkMagenta_i ()
        {
            var val = Rgba32.DarkMagenta;
            Assert.That(val.R, Is.EqualTo(139));
            Assert.That(val.G, Is.EqualTo(0));
            Assert.That(val.B, Is.EqualTo(139));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the DarkOliveGreen constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_DarkOliveGreen_i ()
        {
            var val = Rgba32.DarkOliveGreen;
            Assert.That(val.R, Is.EqualTo(85));
            Assert.That(val.G, Is.EqualTo(107));
            Assert.That(val.B, Is.EqualTo(47));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the DarkOrange constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_DarkOrange_i ()
        {
            var val = Rgba32.DarkOrange;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(140));
            Assert.That(val.B, Is.EqualTo(0));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the DarkOrchid constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_DarkOrchid_i ()
        {
            var val = Rgba32.DarkOrchid;
            Assert.That(val.R, Is.EqualTo(153));
            Assert.That(val.G, Is.EqualTo(50));
            Assert.That(val.B, Is.EqualTo(204));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the DarkRed constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_DarkRed_i ()
        {
            var val = Rgba32.DarkRed;
            Assert.That(val.R, Is.EqualTo(139));
            Assert.That(val.G, Is.EqualTo(0));
            Assert.That(val.B, Is.EqualTo(0));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the DarkSalmon constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_DarkSalmon_i ()
        {
            var val = Rgba32.DarkSalmon;
            Assert.That(val.R, Is.EqualTo(233));
            Assert.That(val.G, Is.EqualTo(150));
            Assert.That(val.B, Is.EqualTo(122));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the DarkSeaGreen constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_DarkSeaGreen_i ()
        {
            var val = Rgba32.DarkSeaGreen;
            Assert.That(val.R, Is.EqualTo(143));
            Assert.That(val.G, Is.EqualTo(188));
            Assert.That(val.B, Is.EqualTo(139));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the DarkSlateBlue constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_DarkSlateBlue_i ()
        {
            var val = Rgba32.DarkSlateBlue;
            Assert.That(val.R, Is.EqualTo(72));
            Assert.That(val.G, Is.EqualTo(61));
            Assert.That(val.B, Is.EqualTo(139));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the DarkSlateGrey constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_DarkSlateGrey_i ()
        {
            var val = Rgba32.DarkSlateGrey;
            Assert.That(val.R, Is.EqualTo(47));
            Assert.That(val.G, Is.EqualTo(79));
            Assert.That(val.B, Is.EqualTo(79));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the DarkTurquoise constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_DarkTurquoise_i ()
        {
            var val = Rgba32.DarkTurquoise;
            Assert.That(val.R, Is.EqualTo(0));
            Assert.That(val.G, Is.EqualTo(206));
            Assert.That(val.B, Is.EqualTo(209));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the DarkViolet constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_DarkViolet_i ()
        {
            var val = Rgba32.DarkViolet;
            Assert.That(val.R, Is.EqualTo(148));
            Assert.That(val.G, Is.EqualTo(0));
            Assert.That(val.B, Is.EqualTo(211));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the DeepPink constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_DeepPink_i ()
        {
            var val = Rgba32.DeepPink;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(20));
            Assert.That(val.B, Is.EqualTo(147));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the DeepSkyBlue constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_DeepSkyBlue_i ()
        {
            var val = Rgba32.DeepSkyBlue;
            Assert.That(val.R, Is.EqualTo(0));
            Assert.That(val.G, Is.EqualTo(191));
            Assert.That(val.B, Is.EqualTo(255));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the DimGrey constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_DimGrey_i ()
        {
            var val = Rgba32.DimGrey;
            Assert.That(val.R, Is.EqualTo(105));
            Assert.That(val.G, Is.EqualTo(105));
            Assert.That(val.B, Is.EqualTo(105));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the DodgerBlue constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_DodgerBlue_i ()
        {
            var val = Rgba32.DodgerBlue;
            Assert.That(val.R, Is.EqualTo(30));
            Assert.That(val.G, Is.EqualTo(144));
            Assert.That(val.B, Is.EqualTo(255));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Firebrick constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Firebrick_i ()
        {
            var val = Rgba32.Firebrick;
            Assert.That(val.R, Is.EqualTo(178));
            Assert.That(val.G, Is.EqualTo(34));
            Assert.That(val.B, Is.EqualTo(34));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the FloralWhite constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_FloralWhite_i ()
        {
            var val = Rgba32.FloralWhite;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(250));
            Assert.That(val.B, Is.EqualTo(240));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the ForestGreen constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_ForestGreen_i ()
        {
            var val = Rgba32.ForestGreen;
            Assert.That(val.R, Is.EqualTo(34));
            Assert.That(val.G, Is.EqualTo(139));
            Assert.That(val.B, Is.EqualTo(34));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Fuchsia constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Fuchsia_i ()
        {
            var val = Rgba32.Fuchsia;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(0));
            Assert.That(val.B, Is.EqualTo(255));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Gainsboro constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Gainsboro_i ()
        {
            var val = Rgba32.Gainsboro;
            Assert.That(val.R, Is.EqualTo(220));
            Assert.That(val.G, Is.EqualTo(220));
            Assert.That(val.B, Is.EqualTo(220));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the GhostWhite constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_GhostWhite_i ()
        {
            var val = Rgba32.GhostWhite;
            Assert.That(val.R, Is.EqualTo(248));
            Assert.That(val.G, Is.EqualTo(248));
            Assert.That(val.B, Is.EqualTo(255));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Gold constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Gold_i ()
        {
            var val = Rgba32.Gold;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(215));
            Assert.That(val.B, Is.EqualTo(0));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Goldenrod constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Goldenrod_i ()
        {
            var val = Rgba32.Goldenrod;
            Assert.That(val.R, Is.EqualTo(218));
            Assert.That(val.G, Is.EqualTo(165));
            Assert.That(val.B, Is.EqualTo(32));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Grey constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Grey_i ()
        {
            var val = Rgba32.Grey;
            Assert.That(val.R, Is.EqualTo(128));
            Assert.That(val.G, Is.EqualTo(128));
            Assert.That(val.B, Is.EqualTo(128));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Green constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Green_i ()
        {
            var val = Rgba32.Green;
            Assert.That(val.R, Is.EqualTo(0));
            Assert.That(val.G, Is.EqualTo(128));
            Assert.That(val.B, Is.EqualTo(0));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the GreenYellow constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_GreenYellow_i ()
        {
            var val = Rgba32.GreenYellow;
            Assert.That(val.R, Is.EqualTo(173));
            Assert.That(val.G, Is.EqualTo(255));
            Assert.That(val.B, Is.EqualTo(47));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Honeydew constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Honeydew_i ()
        {
            var val = Rgba32.Honeydew;
            Assert.That(val.R, Is.EqualTo(240));
            Assert.That(val.G, Is.EqualTo(255));
            Assert.That(val.B, Is.EqualTo(240));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the HotPink constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_HotPink_i ()
        {
            var val = Rgba32.HotPink;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(105));
            Assert.That(val.B, Is.EqualTo(180));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the IndianRed constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_IndianRed_i ()
        {
            var val = Rgba32.IndianRed;
            Assert.That(val.R, Is.EqualTo(205));
            Assert.That(val.G, Is.EqualTo(92));
            Assert.That(val.B, Is.EqualTo(92));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Indigo constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Indigo_i ()
        {
            var val = Rgba32.Indigo;
            Assert.That(val.R, Is.EqualTo(75));
            Assert.That(val.G, Is.EqualTo(0));
            Assert.That(val.B, Is.EqualTo(130));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Ivory constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Ivory_i ()
        {
            var val = Rgba32.Ivory;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(255));
            Assert.That(val.B, Is.EqualTo(240));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Khaki constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Khaki_i ()
        {
            var val = Rgba32.Khaki;
            Assert.That(val.R, Is.EqualTo(240));
            Assert.That(val.G, Is.EqualTo(230));
            Assert.That(val.B, Is.EqualTo(140));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Lavender constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Lavender_i ()
        {
            var val = Rgba32.Lavender;
            Assert.That(val.R, Is.EqualTo(230));
            Assert.That(val.G, Is.EqualTo(230));
            Assert.That(val.B, Is.EqualTo(250));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the LavenderBlush constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_LavenderBlush_i ()
        {
            var val = Rgba32.LavenderBlush;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(240));
            Assert.That(val.B, Is.EqualTo(245));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the LawnGreen constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_LawnGreen_i ()
        {
            var val = Rgba32.LawnGreen;
            Assert.That(val.R, Is.EqualTo(124));
            Assert.That(val.G, Is.EqualTo(252));
            Assert.That(val.B, Is.EqualTo(0));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the LemonChiffon constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_LemonChiffon_i ()
        {
            var val = Rgba32.LemonChiffon;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(250));
            Assert.That(val.B, Is.EqualTo(205));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the LightBlue constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_LightBlue_i ()
        {
            var val = Rgba32.LightBlue;
            Assert.That(val.R, Is.EqualTo(173));
            Assert.That(val.G, Is.EqualTo(216));
            Assert.That(val.B, Is.EqualTo(230));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the LightCoral constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_LightCoral_i ()
        {
            var val = Rgba32.LightCoral;
            Assert.That(val.R, Is.EqualTo(240));
            Assert.That(val.G, Is.EqualTo(128));
            Assert.That(val.B, Is.EqualTo(128));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the LightCyan constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_LightCyan_i ()
        {
            var val = Rgba32.LightCyan;
            Assert.That(val.R, Is.EqualTo(224));
            Assert.That(val.G, Is.EqualTo(255));
            Assert.That(val.B, Is.EqualTo(255));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the LightGoldenrodYellow constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_LightGoldenrodYellow_i ()
        {
            var val = Rgba32.LightGoldenrodYellow;
            Assert.That(val.R, Is.EqualTo(250));
            Assert.That(val.G, Is.EqualTo(250));
            Assert.That(val.B, Is.EqualTo(210));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the LightGreen constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_LightGreen_i ()
        {
            var val = Rgba32.LightGreen;
            Assert.That(val.R, Is.EqualTo(144));
            Assert.That(val.G, Is.EqualTo(238));
            Assert.That(val.B, Is.EqualTo(144));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the LightGrey constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_LightGrey_i ()
        {
            var val = Rgba32.LightGrey;
            Assert.That(val.R, Is.EqualTo(211));
            Assert.That(val.G, Is.EqualTo(211));
            Assert.That(val.B, Is.EqualTo(211));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the LightPink constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_LightPink_i ()
        {
            var val = Rgba32.LightPink;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(182));
            Assert.That(val.B, Is.EqualTo(193));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the LightSalmon constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_LightSalmon_i ()
        {
            var val = Rgba32.LightSalmon;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(160));
            Assert.That(val.B, Is.EqualTo(122));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the LightSeaGreen constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_LightSeaGreen_i ()
        {
            var val = Rgba32.LightSeaGreen;
            Assert.That(val.R, Is.EqualTo(32));
            Assert.That(val.G, Is.EqualTo(178));
            Assert.That(val.B, Is.EqualTo(170));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the LightSkyBlue constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_LightSkyBlue_i ()
        {
            var val = Rgba32.LightSkyBlue;
            Assert.That(val.R, Is.EqualTo(135));
            Assert.That(val.G, Is.EqualTo(206));
            Assert.That(val.B, Is.EqualTo(250));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the LightSlateGrey constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_LightSlateGrey_i ()
        {
            var val = Rgba32.LightSlateGrey;
            Assert.That(val.R, Is.EqualTo(119));
            Assert.That(val.G, Is.EqualTo(136));
            Assert.That(val.B, Is.EqualTo(153));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the LightSteelBlue constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_LightSteelBlue_i ()
        {
            var val = Rgba32.LightSteelBlue;
            Assert.That(val.R, Is.EqualTo(176));
            Assert.That(val.G, Is.EqualTo(196));
            Assert.That(val.B, Is.EqualTo(222));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the LightYellow constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_LightYellow_i ()
        {
            var val = Rgba32.LightYellow;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(255));
            Assert.That(val.B, Is.EqualTo(224));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Lime constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Lime_i ()
        {
            var val = Rgba32.Lime;
            Assert.That(val.R, Is.EqualTo(0));
            Assert.That(val.G, Is.EqualTo(255));
            Assert.That(val.B, Is.EqualTo(0));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the LimeGreen constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_LimeGreen_i ()
        {
            var val = Rgba32.LimeGreen;
            Assert.That(val.R, Is.EqualTo(50));
            Assert.That(val.G, Is.EqualTo(205));
            Assert.That(val.B, Is.EqualTo(50));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Linen constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Linen_i ()
        {
            var val = Rgba32.Linen;
            Assert.That(val.R, Is.EqualTo(250));
            Assert.That(val.G, Is.EqualTo(240));
            Assert.That(val.B, Is.EqualTo(230));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Magenta constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Magenta_i ()
        {
            var val = Rgba32.Magenta;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(0));
            Assert.That(val.B, Is.EqualTo(255));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Maroon constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Maroon_i ()
        {
            var val = Rgba32.Maroon;
            Assert.That(val.R, Is.EqualTo(128));
            Assert.That(val.G, Is.EqualTo(0));
            Assert.That(val.B, Is.EqualTo(0));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the MediumAquamarine constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_MediumAquamarine_i ()
        {
            var val = Rgba32.MediumAquamarine;
            Assert.That(val.R, Is.EqualTo(102));
            Assert.That(val.G, Is.EqualTo(205));
            Assert.That(val.B, Is.EqualTo(170));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the MediumBlue constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_MediumBlue_i ()
        {
            var val = Rgba32.MediumBlue;
            Assert.That(val.R, Is.EqualTo(0));
            Assert.That(val.G, Is.EqualTo(0));
            Assert.That(val.B, Is.EqualTo(205));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the MediumOrchid constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_MediumOrchid_i ()
        {
            var val = Rgba32.MediumOrchid;
            Assert.That(val.R, Is.EqualTo(186));
            Assert.That(val.G, Is.EqualTo(85));
            Assert.That(val.B, Is.EqualTo(211));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the MediumPurple constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_MediumPurple_i ()
        {
            var val = Rgba32.MediumPurple;
            Assert.That(val.R, Is.EqualTo(147));
            Assert.That(val.G, Is.EqualTo(112));
            Assert.That(val.B, Is.EqualTo(219));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the MediumSeaGreen constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_MediumSeaGreen_i ()
        {
            var val = Rgba32.MediumSeaGreen;
            Assert.That(val.R, Is.EqualTo(60));
            Assert.That(val.G, Is.EqualTo(179));
            Assert.That(val.B, Is.EqualTo(113));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the MediumSlateBlue constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_MediumSlateBlue_i ()
        {
            var val = Rgba32.MediumSlateBlue;
            Assert.That(val.R, Is.EqualTo(123));
            Assert.That(val.G, Is.EqualTo(104));
            Assert.That(val.B, Is.EqualTo(238));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the MediumSpringGreen constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_MediumSpringGreen_i ()
        {
            var val = Rgba32.MediumSpringGreen;
            Assert.That(val.R, Is.EqualTo(0));
            Assert.That(val.G, Is.EqualTo(250));
            Assert.That(val.B, Is.EqualTo(154));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the MediumTurquoise constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_MediumTurquoise_i ()
        {
            var val = Rgba32.MediumTurquoise;
            Assert.That(val.R, Is.EqualTo(72));
            Assert.That(val.G, Is.EqualTo(209));
            Assert.That(val.B, Is.EqualTo(204));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the MediumVioletRed constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_MediumVioletRed_i ()
        {
            var val = Rgba32.MediumVioletRed;
            Assert.That(val.R, Is.EqualTo(199));
            Assert.That(val.G, Is.EqualTo(21));
            Assert.That(val.B, Is.EqualTo(133));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the MidnightBlue constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_MidnightBlue_i ()
        {
            var val = Rgba32.MidnightBlue;
            Assert.That(val.R, Is.EqualTo(25));
            Assert.That(val.G, Is.EqualTo(25));
            Assert.That(val.B, Is.EqualTo(112));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the MintCream constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_MintCream_i ()
        {
            var val = Rgba32.MintCream;
            Assert.That(val.R, Is.EqualTo(245));
            Assert.That(val.G, Is.EqualTo(255));
            Assert.That(val.B, Is.EqualTo(250));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the MistyRose constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_MistyRose_i ()
        {
            var val = Rgba32.MistyRose;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(228));
            Assert.That(val.B, Is.EqualTo(225));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Moccasin constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Moccasin_i ()
        {
            var val = Rgba32.Moccasin;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(228));
            Assert.That(val.B, Is.EqualTo(181));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the NavajoWhite constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_NavajoWhite_i ()
        {
            var val = Rgba32.NavajoWhite;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(222));
            Assert.That(val.B, Is.EqualTo(173));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Navy constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Navy_i ()
        {
            var val = Rgba32.Navy;
            Assert.That(val.R, Is.EqualTo(0));
            Assert.That(val.G, Is.EqualTo(0));
            Assert.That(val.B, Is.EqualTo(128));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the OldLace constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_OldLace_i ()
        {
            var val = Rgba32.OldLace;
            Assert.That(val.R, Is.EqualTo(253));
            Assert.That(val.G, Is.EqualTo(245));
            Assert.That(val.B, Is.EqualTo(230));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Olive constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Olive_i ()
        {
            var val = Rgba32.Olive;
            Assert.That(val.R, Is.EqualTo(128));
            Assert.That(val.G, Is.EqualTo(128));
            Assert.That(val.B, Is.EqualTo(0));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the OliveDrab constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_OliveDrab_i ()
        {
            var val = Rgba32.OliveDrab;
            Assert.That(val.R, Is.EqualTo(107));
            Assert.That(val.G, Is.EqualTo(142));
            Assert.That(val.B, Is.EqualTo(35));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Orange constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Orange_i ()
        {
            var val = Rgba32.Orange;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(165));
            Assert.That(val.B, Is.EqualTo(0));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the OrangeRed constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_OrangeRed_i ()
        {
            var val = Rgba32.OrangeRed;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(69));
            Assert.That(val.B, Is.EqualTo(0));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Orchid constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Orchid_i ()
        {
            var val = Rgba32.Orchid;
            Assert.That(val.R, Is.EqualTo(218));
            Assert.That(val.G, Is.EqualTo(112));
            Assert.That(val.B, Is.EqualTo(214));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the PaleGoldenrod constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_PaleGoldenrod_i ()
        {
            var val = Rgba32.PaleGoldenrod;
            Assert.That(val.R, Is.EqualTo(238));
            Assert.That(val.G, Is.EqualTo(232));
            Assert.That(val.B, Is.EqualTo(170));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the PaleGreen constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_PaleGreen_i ()
        {
            var val = Rgba32.PaleGreen;
            Assert.That(val.R, Is.EqualTo(152));
            Assert.That(val.G, Is.EqualTo(251));
            Assert.That(val.B, Is.EqualTo(152));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the PaleTurquoise constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_PaleTurquoise_i ()
        {
            var val = Rgba32.PaleTurquoise;
            Assert.That(val.R, Is.EqualTo(175));
            Assert.That(val.G, Is.EqualTo(238));
            Assert.That(val.B, Is.EqualTo(238));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the PaleVioletRed constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_PaleVioletRed_i ()
        {
            var val = Rgba32.PaleVioletRed;
            Assert.That(val.R, Is.EqualTo(219));
            Assert.That(val.G, Is.EqualTo(112));
            Assert.That(val.B, Is.EqualTo(147));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the PapayaWhip constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_PapayaWhip_i ()
        {
            var val = Rgba32.PapayaWhip;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(239));
            Assert.That(val.B, Is.EqualTo(213));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the PeachPuff constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_PeachPuff_i ()
        {
            var val = Rgba32.PeachPuff;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(218));
            Assert.That(val.B, Is.EqualTo(185));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Peru constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Peru_i ()
        {
            var val = Rgba32.Peru;
            Assert.That(val.R, Is.EqualTo(205));
            Assert.That(val.G, Is.EqualTo(133));
            Assert.That(val.B, Is.EqualTo(63));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Pink constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Pink_i ()
        {
            var val = Rgba32.Pink;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(192));
            Assert.That(val.B, Is.EqualTo(203));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Plum constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Plum_i ()
        {
            var val = Rgba32.Plum;
            Assert.That(val.R, Is.EqualTo(221));
            Assert.That(val.G, Is.EqualTo(160));
            Assert.That(val.B, Is.EqualTo(221));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the PowderBlue constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_PowderBlue_i ()
        {
            var val = Rgba32.PowderBlue;
            Assert.That(val.R, Is.EqualTo(176));
            Assert.That(val.G, Is.EqualTo(224));
            Assert.That(val.B, Is.EqualTo(230));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Purple constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Purple_i ()
        {
            var val = Rgba32.Purple;
            Assert.That(val.R, Is.EqualTo(128));
            Assert.That(val.G, Is.EqualTo(0));
            Assert.That(val.B, Is.EqualTo(128));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Red constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Red_i ()
        {
            var val = Rgba32.Red;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(0));
            Assert.That(val.B, Is.EqualTo(0));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the RosyBrown constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_RosyBrown_i ()
        {
            var val = Rgba32.RosyBrown;
            Assert.That(val.R, Is.EqualTo(188));
            Assert.That(val.G, Is.EqualTo(143));
            Assert.That(val.B, Is.EqualTo(143));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the RoyalBlue constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_RoyalBlue_i ()
        {
            var val = Rgba32.RoyalBlue;
            Assert.That(val.R, Is.EqualTo(65));
            Assert.That(val.G, Is.EqualTo(105));
            Assert.That(val.B, Is.EqualTo(225));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the SaddleBrown constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_SaddleBrown_i ()
        {
            var val = Rgba32.SaddleBrown;
            Assert.That(val.R, Is.EqualTo(139));
            Assert.That(val.G, Is.EqualTo(69));
            Assert.That(val.B, Is.EqualTo(19));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Salmon constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Salmon_i ()
        {
            var val = Rgba32.Salmon;
            Assert.That(val.R, Is.EqualTo(250));
            Assert.That(val.G, Is.EqualTo(128));
            Assert.That(val.B, Is.EqualTo(114));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the SandyBrown constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_SandyBrown_i ()
        {
            var val = Rgba32.SandyBrown;
            Assert.That(val.R, Is.EqualTo(244));
            Assert.That(val.G, Is.EqualTo(164));
            Assert.That(val.B, Is.EqualTo(96));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the SeaGreen constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_SeaGreen_i ()
        {
            var val = Rgba32.SeaGreen;
            Assert.That(val.R, Is.EqualTo(46));
            Assert.That(val.G, Is.EqualTo(139));
            Assert.That(val.B, Is.EqualTo(87));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the SeaShell constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_SeaShell_i ()
        {
            var val = Rgba32.SeaShell;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(245));
            Assert.That(val.B, Is.EqualTo(238));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Sienna constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Sienna_i ()
        {
            var val = Rgba32.Sienna;
            Assert.That(val.R, Is.EqualTo(160));
            Assert.That(val.G, Is.EqualTo(82));
            Assert.That(val.B, Is.EqualTo(45));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Silver constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Silver_i ()
        {
            var val = Rgba32.Silver;
            Assert.That(val.R, Is.EqualTo(192));
            Assert.That(val.G, Is.EqualTo(192));
            Assert.That(val.B, Is.EqualTo(192));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the SkyBlue constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_SkyBlue_i ()
        {
            var val = Rgba32.SkyBlue;
            Assert.That(val.R, Is.EqualTo(135));
            Assert.That(val.G, Is.EqualTo(206));
            Assert.That(val.B, Is.EqualTo(235));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the SlateBlue constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_SlateBlue_i ()
        {
            var val = Rgba32.SlateBlue;
            Assert.That(val.R, Is.EqualTo(106));
            Assert.That(val.G, Is.EqualTo(90));
            Assert.That(val.B, Is.EqualTo(205));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the SlateGrey constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_SlateGrey_i ()
        {
            var val = Rgba32.SlateGrey;
            Assert.That(val.R, Is.EqualTo(112));
            Assert.That(val.G, Is.EqualTo(128));
            Assert.That(val.B, Is.EqualTo(144));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Snow constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Snow_i ()
        {
            var val = Rgba32.Snow;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(250));
            Assert.That(val.B, Is.EqualTo(250));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the SpringGreen constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_SpringGreen_i ()
        {
            var val = Rgba32.SpringGreen;
            Assert.That(val.R, Is.EqualTo(0));
            Assert.That(val.G, Is.EqualTo(255));
            Assert.That(val.B, Is.EqualTo(127));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the SteelBlue constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_SteelBlue_i ()
        {
            var val = Rgba32.SteelBlue;
            Assert.That(val.R, Is.EqualTo(70));
            Assert.That(val.G, Is.EqualTo(130));
            Assert.That(val.B, Is.EqualTo(180));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Tan constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Tan_i ()
        {
            var val = Rgba32.Tan;
            Assert.That(val.R, Is.EqualTo(210));
            Assert.That(val.G, Is.EqualTo(180));
            Assert.That(val.B, Is.EqualTo(140));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Teal constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Teal_i ()
        {
            var val = Rgba32.Teal;
            Assert.That(val.R, Is.EqualTo(0));
            Assert.That(val.G, Is.EqualTo(128));
            Assert.That(val.B, Is.EqualTo(128));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Thistle constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Thistle_i ()
        {
            var val = Rgba32.Thistle;
            Assert.That(val.R, Is.EqualTo(216));
            Assert.That(val.G, Is.EqualTo(191));
            Assert.That(val.B, Is.EqualTo(216));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Tomato constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Tomato_i ()
        {
            var val = Rgba32.Tomato;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(99));
            Assert.That(val.B, Is.EqualTo(71));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Turquoise constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Turquoise_i ()
        {
            var val = Rgba32.Turquoise;
            Assert.That(val.R, Is.EqualTo(64));
            Assert.That(val.G, Is.EqualTo(224));
            Assert.That(val.B, Is.EqualTo(208));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Violet constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Violet_i ()
        {
            var val = Rgba32.Violet;
            Assert.That(val.R, Is.EqualTo(238));
            Assert.That(val.G, Is.EqualTo(130));
            Assert.That(val.B, Is.EqualTo(238));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Wheat constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Wheat_i ()
        {
            var val = Rgba32.Wheat;
            Assert.That(val.R, Is.EqualTo(245));
            Assert.That(val.G, Is.EqualTo(222));
            Assert.That(val.B, Is.EqualTo(179));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the White constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_White_i ()
        {
            var val = Rgba32.White;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(255));
            Assert.That(val.B, Is.EqualTo(255));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the WhiteSmoke constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_WhiteSmoke_i ()
        {
            var val = Rgba32.WhiteSmoke;
            Assert.That(val.R, Is.EqualTo(245));
            Assert.That(val.G, Is.EqualTo(245));
            Assert.That(val.B, Is.EqualTo(245));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the Yellow constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_Yellow_i ()
        {
            var val = Rgba32.Yellow;
            Assert.That(val.R, Is.EqualTo(255));
            Assert.That(val.G, Is.EqualTo(255));
            Assert.That(val.B, Is.EqualTo(0));
            Assert.That(val.A, Is.EqualTo(255));
        }

        /// <summary>
        /// Tests that the YellowGreen constant yeilds the correct value.
        /// </summary>
        [Test]
        public void TestConstant_YellowGreen_i ()
        {
            var val = Rgba32.YellowGreen;
            Assert.That(val.R, Is.EqualTo(154));
            Assert.That(val.G, Is.EqualTo(205));
            Assert.That(val.B, Is.EqualTo(50));
            Assert.That(val.A, Is.EqualTo(255));
        }


        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void Test_Constructors_ii ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_FromNonPremultiplied_i ()
        {
            throw new InconclusiveException ("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_FromNonPremultiplied_ii ()
        {
            throw new InconclusiveException ("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_i ()
        {
            throw new InconclusiveException ("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestMemberFn_ToVector3_i ()
        {
            throw new InconclusiveException ("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Desaturate_i ()
        {
            throw new InconclusiveException ("Not Implemented");
        }

        void TestMultiplication ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// Assert that, for a known example, all the multiplication opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_i ()
        {
            this.TestMultiplication();
        }
    }

    /// <summary>
    /// Tests the Rgba64 packed data type.
    /// </summary>
    [TestFixture]
    public class Rgba64Tests
    {
        /// <summary>
        /// Iterates over a random selection of values within the range of
        /// possible Rgba64 values and makes sure that unpacking them and
        /// then re-packing that result yeilds the original packed value.
        /// </summary>
        [Test]
        public void TestRandomValues_i()
        {
            var rand = new System.Random();
            var buff = new Byte[8];

            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                rand.NextBytes(buff);
                UInt64 packed = BitConverter.ToUInt64(buff, 0);
                var packedObj = new Rgba64();
                packedObj.PackedValue = packed;
                SinglePrecision.Vector4 unpacked;
                packedObj.UnpackTo(out unpacked);
                var newPackedObj = new Rgba64(ref unpacked);
                Assert.That(newPackedObj.PackedValue, Is.EqualTo(packed));
            }
        }

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i()
        {
            var testCase = new Rgba64();
            var f = new SinglePrecision.Vector4(0.656f, 0.125f, 0.222f, 0.861f);
            testCase.PackFrom(ref f);
            String s = testCase.ToString ();
            Assert.That(s, Is.EqualTo("DC6A38D52000A7EF"));
        }

        /// <summary>
        /// Makes sure that the hashing function is good by testing
        /// random scenarios and ensuring that there are no more than a
        /// reasonable number of collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            HashSet<Int32> hs = new HashSet<Int32>();
            var rand = new System.Random();
            var buff = new Byte[8];
            UInt32 collisions = 0;
            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                rand.NextBytes(buff);
                UInt64 packed = BitConverter.ToUInt64(buff, 0);
                var packedObj = new Rgba64();
                packedObj.PackedValue = packed;
                Int32 hc = packedObj.GetHashCode ();
                if(hs.Contains(hc)) ++collisions;
                hs.Add(hc);
            }
            Assert.That(collisions, Is.LessThan(10));
        }
    }

    /// <summary>
    /// Tests the Rgba_10_10_10_2 packed data type.
    /// </summary>
    [TestFixture]
    public class Rgba_10_10_10_2Tests
    {
        /// <summary>
        /// Iterates over a random selection of values within the range of
        /// possible Rgba_10_10_10_2 values and makes sure that unpacking them and 
        /// then re-packing that result yeilds the original packed value.
        /// </summary>
        [Test]
        public void TestRandomValues_i()
        {
            var rand = new System.Random();
            var buff = new Byte[4];
            
            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                rand.NextBytes(buff);
                UInt32 packed = BitConverter.ToUInt32(buff, 0);
                var packedObj = new Rgba_10_10_10_2();
                packedObj.PackedValue = packed;
                SinglePrecision.Vector4 unpacked;
                packedObj.UnpackTo(out unpacked);
                var newPackedObj = new Rgba_10_10_10_2(ref unpacked);
                Assert.That(newPackedObj.PackedValue, Is.EqualTo(packed));
            }
        }

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i()
        {
            var testCase = new Rgba_10_10_10_2();
            var f = new SinglePrecision.Vector4(0.656f, 0.125f, 0.222f, 0.861f);
            testCase.PackFrom(ref f);
            String s = testCase.ToString ();
            Assert.That(s, Is.EqualTo("8DD0A7EF"));
        }

        /// <summary>
        /// Makes sure that the hashing function is good by testing 
        /// random scenarios and ensuring that there are no more than a 
        /// reasonable number of collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            HashSet<Int32> hs = new HashSet<Int32>();
            var rand = new System.Random();
            var buff = new Byte[4];
            UInt32 collisions = 0;
            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                rand.NextBytes(buff);
                UInt32 packed = BitConverter.ToUInt32(buff, 0);
                var packedObj = new Rgba_10_10_10_2();
                packedObj.PackedValue = packed;
                Int32 hc = packedObj.GetHashCode ();
                if(hs.Contains(hc)) ++collisions;
                hs.Add(hc);
            }
            Assert.That(collisions, Is.LessThan(10));
        }
    }

    /// <summary>
    /// Tests the Short2 packed data type.
    /// </summary>
    [TestFixture]
    public class Short2Tests
    {
        /// <summary>
        /// Iterates over a random selection of values within the range of
        /// possible Short2 values and makes sure that unpacking them and 
        /// then re-packing that result yeilds the original packed value.
        /// </summary>
        [Test]
        public void TestRandomValues_i()
        {
            var rand = new System.Random();
            var buff = new Byte[4];
            
            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                rand.NextBytes(buff);
                UInt32 packed = BitConverter.ToUInt32(buff, 0);
                var packedObj = new Short2();
                packedObj.PackedValue = packed;
                SinglePrecision.Vector2 unpacked;
                packedObj.UnpackTo(out unpacked);
                var newPackedObj = new Short2(ref unpacked);
                Assert.That(newPackedObj.PackedValue, Is.EqualTo(packed));
            }
        }

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i()
        {
            var testCase = new Short2();
            var f = new SinglePrecision.Vector2(0.656f, 0.125f);
            testCase.PackFrom(ref f);
            String s = testCase.ToString ();
            Assert.That(s, Is.EqualTo("00000001"));
        }

        /// <summary>
        /// Makes sure that the hashing function is good by testing 
        /// random scenarios and ensuring that there are no more than a 
        /// reasonable number of collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            HashSet<Int32> hs = new HashSet<Int32>();
            var rand = new System.Random();
            var buff = new Byte[4];
            UInt32 collisions = 0;
            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                rand.NextBytes(buff);
                UInt32 packed = BitConverter.ToUInt32(buff, 0);
                var packedObj = new Short2();
                packedObj.PackedValue = packed;
                Int32 hc = packedObj.GetHashCode ();
                if(hs.Contains(hc)) ++collisions;
                hs.Add(hc);
            }
            Assert.That(collisions, Is.LessThan(10));
        }
    }

    /// <summary>
    /// Tests the Short4 packed data type.
    /// </summary>
    [TestFixture]
    public class Short4Tests
    {
        /// <summary>
        /// Iterates over a random selection of values within the range of
        /// possible Short4 values and makes sure that unpacking them and 
        /// then re-packing that result yeilds the original packed value.
        /// </summary>
        [Test]
        public void TestRandomValues_i()
        {
            var rand = new System.Random();
            var buff = new Byte[8];
            
            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                rand.NextBytes(buff);
                UInt64 packed = BitConverter.ToUInt64(buff, 0);
                var packedObj = new Short4();
                packedObj.PackedValue = packed;
                SinglePrecision.Vector4 unpacked;
                packedObj.UnpackTo(out unpacked);
                var newPackedObj = new Short4(ref unpacked);
                Assert.That(newPackedObj.PackedValue, Is.EqualTo(packedObj.PackedValue));
            }
        }

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i()
        {
            var testCase = new Short4();
            var f = new SinglePrecision.Vector4(0.656f, 0.125f, 0.222f, 0.861f);
            testCase.PackFrom(ref f);
            String s = testCase.ToString ();
            Assert.That(s, Is.EqualTo("1000000000001"));
        }

        /// <summary>
        /// Makes sure that the hashing function is good by testing 
        /// random scenarios and ensuring that there are no more than a 
        /// reasonable number of collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            HashSet<Int32> hs = new HashSet<Int32>();
            var rand = new System.Random();
            var buff = new Byte[8];
            UInt32 collisions = 0;
            for(Int32 i = 0; i < Settings.NumTests; ++i)
            {
                rand.NextBytes(buff);
                UInt64 packed = BitConverter.ToUInt64(buff, 0);
                var packedObj = new Short4();
                packedObj.PackedValue = packed;
                Int32 hc = packedObj.GetHashCode ();
                if(hs.Contains(hc)) ++collisions;
                hs.Add(hc);
            }
            Assert.That(collisions, Is.LessThan(10));
        }
    }

}

namespace Abacus.Int32Precision.Tests
{
    /// <summary>
    /// todo
    /// </summary>
    [TestFixture]
    public class Point2Tests
    {
        /// <summary>
        /// The random number generator used for testing.
        /// </summary>
        static readonly System.Random rand;

        /// <summary>
        /// Static constructor used to ensure that the random number generator
        /// always gets initilised with the same seed, making the tests
        /// behave in a deterministic manner.
        /// </summary>
        static Point2Tests ()
        {
            rand = new System.Random(0);
        }

        /// <summary>
        /// Helper function for getting the next random Int32 value.
        /// </summary>
        static Int32 GetNextRandomInt32 ()
        {
            Int32 randomValue = rand.Next();

            Int32 zero = 0;
            Int32 multiplier = 1000;

            randomValue *= multiplier;

            Boolean randomBoolean = (rand.Next(0, 1) == 0) ? true : false;

            if( randomBoolean )
                randomValue = zero - randomValue;

            return randomValue;
        }

        /// <summary>
        /// Helper function for getting the next random Point2.
        /// </summary>
        static Point2 GetNextRandomPoint2 ()
        {
            Int32 a = GetNextRandomInt32();
            Int32 b = GetNextRandomInt32();

            return new Point2(a, b);
        }

        /// <summary>
        /// Helper to encapsulate asserting that two Point2s are equal.
        /// </summary>
        static void AssertEqualWithinReason (Point2 a, Point2 b)
        {
            Assert.That(a.X, Is.EqualTo(b.X));
            Assert.That(a.Y, Is.EqualTo(b.Y));
        }
        

        // Test: StructLayout //----------------------------------------------//

        /// <summary>
        /// This test makes sure that the struct layout has been defined
        /// correctly.
        /// </summary>
        [Test]
        public void Test_StructLayout_i ()
        {
            Type t = typeof(Point2);

            Assert.That(
                t.StructLayoutAttribute.Value, 
                Is.EqualTo(LayoutKind.Sequential));
        }

        /// <summary>
        /// This test makes sure that when examining the memory addresses of the 
        /// X and Y member variables of a number of randomly generated Point2
        /// objects the results are as expected. 
        /// </summary>
        [Test]
        public unsafe void Test_StructLayout_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Point2 pnt = GetNextRandomPoint2();

                GCHandle h_pnt = GCHandle.Alloc(pnt, GCHandleType.Pinned);

                IntPtr pntAddress = h_pnt.AddrOfPinnedObject();

                Int32[] data = new Int32[2];

                // nb: when Fixed32 and Half are moved back into the main
                //     dev branch there will be need for an extension method for
                //     Marshal that will perform the copy for those types. 
                MarshalHelper.Copy(pntAddress, data, 0, 2);
                Assert.That(data[0], Is.EqualTo(pnt.X));
                Assert.That(data[1], Is.EqualTo(pnt.Y));
                
                h_pnt.Free();
            }
        }

        // Test: Constructors //----------------------------------------------//

        /// <summary>
        /// This test goes though each public constuctor and ensures that the 
        /// data members of the structure have been properly set.
        /// </summary>
        [Test]
        public void Test_Constructors_i ()
        {
            {
                // Test default values
                Point2 a = new Point2();
                Assert.That(a, Is.EqualTo(Point2.Zero));
            }
            {
                // Test Point2( Int32, Int32 )
                Int32 u = -189;
                Int32 v = 429;
                Point2 c = new Point2(u, v);
                Assert.That(c.X, Is.EqualTo(u));
                Assert.That(c.Y, Is.EqualTo(v));
            }
            {
                // Test no constructor
                Point2 e;
                e.X = 0;
                e.Y = 0;
                Assert.That(e, Is.EqualTo(Point2.Zero));
            }
        }

        // Test Member Fn: ToString //----------------------------------------//

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i ()
        {
            Point2 a = new Point2(42, -17);

            String result = a.ToString();

            String expected = "{X:42 Y:-17}";

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: GetHashCode //-------------------------------------//

        /// <summary>
        /// Makes sure that the hashing function is good by testing 10,000
        /// random scenarios and ensuring that there are no more than 10
        /// collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            var hs1 = new System.Collections.Generic.HashSet<Point2>();
            var hs2 = new System.Collections.Generic.HashSet<Int32>();

            for(Int32 i = 0; i < 10000; ++i)
            {
                var a = GetNextRandomPoint2();

                hs1.Add(a);
                hs2.Add(a.GetHashCode());
            }

            Assert.That(hs1.Count, Is.EqualTo(hs2.Count).Within(10));
        }

        // Test Constant: Zero //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point2 initilised using the Zero constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Zero_i ()
        {
            Point2 result = Point2.Zero;
            Point2 expected = new Point2(0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: One //----------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point2 initilised using the One constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_One_i ()
        {
            Point2 result = Point2.One;
            Point2 expected = new Point2(1, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitX //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point2 initilised using the UnitX 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitX_i ()
        {
            Point2 result = Point2.UnitX;
            Point2 expected = new Point2(1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitY //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point2 initilised using the UnitY
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitY_i ()
        {
            Point2 result = Point2.UnitY;
            Point2 expected = new Point2(0, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Operator: Equality //-----------------------------------------//

        /// <summary>
        /// Helper method for testing equality.
        /// </summary>
        void TestEquality (Point2 a, Point2 b, Boolean expected )
        {
            // This test asserts the following:
            //   (a == b) == expected
            //   (b == a) == expected
            //   (a != b) == !expected
            //   (b != a) == !expected

            Boolean result_1a = (a == b);
            Boolean result_1b = (a.Equals(b));
            Boolean result_1c = (a.Equals((Object)b));
            
            Boolean result_2a = (b == a);
            Boolean result_2b = (b.Equals(a));
            Boolean result_2c = (b.Equals((Object)a));

            Boolean result_3a = (a != b);
            Boolean result_4a = (b != a);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_1c, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
            Assert.That(result_2c, Is.EqualTo(expected));
            Assert.That(result_3a, Is.EqualTo(!expected));
            Assert.That(result_4a, Is.EqualTo(!expected));
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of TRUE when two equal  
        /// Point2 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_i ()
        {
            var a = new Point2(44, -54);
            var b = new Point2(44, -54);

            Boolean expected = true;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of FALSE when two unequal  
        /// Point2 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_ii ()
        {
            var a = new Point2(44, 54);
            var b = new Point2(44, -54);

            Boolean expected = false;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Tests to make sure that all the equality opperators and functions 
        /// yield the expected result of TRUE when used on a number of randomly 
        /// generated pairs of equal Point2 objects.
        /// </summary>
        [Test]
        public void TestOperator_Equality_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint2();

                Point2 b = a;

                this.TestEquality(a, b, true);
            }
        }


        // Test Operator: Addition //-----------------------------------------//

        /// <summary>
        /// Helper method for testing addition.
        /// </summary>
        void TestAddition (Point2 a, Point2 b, Point2 expected )
        {
            // This test asserts the following:
            //   a + b == expected
            //   b + a == expected

            var result_1a = a + b;
            var result_2a = b + a;

            Point2 result_1b; Point2.Add(ref a, ref b, out result_1b);
            Point2 result_2b; Point2.Add(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the addition opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_i ()
        {
            var a = new Point2(3, -6);
            var b = new Point2(-6, 12);

            var expected = new Point2(-3, 6);

            this.TestAddition(a, b, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving the zero point, all the 
        /// addition opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_ii ()
        {
            var a = new Point2(-2313, 88);

            var expected = a;

            this.TestAddition(a, Point2.Zero, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving two zero points, all the 
        /// addition opperators and functions yield the correct result of zero.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iii ()
        {
            this.TestAddition(Point2.Zero, Point2.Zero, Point2.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// addition opperators and functions yield the same results as a
        /// manual addition calculation.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint2();
                var b = GetNextRandomPoint2();

                var expected = new Point2(a.X + b.X, a.Y + b.Y);

                this.TestAddition(a, b, expected);
            }
        }

        // Test Operator: Subtraction //--------------------------------------//
        
        /// <summary>
        /// Helper method for testing subtraction.
        /// </summary>
        void TestSubtraction (Point2 a, Point2 b, Point2 expected )
        {
            // This test asserts the following:
            //   a - b == expected
            //   b - a == -expected

            var result_1a = a - b;
            var result_2a = b - a;

            Point2 result_1b; Point2.Subtract(ref a, ref b, out result_1b);
            Point2 result_2b; Point2.Subtract(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(-expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(-expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the subtraction opperators
        /// and functions yield the correct result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_i ()
        {
            var a = new Point2(12, -4);
            var b = new Point2(15, 11);
            var expected = new Point2(-3, -15);
            this.TestSubtraction(a, b, expected);

            var c = new Point2(-423, 342);
            this.TestSubtraction(c, Point2.Zero, c);
        }

        /// <summary>
        /// Assert that when subtracting the zero point fromt the zero point, 
        /// all the subtraction opperators and functions yield the correct 
        /// result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_ii ()
        {
            this.TestSubtraction(Point2.Zero, Point2.Zero, Point2.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// subtraction opperators and functions yield the same results as a
        /// manual subtraction calculation.
        /// </summary>
        [Test]
        public void TestOperator_Subtraction_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint2();
                var b = GetNextRandomPoint2();

                var expected = new Point2(a.X - b.X, a.Y - b.Y);

                this.TestSubtraction(a, b, expected);
            }
        }

        // Test Operator: Negation //-----------------------------------------//
        
        /// <summary>
        /// Helper method for testing negation.
        /// </summary>
        void TestNegation (Point2 a, Point2 expected )
        {
            // This test asserts the following:
            //   -a == expected

            var result_1a = -a;

            Point2 result_1b; Point2.Negate(ref a, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the negation opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_i ()
        {
            Int32 r = 3432;
            Int32 s = -6218;
            Int32 t = -3432;
            Int32 u = 6218;

            var a = new Point2(r, s);
            var b = new Point2(u, t);
            var c = new Point2(t, u);
            var d = new Point2(s, r);

            this.TestNegation(a, c);
            this.TestNegation(b, d);
        }

        /// <summary>
        /// Assert that, for known examples involving the zero point, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_ii ()
        {
            Int32 t = -3432;
            Int32 u = 6218;
            Int32 r = 3432;
            Int32 s = -6218;

            var c = new Point2(t, u);
            var d = new Point2(s, r);

            this.TestNegation(c, Point2.Zero - c);
            this.TestNegation(d, Point2.Zero - d);
        }

        /// <summary>
        /// Assert that when negating the zero point, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iii ()
        {
            this.TestNegation(Point2.Zero, Point2.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// negation opperators and functions yield the same results as a
        /// manual negation calculation.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint2();
                this.TestNegation(a, Point2.Zero - a);
            }
        }

        // Test Operator: Multiplication //-----------------------------------//

        /// <summary>
        /// Helper method for testing multiplication.
        /// </summary>
        void TestMultiplication (Point2 a, Point2 b, Point2 expected )
        {
            // This test asserts the following:
            //   a * b == expected
            //   b * a == expected

            var result_1a = a * b;
            var result_2a = b * a;

            Point2 result_1b; Point2.Multiply(ref a, ref b, out result_1b);
            Point2 result_2b; Point2.Multiply(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the multiplication opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_i ()
        {
            Int32 r = 18;
            Int32 s = -54;

            Int32 x = 3;
            Int32 y = 6;
            Int32 z = -9;

            var a = new Point2(x, y);
            var b = new Point2(y, z);
            var c = new Point2(r, s);

            this.TestMultiplication(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// multiplication opperators and functions yield the same results as a
        /// manual multiplication calculation.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint2();
                var b = GetNextRandomPoint2();

                var c = new Point2(a.X * b.X, a.Y * b.Y);

                this.TestMultiplication(a, b, c);
            }
        }


        // Test Operator: Division //-----------------------------------------//

        /// <summary>
        /// Helper method for testing division.
        /// </summary>
        void TestDivision (Point2 a, Point2 b, Point2 expected )
        {
            // This test asserts the following:
            //   a / b == expected

            var result_1a = a / b;

            Point2 result_1b; Point2.Divide(ref a, ref b, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example using whole numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_i ()
        {
            Int32 r = 10;
            Int32 s = -40;

            Int32 x = 2000;
            Int32 y = 200;
            Int32 z = -5;

            var a = new Point2(x, y);
            var b = new Point2(y, z);
            var c = new Point2(r, s);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a known example using fractional numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_ii ()
        {
            Int32 t = ((Int32) 1 ) / ((Int32) 10);
            Int32 u = ((Int32) (-1) ) / ((Int32) 40 );
            Int32 x = 2000;
            Int32 y = 200;
            Int32 z = -5;

            var a = new Point2(y, z);
            var b = new Point2(x, y);
            var c = new Point2(t, u);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// division opperators and functions yield the same results as a
        /// manual addition division.
        /// </summary>
        [Test]
        public void TestOperator_Division_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint2();
                var b = GetNextRandomPoint2();

                var c = new Point2(a.X / b.X, a.Y / b.Y);

                this.TestDivision(a, b, c);
            }
        }

    }
        /// <summary>
    /// todo
    /// </summary>
    [TestFixture]
    public class Point3Tests
    {
        /// <summary>
        /// The random number generator used for testing.
        /// </summary>
        static readonly System.Random rand;

        /// <summary>
        /// Static constructor used to ensure that the random number generator
        /// always gets initilised with the same seed, making the tests
        /// behave in a deterministic manner.
        /// </summary>
        static Point3Tests ()
        {
            rand = new System.Random(0);
        }

        /// <summary>
        /// Helper function for getting the next random Int32 value.
        /// </summary>
        static Int32 GetNextRandomInt32 ()
        {
            Int32 randomValue = rand.Next();

            Int32 zero = 0;
            Int32 multiplier = 1000;

            randomValue *= multiplier;

            Boolean randomBoolean = (rand.Next(0, 1) == 0) ? true : false;

            if( randomBoolean )
                randomValue = zero - randomValue;

            return randomValue;
        }

        /// <summary>
        /// Helper function for getting the next random Point3.
        /// </summary>
        static Point3 GetNextRandomPoint3 ()
        {
            Int32 a = GetNextRandomInt32();
            Int32 b = GetNextRandomInt32();
            Int32 c = GetNextRandomInt32();

            return new Point3(a, b, c);
        }

        /// <summary>
        /// Helper to encapsulate asserting that two Point3s are equal.
        /// </summary>
        static void AssertEqualWithinReason (Point3 a, Point3 b)
        {
            Assert.That(a.X, Is.EqualTo(b.X));
            Assert.That(a.Y, Is.EqualTo(b.Y));
            Assert.That(a.Z, Is.EqualTo(b.Z));
        }
        

        // Test: StructLayout //----------------------------------------------//

        /// <summary>
        /// This test makes sure that the struct layout has been defined
        /// correctly.
        /// </summary>
        [Test]
        public void Test_StructLayout_i ()
        {
            Type t = typeof(Point3);

            Assert.That(
                t.StructLayoutAttribute.Value, 
                Is.EqualTo(LayoutKind.Sequential));
        }

        /// <summary>
        /// This test makes sure that when examining the memory addresses of the 
        /// X, Y and Z member variables of a number of randomly generated 
        /// Point3 objects the results are as expected. 
        /// </summary>
        [Test]
        public unsafe void Test_StructLayout_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Point3 pnt = GetNextRandomPoint3();

                GCHandle h_pnt = GCHandle.Alloc(pnt, GCHandleType.Pinned);

                IntPtr pntAddress = h_pnt.AddrOfPinnedObject();

                Int32[] data = new Int32[3];

                // nb: when Fixed32 and Half are moved back into the main
                //     dev branch there will be need for an extension method for
                //     Marshal that will perform the copy for those types. 
                MarshalHelper.Copy(pntAddress, data, 0, 3);
                Assert.That(data[0], Is.EqualTo(pnt.X));
                Assert.That(data[1], Is.EqualTo(pnt.Y));
                Assert.That(data[2], Is.EqualTo(pnt.Z));
                
                h_pnt.Free();
            }
        }

        // Test: Constructors //----------------------------------------------//

        /// <summary>
        /// This test goes though each public constuctor and ensures that the 
        /// data members of the structure have been properly set.
        /// </summary>
        [Test]
        public void Test_Constructors_i ()
        {
            {
                // Test default values
                Point3 a = new Point3();
                Assert.That(a, Is.EqualTo(Point3.Zero));
            }
            {
                // Test Point3( Int32, Int32, Int32 )
                Int32 a = -189;
                Int32 b = 429;
                Int32 c = 4298;
                Point3 d = new Point3(a, b, c);
                Assert.That(d.X, Is.EqualTo(a));
                Assert.That(d.Y, Is.EqualTo(b));
                Assert.That(d.Z, Is.EqualTo(c));
            }
            {
                // Test Point3( Point2, Int32 )
                Point2 a = new Point2(-189, 429);
                Int32 b = 4298;
                Point3 c = new Point3(a, b);
                Assert.That(c.X, Is.EqualTo(a.X));
                Assert.That(c.Y, Is.EqualTo(a.Y));
                Assert.That(c.Z, Is.EqualTo(b));
            }
            {
                // Test no constructor
                Point3 a;
                a.X = 0;
                a.Y = 0;
                a.Z = 0;
                Assert.That(a, Is.EqualTo(Point3.Zero));
            }
        }

        // Test Member Fn: ToString //----------------------------------------//

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i ()
        {
            Point3 a = new Point3(42, -17, 13);

            String result = a.ToString();

            String expected = "{X:42 Y:-17 Z:13}";

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: GetHashCode //-------------------------------------//

        /// <summary>
        /// Makes sure that the hashing function is good by testing 10,000
        /// random scenarios and ensuring that there are no more than 10
        /// collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            var hs1 = new System.Collections.Generic.HashSet<Point3>();
            var hs2 = new System.Collections.Generic.HashSet<Int32>();

            for(Int32 i = 0; i < 10000; ++i)
            {
                var a = GetNextRandomPoint3();

                hs1.Add(a);
                hs2.Add(a.GetHashCode());
            }

            Assert.That(hs1.Count, Is.EqualTo(hs2.Count).Within(10));
        }

        // Test Constant: Zero //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the Zero constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Zero_i ()
        {
            Point3 result = Point3.Zero;
            Point3 expected = new Point3(0, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: One //----------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the One constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_One_i ()
        {
            Point3 result = Point3.One;
            Point3 expected = new Point3(1, 1, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitX //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the UnitX 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitX_i ()
        {
            Point3 result = Point3.UnitX;
            Point3 expected = new Point3(1, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitY //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the UnitY
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitY_i ()
        {
            Point3 result = Point3.UnitY;
            Point3 expected = new Point3(0, 1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitZ //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the UnitZ
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitZ_i ()
        {
            Point3 result = Point3.UnitZ;
            Point3 expected = new Point3(0, 0, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Up //-----------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the Up
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Up_i ()
        {
            Point3 result = Point3.Up;
            Point3 expected = new Point3(0, 1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Down //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the Down
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Down_i ()
        {
            Point3 result = Point3.Down;
            Point3 expected = new Point3(0, -1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Right //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the Right
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Right_i ()
        {
            Point3 result = Point3.Right;
            Point3 expected = new Point3(1, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Left //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the Left
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Left_i ()
        {
            Point3 result = Point3.Left;
            Point3 expected = new Point3(-1, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Forward //------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the Forward
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Forward_i ()
        {
            Point3 result = Point3.Forward;
            Point3 expected = new Point3(0, 0, -1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Backward //-----------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the Backward
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Backward_i ()
        {
            Point3 result = Point3.Backward;
            Point3 expected = new Point3(0, 0, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Operator: Equality //-----------------------------------------//

        /// <summary>
        /// Helper method for testing equality.
        /// </summary>
        void TestEquality (Point3 a, Point3 b, Boolean expected )
        {
            // This test asserts the following:
            //   (a == b) == expected
            //   (b == a) == expected
            //   (a != b) == !expected
            //   (b != a) == !expected

            Boolean result_1a = (a == b);
            Boolean result_1b = (a.Equals(b));
            Boolean result_1c = (a.Equals((Object)b));
            
            Boolean result_2a = (b == a);
            Boolean result_2b = (b.Equals(a));
            Boolean result_2c = (b.Equals((Object)a));

            Boolean result_3a = (a != b);
            Boolean result_4a = (b != a);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_1c, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
            Assert.That(result_2c, Is.EqualTo(expected));
            Assert.That(result_3a, Is.EqualTo(!expected));
            Assert.That(result_4a, Is.EqualTo(!expected));
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of TRUE when two equal  
        /// Point3 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_i ()
        {
            var a = new Point3(44, -54, -22);
            var b = new Point3(44, -54, -22);

            Boolean expected = true;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of FALSE when two unequal  
        /// Point3 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_ii ()
        {
            var a = new Point3(44, 54, 2);
            var b = new Point3(44, -54, 2);

            Boolean expected = false;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Tests to make sure that all the equality opperators and functions 
        /// yield the expected result of TRUE when used on a number of randomly 
        /// generated pairs of equal Point3 objects.
        /// </summary>
        [Test]
        public void TestOperator_Equality_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint3();

                Point3 b = a;

                this.TestEquality(a, b, true);
            }
        }


        // Test Operator: Addition //-----------------------------------------//

        /// <summary>
        /// Helper method for testing addition.
        /// </summary>
        void TestAddition (Point3 a, Point3 b, Point3 expected )
        {
            // This test asserts the following:
            //   a + b == expected
            //   b + a == expected

            var result_1a = a + b;
            var result_2a = b + a;

            Point3 result_1b; Point3.Add(ref a, ref b, out result_1b);
            Point3 result_2b; Point3.Add(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the addition opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_i ()
        {
            var a = new Point3(3, -6, 44);
            var b = new Point3(-6, 12, 18);

            var expected = new Point3(-3, 6, 62);

            this.TestAddition(a, b, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving the zero point, all the 
        /// addition opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_ii ()
        {
            var a = new Point3(-2313, 88, 199);

            var expected = a;

            this.TestAddition(a, Point3.Zero, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving two zero points, all the 
        /// addition opperators and functions yield the correct result of zero.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iii ()
        {
            this.TestAddition(Point3.Zero, Point3.Zero, Point3.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// addition opperators and functions yield the same results as a
        /// manual addition calculation.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint3();
                var b = GetNextRandomPoint3();

                var expected = new Point3(
                    a.X + b.X, a.Y + b.Y, a.Z + b.Z);

                this.TestAddition(a, b, expected);
            }
        }

        // Test Operator: Subtraction //--------------------------------------//
        
        /// <summary>
        /// Helper method for testing subtraction.
        /// </summary>
        void TestSubtraction (Point3 a, Point3 b, Point3 expected )
        {
            // This test asserts the following:
            //   a - b == expected
            //   b - a == -expected

            var result_1a = a - b;
            var result_2a = b - a;

            Point3 result_1b; Point3.Subtract(ref a, ref b, out result_1b);
            Point3 result_2b; Point3.Subtract(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(-expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(-expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the subtraction opperators
        /// and functions yield the correct result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_i ()
        {
            var a = new Point3(12, -4, 14);
            var b = new Point3(15, 11, 7);
            var expected = new Point3(-3, -15, 7);
            this.TestSubtraction(a, b, expected);

            var c = new Point3(-423, 342, 7);
            this.TestSubtraction(c, Point3.Zero, c);
        }

        /// <summary>
        /// Assert that when subtracting the zero point fromt the zero point, 
        /// all the subtraction opperators and functions yield the correct 
        /// result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_ii ()
        {
            this.TestSubtraction(Point3.Zero, Point3.Zero, Point3.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// subtraction opperators and functions yield the same results as a
        /// manual subtraction calculation.
        /// </summary>
        [Test]
        public void TestOperator_Subtraction_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint3();
                var b = GetNextRandomPoint3();

                var expected = new Point3(a.X - b.X, a.Y - b.Y, a.Z - b.Z);

                this.TestSubtraction(a, b, expected);
            }
        }

        // Test Operator: Negation //-----------------------------------------//
        
        /// <summary>
        /// Helper method for testing negation.
        /// </summary>
        void TestNegation (Point3 a, Point3 expected )
        {
            // This test asserts the following:
            //   -a == expected

            var result_1a = -a;

            Point3 result_1b; Point3.Negate(ref a, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the negation opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_i ()
        {
            Int32 r = 3432;
            Int32 s = -6218;
            Int32 t = -3432;
            Int32 u = 6218;

            var a = new Point3(r, s, t);
            var b = new Point3(u, t, s);
            var c = new Point3(t, u, r);
            var d = new Point3(s, r, u);

            this.TestNegation(a, c);
            this.TestNegation(b, d);
        }

        /// <summary>
        /// Assert that, for known examples involving the zero point, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_ii ()
        {
            Int32 t = -3432;
            Int32 u = 6218;
            Int32 r = 3432;
            Int32 s = -6218;

            var c = new Point3(t, u, r);
            var d = new Point3(s, r, u);

            this.TestNegation(c, Point3.Zero - c);
            this.TestNegation(d, Point3.Zero - d);
        }

        /// <summary>
        /// Assert that when negating the zero point, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iii ()
        {
            this.TestNegation(Point3.Zero, Point3.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// negation opperators and functions yield the same results as a
        /// manual negation calculation.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint3();
                this.TestNegation(a, Point3.Zero - a);
            }
        }

        // Test Operator: Multiplication //-----------------------------------//

        /// <summary>
        /// Helper method for testing multiplication.
        /// </summary>
        void TestMultiplication (Point3 a, Point3 b, Point3 expected )
        {
            // This test asserts the following:
            //   a * b == expected
            //   b * a == expected

            var result_1a = a * b;
            var result_2a = b * a;

            Point3 result_1b; Point3.Multiply(ref a, ref b, out result_1b);
            Point3 result_2b; Point3.Multiply(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the multiplication opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_i ()
        {
            Int32 r = -27;
            Int32 s = 36;
            Int32 t = 9;

            Int32 x = 3;
            Int32 y = 6;
            Int32 z = -9;

            var a = new Point3(x, y, x);
            var b = new Point3(z, y, x);
            var c = new Point3(r, s, t);

            this.TestMultiplication(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// multiplication opperators and functions yield the same results as a
        /// manual multiplication calculation.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint3();
                var b = GetNextRandomPoint3();

                var c = new Point3(a.X * b.X, a.Y * b.Y, a.Z * b.Z);

                this.TestMultiplication(a, b, c);
            }
        }


        // Test Operator: Division //-----------------------------------------//

        /// <summary>
        /// Helper method for testing division.
        /// </summary>
        void TestDivision (Point3 a, Point3 b, Point3 expected )
        {
            // This test asserts the following:
            //   a / b == expected

            var result_1a = a / b;

            Point3 result_1b; Point3.Divide(ref a, ref b, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example using whole numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_i ()
        {
            Int32 r = 10;
            Int32 s = -40;
            Int32 t = 1;

            Int32 x = 2000;
            Int32 y = 200;
            Int32 z = -5;

            var a = new Point3(x, y, x);
            var b = new Point3(y, z, x);
            var c = new Point3(r, s, t);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a known example using fractional numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_ii ()
        {
            Int32 t = ((Int32) 1 ) / ((Int32) 10);
            Int32 u = ((Int32) (-1) ) / ((Int32) 40 );
            Int32 v = -20;
            Int32 w = 100;
            Int32 x = 2000;
            Int32 y = 200;
            Int32 z = -5;

            var a = new Point3(y, z, w);
            var b = new Point3(x, y, z);
            var c = new Point3(t, u, v);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// division opperators and functions yield the same results as a
        /// manual addition division.
        /// </summary>
        [Test]
        public void TestOperator_Division_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint3();
                var b = GetNextRandomPoint3();

                var c = new Point3(a.X / b.X, a.Y / b.Y, a.Z / b.Z);

                this.TestDivision(a, b, c);
            }
        }

    }
    }

namespace Abacus.Int64Precision.Tests
{
    /// <summary>
    /// todo
    /// </summary>
    [TestFixture]
    public class Point2Tests
    {
        /// <summary>
        /// The random number generator used for testing.
        /// </summary>
        static readonly System.Random rand;

        /// <summary>
        /// Static constructor used to ensure that the random number generator
        /// always gets initilised with the same seed, making the tests
        /// behave in a deterministic manner.
        /// </summary>
        static Point2Tests ()
        {
            rand = new System.Random(0);
        }

        /// <summary>
        /// Helper function for getting the next random Int64 value.
        /// </summary>
        static Int64 GetNextRandomInt64 ()
        {
            Int64 randomValue = rand.Next();

            Int64 zero = 0;
            Int64 multiplier = 1000;

            randomValue *= multiplier;

            Boolean randomBoolean = (rand.Next(0, 1) == 0) ? true : false;

            if( randomBoolean )
                randomValue = zero - randomValue;

            return randomValue;
        }

        /// <summary>
        /// Helper function for getting the next random Point2.
        /// </summary>
        static Point2 GetNextRandomPoint2 ()
        {
            Int64 a = GetNextRandomInt64();
            Int64 b = GetNextRandomInt64();

            return new Point2(a, b);
        }

        /// <summary>
        /// Helper to encapsulate asserting that two Point2s are equal.
        /// </summary>
        static void AssertEqualWithinReason (Point2 a, Point2 b)
        {
            Assert.That(a.X, Is.EqualTo(b.X));
            Assert.That(a.Y, Is.EqualTo(b.Y));
        }
        

        // Test: StructLayout //----------------------------------------------//

        /// <summary>
        /// This test makes sure that the struct layout has been defined
        /// correctly.
        /// </summary>
        [Test]
        public void Test_StructLayout_i ()
        {
            Type t = typeof(Point2);

            Assert.That(
                t.StructLayoutAttribute.Value, 
                Is.EqualTo(LayoutKind.Sequential));
        }

        /// <summary>
        /// This test makes sure that when examining the memory addresses of the 
        /// X and Y member variables of a number of randomly generated Point2
        /// objects the results are as expected. 
        /// </summary>
        [Test]
        public unsafe void Test_StructLayout_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Point2 pnt = GetNextRandomPoint2();

                GCHandle h_pnt = GCHandle.Alloc(pnt, GCHandleType.Pinned);

                IntPtr pntAddress = h_pnt.AddrOfPinnedObject();

                Int64[] data = new Int64[2];

                // nb: when Fixed32 and Half are moved back into the main
                //     dev branch there will be need for an extension method for
                //     Marshal that will perform the copy for those types. 
                MarshalHelper.Copy(pntAddress, data, 0, 2);
                Assert.That(data[0], Is.EqualTo(pnt.X));
                Assert.That(data[1], Is.EqualTo(pnt.Y));
                
                h_pnt.Free();
            }
        }

        // Test: Constructors //----------------------------------------------//

        /// <summary>
        /// This test goes though each public constuctor and ensures that the 
        /// data members of the structure have been properly set.
        /// </summary>
        [Test]
        public void Test_Constructors_i ()
        {
            {
                // Test default values
                Point2 a = new Point2();
                Assert.That(a, Is.EqualTo(Point2.Zero));
            }
            {
                // Test Point2( Int64, Int64 )
                Int64 u = -189;
                Int64 v = 429;
                Point2 c = new Point2(u, v);
                Assert.That(c.X, Is.EqualTo(u));
                Assert.That(c.Y, Is.EqualTo(v));
            }
            {
                // Test no constructor
                Point2 e;
                e.X = 0;
                e.Y = 0;
                Assert.That(e, Is.EqualTo(Point2.Zero));
            }
        }

        // Test Member Fn: ToString //----------------------------------------//

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i ()
        {
            Point2 a = new Point2(42, -17);

            String result = a.ToString();

            String expected = "{X:42 Y:-17}";

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: GetHashCode //-------------------------------------//

        /// <summary>
        /// Makes sure that the hashing function is good by testing 10,000
        /// random scenarios and ensuring that there are no more than 10
        /// collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            var hs1 = new System.Collections.Generic.HashSet<Point2>();
            var hs2 = new System.Collections.Generic.HashSet<Int32>();

            for(Int32 i = 0; i < 10000; ++i)
            {
                var a = GetNextRandomPoint2();

                hs1.Add(a);
                hs2.Add(a.GetHashCode());
            }

            Assert.That(hs1.Count, Is.EqualTo(hs2.Count).Within(10));
        }

        // Test Constant: Zero //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point2 initilised using the Zero constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Zero_i ()
        {
            Point2 result = Point2.Zero;
            Point2 expected = new Point2(0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: One //----------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point2 initilised using the One constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_One_i ()
        {
            Point2 result = Point2.One;
            Point2 expected = new Point2(1, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitX //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point2 initilised using the UnitX 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitX_i ()
        {
            Point2 result = Point2.UnitX;
            Point2 expected = new Point2(1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitY //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point2 initilised using the UnitY
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitY_i ()
        {
            Point2 result = Point2.UnitY;
            Point2 expected = new Point2(0, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Operator: Equality //-----------------------------------------//

        /// <summary>
        /// Helper method for testing equality.
        /// </summary>
        void TestEquality (Point2 a, Point2 b, Boolean expected )
        {
            // This test asserts the following:
            //   (a == b) == expected
            //   (b == a) == expected
            //   (a != b) == !expected
            //   (b != a) == !expected

            Boolean result_1a = (a == b);
            Boolean result_1b = (a.Equals(b));
            Boolean result_1c = (a.Equals((Object)b));
            
            Boolean result_2a = (b == a);
            Boolean result_2b = (b.Equals(a));
            Boolean result_2c = (b.Equals((Object)a));

            Boolean result_3a = (a != b);
            Boolean result_4a = (b != a);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_1c, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
            Assert.That(result_2c, Is.EqualTo(expected));
            Assert.That(result_3a, Is.EqualTo(!expected));
            Assert.That(result_4a, Is.EqualTo(!expected));
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of TRUE when two equal  
        /// Point2 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_i ()
        {
            var a = new Point2(44, -54);
            var b = new Point2(44, -54);

            Boolean expected = true;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of FALSE when two unequal  
        /// Point2 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_ii ()
        {
            var a = new Point2(44, 54);
            var b = new Point2(44, -54);

            Boolean expected = false;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Tests to make sure that all the equality opperators and functions 
        /// yield the expected result of TRUE when used on a number of randomly 
        /// generated pairs of equal Point2 objects.
        /// </summary>
        [Test]
        public void TestOperator_Equality_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint2();

                Point2 b = a;

                this.TestEquality(a, b, true);
            }
        }


        // Test Operator: Addition //-----------------------------------------//

        /// <summary>
        /// Helper method for testing addition.
        /// </summary>
        void TestAddition (Point2 a, Point2 b, Point2 expected )
        {
            // This test asserts the following:
            //   a + b == expected
            //   b + a == expected

            var result_1a = a + b;
            var result_2a = b + a;

            Point2 result_1b; Point2.Add(ref a, ref b, out result_1b);
            Point2 result_2b; Point2.Add(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the addition opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_i ()
        {
            var a = new Point2(3, -6);
            var b = new Point2(-6, 12);

            var expected = new Point2(-3, 6);

            this.TestAddition(a, b, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving the zero point, all the 
        /// addition opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_ii ()
        {
            var a = new Point2(-2313, 88);

            var expected = a;

            this.TestAddition(a, Point2.Zero, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving two zero points, all the 
        /// addition opperators and functions yield the correct result of zero.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iii ()
        {
            this.TestAddition(Point2.Zero, Point2.Zero, Point2.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// addition opperators and functions yield the same results as a
        /// manual addition calculation.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint2();
                var b = GetNextRandomPoint2();

                var expected = new Point2(a.X + b.X, a.Y + b.Y);

                this.TestAddition(a, b, expected);
            }
        }

        // Test Operator: Subtraction //--------------------------------------//
        
        /// <summary>
        /// Helper method for testing subtraction.
        /// </summary>
        void TestSubtraction (Point2 a, Point2 b, Point2 expected )
        {
            // This test asserts the following:
            //   a - b == expected
            //   b - a == -expected

            var result_1a = a - b;
            var result_2a = b - a;

            Point2 result_1b; Point2.Subtract(ref a, ref b, out result_1b);
            Point2 result_2b; Point2.Subtract(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(-expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(-expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the subtraction opperators
        /// and functions yield the correct result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_i ()
        {
            var a = new Point2(12, -4);
            var b = new Point2(15, 11);
            var expected = new Point2(-3, -15);
            this.TestSubtraction(a, b, expected);

            var c = new Point2(-423, 342);
            this.TestSubtraction(c, Point2.Zero, c);
        }

        /// <summary>
        /// Assert that when subtracting the zero point fromt the zero point, 
        /// all the subtraction opperators and functions yield the correct 
        /// result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_ii ()
        {
            this.TestSubtraction(Point2.Zero, Point2.Zero, Point2.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// subtraction opperators and functions yield the same results as a
        /// manual subtraction calculation.
        /// </summary>
        [Test]
        public void TestOperator_Subtraction_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint2();
                var b = GetNextRandomPoint2();

                var expected = new Point2(a.X - b.X, a.Y - b.Y);

                this.TestSubtraction(a, b, expected);
            }
        }

        // Test Operator: Negation //-----------------------------------------//
        
        /// <summary>
        /// Helper method for testing negation.
        /// </summary>
        void TestNegation (Point2 a, Point2 expected )
        {
            // This test asserts the following:
            //   -a == expected

            var result_1a = -a;

            Point2 result_1b; Point2.Negate(ref a, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the negation opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_i ()
        {
            Int64 r = 3432;
            Int64 s = -6218;
            Int64 t = -3432;
            Int64 u = 6218;

            var a = new Point2(r, s);
            var b = new Point2(u, t);
            var c = new Point2(t, u);
            var d = new Point2(s, r);

            this.TestNegation(a, c);
            this.TestNegation(b, d);
        }

        /// <summary>
        /// Assert that, for known examples involving the zero point, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_ii ()
        {
            Int64 t = -3432;
            Int64 u = 6218;
            Int64 r = 3432;
            Int64 s = -6218;

            var c = new Point2(t, u);
            var d = new Point2(s, r);

            this.TestNegation(c, Point2.Zero - c);
            this.TestNegation(d, Point2.Zero - d);
        }

        /// <summary>
        /// Assert that when negating the zero point, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iii ()
        {
            this.TestNegation(Point2.Zero, Point2.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// negation opperators and functions yield the same results as a
        /// manual negation calculation.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint2();
                this.TestNegation(a, Point2.Zero - a);
            }
        }

        // Test Operator: Multiplication //-----------------------------------//

        /// <summary>
        /// Helper method for testing multiplication.
        /// </summary>
        void TestMultiplication (Point2 a, Point2 b, Point2 expected )
        {
            // This test asserts the following:
            //   a * b == expected
            //   b * a == expected

            var result_1a = a * b;
            var result_2a = b * a;

            Point2 result_1b; Point2.Multiply(ref a, ref b, out result_1b);
            Point2 result_2b; Point2.Multiply(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the multiplication opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_i ()
        {
            Int64 r = 18;
            Int64 s = -54;

            Int64 x = 3;
            Int64 y = 6;
            Int64 z = -9;

            var a = new Point2(x, y);
            var b = new Point2(y, z);
            var c = new Point2(r, s);

            this.TestMultiplication(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// multiplication opperators and functions yield the same results as a
        /// manual multiplication calculation.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint2();
                var b = GetNextRandomPoint2();

                var c = new Point2(a.X * b.X, a.Y * b.Y);

                this.TestMultiplication(a, b, c);
            }
        }


        // Test Operator: Division //-----------------------------------------//

        /// <summary>
        /// Helper method for testing division.
        /// </summary>
        void TestDivision (Point2 a, Point2 b, Point2 expected )
        {
            // This test asserts the following:
            //   a / b == expected

            var result_1a = a / b;

            Point2 result_1b; Point2.Divide(ref a, ref b, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example using whole numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_i ()
        {
            Int64 r = 10;
            Int64 s = -40;

            Int64 x = 2000;
            Int64 y = 200;
            Int64 z = -5;

            var a = new Point2(x, y);
            var b = new Point2(y, z);
            var c = new Point2(r, s);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a known example using fractional numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_ii ()
        {
            Int64 t = ((Int64) 1 ) / ((Int64) 10);
            Int64 u = ((Int64) (-1) ) / ((Int64) 40 );
            Int64 x = 2000;
            Int64 y = 200;
            Int64 z = -5;

            var a = new Point2(y, z);
            var b = new Point2(x, y);
            var c = new Point2(t, u);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// division opperators and functions yield the same results as a
        /// manual addition division.
        /// </summary>
        [Test]
        public void TestOperator_Division_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint2();
                var b = GetNextRandomPoint2();

                var c = new Point2(a.X / b.X, a.Y / b.Y);

                this.TestDivision(a, b, c);
            }
        }

    }
        /// <summary>
    /// todo
    /// </summary>
    [TestFixture]
    public class Point3Tests
    {
        /// <summary>
        /// The random number generator used for testing.
        /// </summary>
        static readonly System.Random rand;

        /// <summary>
        /// Static constructor used to ensure that the random number generator
        /// always gets initilised with the same seed, making the tests
        /// behave in a deterministic manner.
        /// </summary>
        static Point3Tests ()
        {
            rand = new System.Random(0);
        }

        /// <summary>
        /// Helper function for getting the next random Int64 value.
        /// </summary>
        static Int64 GetNextRandomInt64 ()
        {
            Int64 randomValue = rand.Next();

            Int64 zero = 0;
            Int64 multiplier = 1000;

            randomValue *= multiplier;

            Boolean randomBoolean = (rand.Next(0, 1) == 0) ? true : false;

            if( randomBoolean )
                randomValue = zero - randomValue;

            return randomValue;
        }

        /// <summary>
        /// Helper function for getting the next random Point3.
        /// </summary>
        static Point3 GetNextRandomPoint3 ()
        {
            Int64 a = GetNextRandomInt64();
            Int64 b = GetNextRandomInt64();
            Int64 c = GetNextRandomInt64();

            return new Point3(a, b, c);
        }

        /// <summary>
        /// Helper to encapsulate asserting that two Point3s are equal.
        /// </summary>
        static void AssertEqualWithinReason (Point3 a, Point3 b)
        {
            Assert.That(a.X, Is.EqualTo(b.X));
            Assert.That(a.Y, Is.EqualTo(b.Y));
            Assert.That(a.Z, Is.EqualTo(b.Z));
        }
        

        // Test: StructLayout //----------------------------------------------//

        /// <summary>
        /// This test makes sure that the struct layout has been defined
        /// correctly.
        /// </summary>
        [Test]
        public void Test_StructLayout_i ()
        {
            Type t = typeof(Point3);

            Assert.That(
                t.StructLayoutAttribute.Value, 
                Is.EqualTo(LayoutKind.Sequential));
        }

        /// <summary>
        /// This test makes sure that when examining the memory addresses of the 
        /// X, Y and Z member variables of a number of randomly generated 
        /// Point3 objects the results are as expected. 
        /// </summary>
        [Test]
        public unsafe void Test_StructLayout_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Point3 pnt = GetNextRandomPoint3();

                GCHandle h_pnt = GCHandle.Alloc(pnt, GCHandleType.Pinned);

                IntPtr pntAddress = h_pnt.AddrOfPinnedObject();

                Int64[] data = new Int64[3];

                // nb: when Fixed32 and Half are moved back into the main
                //     dev branch there will be need for an extension method for
                //     Marshal that will perform the copy for those types. 
                MarshalHelper.Copy(pntAddress, data, 0, 3);
                Assert.That(data[0], Is.EqualTo(pnt.X));
                Assert.That(data[1], Is.EqualTo(pnt.Y));
                Assert.That(data[2], Is.EqualTo(pnt.Z));
                
                h_pnt.Free();
            }
        }

        // Test: Constructors //----------------------------------------------//

        /// <summary>
        /// This test goes though each public constuctor and ensures that the 
        /// data members of the structure have been properly set.
        /// </summary>
        [Test]
        public void Test_Constructors_i ()
        {
            {
                // Test default values
                Point3 a = new Point3();
                Assert.That(a, Is.EqualTo(Point3.Zero));
            }
            {
                // Test Point3( Int64, Int64, Int64 )
                Int64 a = -189;
                Int64 b = 429;
                Int64 c = 4298;
                Point3 d = new Point3(a, b, c);
                Assert.That(d.X, Is.EqualTo(a));
                Assert.That(d.Y, Is.EqualTo(b));
                Assert.That(d.Z, Is.EqualTo(c));
            }
            {
                // Test Point3( Point2, Int64 )
                Point2 a = new Point2(-189, 429);
                Int64 b = 4298;
                Point3 c = new Point3(a, b);
                Assert.That(c.X, Is.EqualTo(a.X));
                Assert.That(c.Y, Is.EqualTo(a.Y));
                Assert.That(c.Z, Is.EqualTo(b));
            }
            {
                // Test no constructor
                Point3 a;
                a.X = 0;
                a.Y = 0;
                a.Z = 0;
                Assert.That(a, Is.EqualTo(Point3.Zero));
            }
        }

        // Test Member Fn: ToString //----------------------------------------//

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i ()
        {
            Point3 a = new Point3(42, -17, 13);

            String result = a.ToString();

            String expected = "{X:42 Y:-17 Z:13}";

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: GetHashCode //-------------------------------------//

        /// <summary>
        /// Makes sure that the hashing function is good by testing 10,000
        /// random scenarios and ensuring that there are no more than 10
        /// collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            var hs1 = new System.Collections.Generic.HashSet<Point3>();
            var hs2 = new System.Collections.Generic.HashSet<Int32>();

            for(Int32 i = 0; i < 10000; ++i)
            {
                var a = GetNextRandomPoint3();

                hs1.Add(a);
                hs2.Add(a.GetHashCode());
            }

            Assert.That(hs1.Count, Is.EqualTo(hs2.Count).Within(10));
        }

        // Test Constant: Zero //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the Zero constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Zero_i ()
        {
            Point3 result = Point3.Zero;
            Point3 expected = new Point3(0, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: One //----------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the One constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_One_i ()
        {
            Point3 result = Point3.One;
            Point3 expected = new Point3(1, 1, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitX //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the UnitX 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitX_i ()
        {
            Point3 result = Point3.UnitX;
            Point3 expected = new Point3(1, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitY //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the UnitY
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitY_i ()
        {
            Point3 result = Point3.UnitY;
            Point3 expected = new Point3(0, 1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitZ //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the UnitZ
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitZ_i ()
        {
            Point3 result = Point3.UnitZ;
            Point3 expected = new Point3(0, 0, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Up //-----------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the Up
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Up_i ()
        {
            Point3 result = Point3.Up;
            Point3 expected = new Point3(0, 1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Down //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the Down
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Down_i ()
        {
            Point3 result = Point3.Down;
            Point3 expected = new Point3(0, -1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Right //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the Right
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Right_i ()
        {
            Point3 result = Point3.Right;
            Point3 expected = new Point3(1, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Left //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the Left
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Left_i ()
        {
            Point3 result = Point3.Left;
            Point3 expected = new Point3(-1, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Forward //------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the Forward
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Forward_i ()
        {
            Point3 result = Point3.Forward;
            Point3 expected = new Point3(0, 0, -1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Backward //-----------------------------------------//

        /// <summary>
        /// Tests to make sure that a Point3 initilised using the Backward
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Backward_i ()
        {
            Point3 result = Point3.Backward;
            Point3 expected = new Point3(0, 0, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Operator: Equality //-----------------------------------------//

        /// <summary>
        /// Helper method for testing equality.
        /// </summary>
        void TestEquality (Point3 a, Point3 b, Boolean expected )
        {
            // This test asserts the following:
            //   (a == b) == expected
            //   (b == a) == expected
            //   (a != b) == !expected
            //   (b != a) == !expected

            Boolean result_1a = (a == b);
            Boolean result_1b = (a.Equals(b));
            Boolean result_1c = (a.Equals((Object)b));
            
            Boolean result_2a = (b == a);
            Boolean result_2b = (b.Equals(a));
            Boolean result_2c = (b.Equals((Object)a));

            Boolean result_3a = (a != b);
            Boolean result_4a = (b != a);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_1c, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
            Assert.That(result_2c, Is.EqualTo(expected));
            Assert.That(result_3a, Is.EqualTo(!expected));
            Assert.That(result_4a, Is.EqualTo(!expected));
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of TRUE when two equal  
        /// Point3 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_i ()
        {
            var a = new Point3(44, -54, -22);
            var b = new Point3(44, -54, -22);

            Boolean expected = true;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of FALSE when two unequal  
        /// Point3 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_ii ()
        {
            var a = new Point3(44, 54, 2);
            var b = new Point3(44, -54, 2);

            Boolean expected = false;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Tests to make sure that all the equality opperators and functions 
        /// yield the expected result of TRUE when used on a number of randomly 
        /// generated pairs of equal Point3 objects.
        /// </summary>
        [Test]
        public void TestOperator_Equality_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint3();

                Point3 b = a;

                this.TestEquality(a, b, true);
            }
        }


        // Test Operator: Addition //-----------------------------------------//

        /// <summary>
        /// Helper method for testing addition.
        /// </summary>
        void TestAddition (Point3 a, Point3 b, Point3 expected )
        {
            // This test asserts the following:
            //   a + b == expected
            //   b + a == expected

            var result_1a = a + b;
            var result_2a = b + a;

            Point3 result_1b; Point3.Add(ref a, ref b, out result_1b);
            Point3 result_2b; Point3.Add(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the addition opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_i ()
        {
            var a = new Point3(3, -6, 44);
            var b = new Point3(-6, 12, 18);

            var expected = new Point3(-3, 6, 62);

            this.TestAddition(a, b, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving the zero point, all the 
        /// addition opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_ii ()
        {
            var a = new Point3(-2313, 88, 199);

            var expected = a;

            this.TestAddition(a, Point3.Zero, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving two zero points, all the 
        /// addition opperators and functions yield the correct result of zero.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iii ()
        {
            this.TestAddition(Point3.Zero, Point3.Zero, Point3.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// addition opperators and functions yield the same results as a
        /// manual addition calculation.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint3();
                var b = GetNextRandomPoint3();

                var expected = new Point3(
                    a.X + b.X, a.Y + b.Y, a.Z + b.Z);

                this.TestAddition(a, b, expected);
            }
        }

        // Test Operator: Subtraction //--------------------------------------//
        
        /// <summary>
        /// Helper method for testing subtraction.
        /// </summary>
        void TestSubtraction (Point3 a, Point3 b, Point3 expected )
        {
            // This test asserts the following:
            //   a - b == expected
            //   b - a == -expected

            var result_1a = a - b;
            var result_2a = b - a;

            Point3 result_1b; Point3.Subtract(ref a, ref b, out result_1b);
            Point3 result_2b; Point3.Subtract(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(-expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(-expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the subtraction opperators
        /// and functions yield the correct result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_i ()
        {
            var a = new Point3(12, -4, 14);
            var b = new Point3(15, 11, 7);
            var expected = new Point3(-3, -15, 7);
            this.TestSubtraction(a, b, expected);

            var c = new Point3(-423, 342, 7);
            this.TestSubtraction(c, Point3.Zero, c);
        }

        /// <summary>
        /// Assert that when subtracting the zero point fromt the zero point, 
        /// all the subtraction opperators and functions yield the correct 
        /// result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_ii ()
        {
            this.TestSubtraction(Point3.Zero, Point3.Zero, Point3.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// subtraction opperators and functions yield the same results as a
        /// manual subtraction calculation.
        /// </summary>
        [Test]
        public void TestOperator_Subtraction_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint3();
                var b = GetNextRandomPoint3();

                var expected = new Point3(a.X - b.X, a.Y - b.Y, a.Z - b.Z);

                this.TestSubtraction(a, b, expected);
            }
        }

        // Test Operator: Negation //-----------------------------------------//
        
        /// <summary>
        /// Helper method for testing negation.
        /// </summary>
        void TestNegation (Point3 a, Point3 expected )
        {
            // This test asserts the following:
            //   -a == expected

            var result_1a = -a;

            Point3 result_1b; Point3.Negate(ref a, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the negation opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_i ()
        {
            Int64 r = 3432;
            Int64 s = -6218;
            Int64 t = -3432;
            Int64 u = 6218;

            var a = new Point3(r, s, t);
            var b = new Point3(u, t, s);
            var c = new Point3(t, u, r);
            var d = new Point3(s, r, u);

            this.TestNegation(a, c);
            this.TestNegation(b, d);
        }

        /// <summary>
        /// Assert that, for known examples involving the zero point, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_ii ()
        {
            Int64 t = -3432;
            Int64 u = 6218;
            Int64 r = 3432;
            Int64 s = -6218;

            var c = new Point3(t, u, r);
            var d = new Point3(s, r, u);

            this.TestNegation(c, Point3.Zero - c);
            this.TestNegation(d, Point3.Zero - d);
        }

        /// <summary>
        /// Assert that when negating the zero point, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iii ()
        {
            this.TestNegation(Point3.Zero, Point3.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// negation opperators and functions yield the same results as a
        /// manual negation calculation.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint3();
                this.TestNegation(a, Point3.Zero - a);
            }
        }

        // Test Operator: Multiplication //-----------------------------------//

        /// <summary>
        /// Helper method for testing multiplication.
        /// </summary>
        void TestMultiplication (Point3 a, Point3 b, Point3 expected )
        {
            // This test asserts the following:
            //   a * b == expected
            //   b * a == expected

            var result_1a = a * b;
            var result_2a = b * a;

            Point3 result_1b; Point3.Multiply(ref a, ref b, out result_1b);
            Point3 result_2b; Point3.Multiply(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the multiplication opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_i ()
        {
            Int64 r = -27;
            Int64 s = 36;
            Int64 t = 9;

            Int64 x = 3;
            Int64 y = 6;
            Int64 z = -9;

            var a = new Point3(x, y, x);
            var b = new Point3(z, y, x);
            var c = new Point3(r, s, t);

            this.TestMultiplication(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// multiplication opperators and functions yield the same results as a
        /// manual multiplication calculation.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint3();
                var b = GetNextRandomPoint3();

                var c = new Point3(a.X * b.X, a.Y * b.Y, a.Z * b.Z);

                this.TestMultiplication(a, b, c);
            }
        }


        // Test Operator: Division //-----------------------------------------//

        /// <summary>
        /// Helper method for testing division.
        /// </summary>
        void TestDivision (Point3 a, Point3 b, Point3 expected )
        {
            // This test asserts the following:
            //   a / b == expected

            var result_1a = a / b;

            Point3 result_1b; Point3.Divide(ref a, ref b, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example using whole numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_i ()
        {
            Int64 r = 10;
            Int64 s = -40;
            Int64 t = 1;

            Int64 x = 2000;
            Int64 y = 200;
            Int64 z = -5;

            var a = new Point3(x, y, x);
            var b = new Point3(y, z, x);
            var c = new Point3(r, s, t);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a known example using fractional numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_ii ()
        {
            Int64 t = ((Int64) 1 ) / ((Int64) 10);
            Int64 u = ((Int64) (-1) ) / ((Int64) 40 );
            Int64 v = -20;
            Int64 w = 100;
            Int64 x = 2000;
            Int64 y = 200;
            Int64 z = -5;

            var a = new Point3(y, z, w);
            var b = new Point3(x, y, z);
            var c = new Point3(t, u, v);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// division opperators and functions yield the same results as a
        /// manual addition division.
        /// </summary>
        [Test]
        public void TestOperator_Division_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomPoint3();
                var b = GetNextRandomPoint3();

                var c = new Point3(a.X / b.X, a.Y / b.Y, a.Z / b.Z);

                this.TestDivision(a, b, c);
            }
        }

    }
    }


namespace Abacus.SinglePrecision.Tests
{
    /// <summary>
    ///
    /// </summary>
    [TestFixture]
    public class Matrix44Tests
    {
        /// <summary>
        /// The random number generator used for testing.
        /// </summary>
        static readonly System.Random rand;

        /// <summary>
        /// Static constructor used to ensure that the random number generator
        /// always gets initilised with the same seed, making the tests
        /// behave in a deterministic manner.
        /// </summary>
        static Matrix44Tests ()
        {
            rand = new System.Random(0);
        }

        /// <summary>
        /// Helper function for getting the next random Single value.
        /// </summary>
        static Single GetNextRandomSingle ()
        {
            Single randomValue = rand.NextSingle();

            Single zero = 0;
            Single multiplier = 1000;

            randomValue *= multiplier;

            Boolean randomBoolean = (rand.Next(0, 1) == 0) ? true : false;

            if( randomBoolean )
                randomValue = zero - randomValue;

            return randomValue;
        }

        /// <summary>
        /// Helper function for getting the next random Matrix44.
        /// </summary>
        internal static Matrix44 GetNextRandomMatrix44 ()
        {
            Single a = GetNextRandomSingle();
            Single b = GetNextRandomSingle();
            Single c = GetNextRandomSingle();
            Single d = GetNextRandomSingle();
            Single e = GetNextRandomSingle();
            Single f = GetNextRandomSingle();
            Single g = GetNextRandomSingle();
            Single h = GetNextRandomSingle();
            Single i = GetNextRandomSingle();
            Single j = GetNextRandomSingle();
            Single k = GetNextRandomSingle();
            Single l = GetNextRandomSingle();
            Single m = GetNextRandomSingle();
            Single n = GetNextRandomSingle();
            Single o = GetNextRandomSingle();
            Single p = GetNextRandomSingle();

            return new Matrix44(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);
        }

        /// <summary>
        /// Helper to encapsulate asserting that two Matrix44s are equal.
        /// </summary>
        internal static void AssertEqualWithinReason (Matrix44 a, Matrix44 b)
        {
            Single tolerance; RealMaths.TestTolerance(out tolerance);

            Assert.That(a.M11, Is.EqualTo(b.M11).Within(tolerance));
            Assert.That(a.M12, Is.EqualTo(b.M12).Within(tolerance));
            Assert.That(a.M13, Is.EqualTo(b.M13).Within(tolerance));
            Assert.That(a.M14, Is.EqualTo(b.M14).Within(tolerance));
            Assert.That(a.M21, Is.EqualTo(b.M21).Within(tolerance));
            Assert.That(a.M22, Is.EqualTo(b.M22).Within(tolerance));
            Assert.That(a.M23, Is.EqualTo(b.M23).Within(tolerance));
            Assert.That(a.M24, Is.EqualTo(b.M24).Within(tolerance));
            Assert.That(a.M31, Is.EqualTo(b.M31).Within(tolerance));
            Assert.That(a.M32, Is.EqualTo(b.M32).Within(tolerance));
            Assert.That(a.M33, Is.EqualTo(b.M33).Within(tolerance));
            Assert.That(a.M34, Is.EqualTo(b.M34).Within(tolerance));
            Assert.That(a.M41, Is.EqualTo(b.M41).Within(tolerance));
            Assert.That(a.M42, Is.EqualTo(b.M42).Within(tolerance));
            Assert.That(a.M43, Is.EqualTo(b.M43).Within(tolerance));
            Assert.That(a.M44, Is.EqualTo(b.M44).Within(tolerance));
        }
        

        /// <summary>
        /// This test makes sure that the struct layout has been defined
        /// correctly.
        /// </summary>
        [Test]
        public void Test_StructLayout_i ()
        {
            Type t = typeof(Matrix44);

            Assert.That(
                t.StructLayoutAttribute.Value,
                Is.EqualTo(LayoutKind.Sequential));
        }

        /// <summary>
        /// This test makes sure that when examining the memory addresses of the
        /// member variables of a number of randomly generated Matrix44
        /// objects the results are as expected.
        /// </summary>
        [Test]
        public unsafe void Test_StructLayout_ii ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        [Test]
        public void Test_Constructors ()
        {
            Assert.That(true, Is.EqualTo(false));
        }

        [Test]
        public void TestMemberFn_ToString ()
        {
            Assert.That(true, Is.EqualTo(false));
        }

        [Test]
        public void TestMemberFn_GetHashCode ()
        {
            Assert.That(true, Is.EqualTo(false));
        }

        // Test Constant: Identity //-----------------------------------------//

        /// <summary>
        /// Tests to make sure that a Matrix44 initilised using the Identity 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Identity_i ()
        {
            Matrix44 result = Matrix44.Identity;
            Matrix44 expected = new Matrix44 (
                1, 0, 0, 0, 
                0, 1, 0, 0, 
                0, 0, 1, 0, 
                0, 0, 0, 1);

            AssertEqualWithinReason(result, expected);
        }        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateTranslation_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateTranslation_ii ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateScale_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        //// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateScale_ii ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateScale_iii ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateRotationX_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateRotationY_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateRotationZ_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromAxisAngle_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromAllAxis_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateWorldNew_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateWorld_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromQuaternion_i ()
        {
            Single yaw; RealMaths.Pi(out yaw); yaw /= (Single) 4;
            Single pitch; RealMaths.Pi(out pitch); pitch /= (Single) (-8);
            Single roll; RealMaths.Pi(out roll); roll /= (Single) 2;

            Quaternion q; Quaternion.CreateFromYawPitchRoll(yaw, pitch, roll, out q);
            q.Normalise();

            Matrix44 m; Matrix44.CreateFromQuaternion(ref q, out m);

            Matrix44 expected = new Matrix44 ();
            expected.M11 = Single.Parse("-0.270598"); // this is a grim way to do it, make it so we can cast double to fixed
            expected.M12 = Single.Parse("0.9238795");
            expected.M13 = Single.Parse("-0.270598");
            expected.M14 = 0;
            expected.M21 = Single.Parse("-0.7071067");
            expected.M22 = Single.Parse("6.705523E-08");
            expected.M23 = Single.Parse("0.7071067");
            expected.M24 = 0;
            expected.M31 = Single.Parse("0.6532815");
            expected.M32 = Single.Parse("0.3826834");
            expected.M33 = Single.Parse("0.6532815");
            expected.M34 = 0;
            expected.M41 = 0;
            expected.M42 = 0;
            expected.M43 = 0;
            expected.M44 = 1;


            AssertEqualWithinReason(m, expected);

        }

        /// <summary>
        /// Assert that, for a number of examples, a random quaternion can be
        /// selected, converted to a Matrix44 then converted back to the same
        /// quaternion (assuming that the conversion back is correct).
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromQuaternion_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Quaternion q = QuaternionTests.GetNextRandomQuaternion();
                Quaternion.Normalise(ref q, out q);

                Matrix44 m;
                Matrix44.CreateFromQuaternion(ref q, out m);

                Quaternion q2;
                Quaternion.CreateFromRotationMatrix(ref m, out q2);

                QuaternionTests.AssertEqualWithinReason(q, q2);
            }
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromYawPitchRoll_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateBillboard_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateConstrainedBillboard_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreatePerspectiveFieldOfView_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreatePerspective_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreatePerspectiveOffCenter_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateOrthographic_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void CreateOrthographicOffCenter_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateLookAt_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Transpose //---------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Transpose_i ()
        {
            Matrix44 startMatrix = new Matrix44(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);

            Matrix44 testMatrix = startMatrix;

            Matrix44 testMatrixExpectedTranspose = new Matrix44(0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15);

            // RUN THE STATIC VERSION OF THE FUNCTION
            Matrix44 resultMatrix = Matrix44.Identity;

            Matrix44.Transpose(ref testMatrix, out resultMatrix);

            Assert.That(resultMatrix, Is.EqualTo(testMatrixExpectedTranspose));
        }

        // Test Static Fn: Decompose //---------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Decompose_i ()
        {
            Matrix44 scale;
            Matrix44.CreateScale(4, 2, 3, out scale);

            Matrix44 rotation;
            Single pi; RealMaths.Pi(out pi);
            Matrix44.CreateRotationY(pi, out rotation);

            Matrix44 translation;
            Matrix44.CreateTranslation(100, 5, 3, out translation);

            Matrix44 m = rotation * scale;
            //m = translation * m;
            m.Translation = new Vector3(100, 5, 3);

            Vector3 outScale;
            Quaternion outRotation;
            Vector3 outTranslation;

            m.Decompose(out outScale, out outRotation, out outTranslation);

            Matrix44 mat;
            Matrix44.CreateFromQuaternion(ref outRotation, out mat);

            Assert.That(outScale, Is.EqualTo(new Vector3(4, 2, 3)));
            Assert.That(mat, Is.EqualTo(rotation));
            Assert.That(outTranslation, Is.EqualTo(new Vector3(100, 5, 3)));
        }

        // Test Static Fn: Determinant //-------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Determinant_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Invert //------------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Invert_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Transform //---------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Transform_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }
        // Test Operator: Equality //-----------------------------------------//

        /// <summary>
        /// Helper method for testing equality.
        /// </summary>
        void TestEquality (Matrix44 a, Matrix44 b, Boolean expected )
        {
            // This test asserts the following:
            //   (a == b) == expected
            //   (b == a) == expected
            //   (a != b) == !expected
            //   (b != a) == !expected

            Boolean result_1a = (a == b);
            Boolean result_1b = (a.Equals(b));
            Boolean result_1c = (a.Equals((Object)b));
            
            Boolean result_2a = (b == a);
            Boolean result_2b = (b.Equals(a));
            Boolean result_2c = (b.Equals((Object)a));

            Boolean result_3a = (a != b);
            Boolean result_4a = (b != a);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_1c, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
            Assert.That(result_2c, Is.EqualTo(expected));
            Assert.That(result_3a, Is.EqualTo(!expected));
            Assert.That(result_4a, Is.EqualTo(!expected));
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of TRUE when two equal  
        /// Matrix44 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_i ()
        {
            var a = new Matrix44(44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);
            var b = new Matrix44(44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);

            Boolean expected = true;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of FALSE when two unequal  
        /// Matrix44 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_ii ()
        {
            var a = new Matrix44(44, 54, 2, 11, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);
            var b = new Matrix44(44, -54, 2, -1, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);

            Boolean expected = false;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Tests to make sure that all the equality opperators and functions 
        /// yield the expected result of TRUE when used on a number of randomly 
        /// generated pairs of equal Matrix44 objects.
        /// </summary>
        [Test]
        public void TestOperator_Equality_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomMatrix44();

                Matrix44 b = a;

                this.TestEquality(a, b, true);
            }
        }


        // Test Operator: Addition //-----------------------------------------//

        /// <summary>
        /// Helper method for testing addition.
        /// </summary>
        void TestAddition (Matrix44 a, Matrix44 b, Matrix44 expected )
        {
            // This test asserts the following:
            //   a + b == expected
            //   b + a == expected

            var result_1a = a + b;
            var result_2a = b + a;

            Matrix44 result_1b; Matrix44.Add(ref a, ref b, out result_1b);
            Matrix44 result_2b; Matrix44.Add(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the addition opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_i ()
        {
            var a = new Matrix44(3, -6, 44, 11, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);
            var b = new Matrix44(-6, 12, 18, -3, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);

            var expected = new Matrix44(-3, 6, 62, 8, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);

            this.TestAddition(a, b, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving the zero matrix, all the 
        /// addition opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_ii ()
        {
            var a = new Matrix44(-2313, 88, 199, 42, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);

            var expected = a;

            this.TestAddition(a, Matrix44.Identity, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving two zero matrixs, all the 
        /// addition opperators and functions yield the correct result of zero.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iii ()
        {
            this.TestAddition(Matrix44.Identity, Matrix44.Identity, Matrix44.Identity);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// addition opperators and functions yield the same results as a
        /// manual addition calculation.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomMatrix44();
                var b = GetNextRandomMatrix44();

                var expected = new Matrix44(
                    a.M11 / b.M11, 
                    a.M12 / b.M12, 
                    a.M13 / b.M13, 
                    a.M14 / b.M14,
                    a.M21 / b.M21, 
                    a.M22 / b.M22, 
                    a.M23 / b.M23, 
                    a.M24 / b.M24,
                    a.M31 / b.M31, 
                    a.M32 / b.M32, 
                    a.M33 / b.M33, 
                    a.M34 / b.M34,
                    a.M41 / b.M41, 
                    a.M42 / b.M42, 
                    a.M43 / b.M43, 
                    a.M44 / b.M44
                    );

                this.TestAddition(a, b, expected);
            }
        }

        // Test Operator: Subtraction //--------------------------------------//
        
        /// <summary>
        /// Helper method for testing subtraction.
        /// </summary>
        void TestSubtraction (Matrix44 a, Matrix44 b, Matrix44 expected )
        {
            // This test asserts the following:
            //   a - b == expected
            //   b - a == -expected

            var result_1a = a - b;
            var result_2a = b - a;

            Matrix44 result_1b; Matrix44.Subtract(ref a, ref b, out result_1b);
            Matrix44 result_2b; Matrix44.Subtract(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(-expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(-expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the subtraction opperators
        /// and functions yield the correct result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_i ()
        {
            var a = new Matrix44(12, -4, 14, 18, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);
            var b = new Matrix44(15, 11, 7, 27, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);
            var expected = new Matrix44(-3, -15, 7, -9, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);
            this.TestSubtraction(a, b, expected);

            var c = new Matrix44(-423, 342, 7, -800, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);
            this.TestSubtraction(c, Matrix44.Identity, c);
        }

        /// <summary>
        /// Assert that when subtracting the zero matrix fromt the zero matrix, 
        /// all the subtraction opperators and functions yield the correct 
        /// result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_ii ()
        {
            this.TestSubtraction(Matrix44.Identity, Matrix44.Identity, Matrix44.Identity);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// subtraction opperators and functions yield the same results as a
        /// manual subtraction calculation.
        /// </summary>
        [Test]
        public void TestOperator_Subtraction_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomMatrix44();
                var b = GetNextRandomMatrix44();

                var expected = new Matrix44(
                    a.M11 / b.M11, 
                    a.M12 / b.M12, 
                    a.M13 / b.M13, 
                    a.M14 / b.M14,
                    a.M21 / b.M21, 
                    a.M22 / b.M22, 
                    a.M23 / b.M23, 
                    a.M24 / b.M24,
                    a.M31 / b.M31, 
                    a.M32 / b.M32, 
                    a.M33 / b.M33, 
                    a.M34 / b.M34,
                    a.M41 / b.M41, 
                    a.M42 / b.M42, 
                    a.M43 / b.M43, 
                    a.M44 / b.M44
                    );

                this.TestSubtraction(a, b, expected);
            }
        }

        // Test Operator: Negation //-----------------------------------------//
        
        /// <summary>
        /// Helper method for testing negation.
        /// </summary>
        void TestNegation (Matrix44 a, Matrix44 expected )
        {
            // This test asserts the following:
            //   -a == expected

            var result_1a = -a;

            Matrix44 result_1b;
            Matrix44.Negate(ref a, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the negation opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_i ()
        {
            Single r = 3432;
            Single s = -6218;
            Single t = -3432;
            Single u = 6218;

            var a = new Matrix44(r, s, t, u, r, s, t, u, r, s, t, u, r, s, t, u);
            var b = new Matrix44(u, t, s, r, r, s, t, u, r, s, t, u, r, s, t, u);
            var c = new Matrix44(t, u, r, s, r, s, t, u, r, s, t, u, r, s, t, u);
            var d = new Matrix44(s, r, u, t, r, s, t, u, r, s, t, u, r, s, t, u);

            this.TestNegation(a, c);
            this.TestNegation(b, d);
        }

        /// <summary>
        /// Assert that, for known examples involving the zero matrix, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_ii ()
        {
            Single t = -3432;
            Single u = 6218;
            Single r = 3432;
            Single s = -6218;

            var c = new Matrix44(t, u, r, s, r, s, t, u, r, s, t, u, r, s, t, u);
            var d = new Matrix44(s, r, u, t, r, s, t, u, r, s, t, u, r, s, t, u);

            this.TestNegation(c, Matrix44.Identity - c);
            this.TestNegation(d, Matrix44.Identity - d);
        }

        /// <summary>
        /// Assert that when negating the zero matrix, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iii ()
        {
            this.TestNegation(Matrix44.Identity, Matrix44.Identity);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// negation opperators and functions yield the same results as a
        /// manual negation calculation.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomMatrix44();
                this.TestNegation(a, Matrix44.Identity - a);
            }
        }

        // Test Operator: Multiplication //-----------------------------------//

        /// <summary>
        /// Helper method for testing multiplication.
        /// </summary>
        void TestMultiplication (Matrix44 a, Matrix44 b, Matrix44 expected )
        {
            // This test asserts the following:
            //   a * b == expected
            //   b * a == expected

            var result_1a = a * b;
            var result_2a = b * a;

            Matrix44 result_1b; Matrix44.Multiply(ref a, ref b, out result_1b);
            Matrix44 result_2b; Matrix44.Multiply(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the multiplication opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_i ()
        {
            var a = new Matrix44();
            a.M11 = -27;
            a.M12 = 36;
            a.M13 = 9;
            a.M14 = -54;
            
            a.M21 = 36;
            a.M22 = 3;
            a.M23 = 9;
            a.M24 = 9;
            
            a.M31 = 9;
            a.M32 = 9;
            a.M33 = -36;
            a.M34 = 6;
            
            a.M41 = -24;
            a.M42 = 9;
            a.M43 = 36;
            a.M44 = -12;

            var b = new Matrix44();
            b.M11 = 3402;
            b.M12 = -1269;
            b.M13 = -2187;
            b.M14 = 2484;
            
            b.M21 = -999;
            b.M22 = 1467;
            b.M23 = 351;
            b.M24 = -1971;
            
            b.M31 = -387;
            b.M32 = 81;
            b.M33 = 1674;
            b.M34 = -693;
            
            b.M41 = 1584;
            b.M42 = -621;
            b.M43 = -1863;
            b.M44 = 1737;

            this.TestMultiplication(a, a, b);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// multiplication opperators and functions yield the same results as a
        /// manual multiplication calculation.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomMatrix44();
                var b = GetNextRandomMatrix44();

                var c = new Matrix44(
                    a.M11 / b.M11, 
                    a.M12 / b.M12, 
                    a.M13 / b.M13, 
                    a.M14 / b.M14,
                    a.M21 / b.M21, 
                    a.M22 / b.M22, 
                    a.M23 / b.M23, 
                    a.M24 / b.M24,
                    a.M31 / b.M31, 
                    a.M32 / b.M32, 
                    a.M33 / b.M33, 
                    a.M34 / b.M34,
                    a.M41 / b.M41, 
                    a.M42 / b.M42, 
                    a.M43 / b.M43, 
                    a.M44 / b.M44
                    );

                this.TestMultiplication(a, b, c);
            }
        }


        // Test Operator: Division //-----------------------------------------//

        /// <summary>
        /// Helper method for testing division.
        /// </summary>
        void TestDivision (Matrix44 a, Matrix44 b, Matrix44 expected )
        {
            // This test asserts the following:
            //   a / b == expected

            var result_1a = a / b;

            Matrix44 result_1b; Matrix44.Divide(ref a, ref b, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example using whole numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_i ()
        {
            Single r = 10;
            Single s = -40;
            Single t = 1;
            Single u = -400;

            Single x = 2000;
            Single y = 200;
            Single z = -5;

            var a = new Matrix44(x, y, x, x, r, s, t, u, r, s, t, u, r, s, t, u);
            var b = new Matrix44(y, z, x, z, r, s, t, u, r, s, t, u, r, s, t, u);
            var c = new Matrix44(r, s, t, u, r, s, t, u, r, s, t, u, r, s, t, u);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a known example using fractional numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_ii ()
        {
            Single r = 5;
            Single s = 4;
            Single t = ((Single) 1 ) / ((Single) 10);
            Single u = ((Single) (-1) ) / ((Single) 40 );
            Single v = -20;
            Single w = 100;
            Single x = 2000;
            Single y = 200;
            Single z = -5;

            var a = new Matrix44(y, z, w, v, r, s, t, u, r, s, t, u, r, s, t, u);
            var b = new Matrix44(x, y, z, z, r, s, t, u, r, s, t, u, r, s, t, u);
            var c = new Matrix44(t, u, v, s, r, s, t, u, r, s, t, u, r, s, t, u);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// division opperators and functions yield the same results as a
        /// manual addition division.
        /// </summary>
        [Test]
        public void TestOperator_Division_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomMatrix44();
                var b = GetNextRandomMatrix44();

                var c = new Matrix44(
                    a.M11 / b.M11, 
                    a.M12 / b.M12, 
                    a.M13 / b.M13, 
                    a.M14 / b.M14,
                    a.M21 / b.M21, 
                    a.M22 / b.M22, 
                    a.M23 / b.M23, 
                    a.M24 / b.M24,
                    a.M31 / b.M31, 
                    a.M32 / b.M32, 
                    a.M33 / b.M33, 
                    a.M34 / b.M34,
                    a.M41 / b.M41, 
                    a.M42 / b.M42, 
                    a.M43 / b.M43, 
                    a.M44 / b.M44
                    );

                this.TestDivision(a, b, c);
            }
        }

        /// <summary>
        /// Assert that, running the Lerp function on a number of randomly
        /// generated pairs of Matrix44 objects for a range of weighting amounts, 
        /// yields the same results as those obtained from performing a manual 
        /// Lerp calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_i ()
        {
            for(Int32 j = 0; j < 100; ++j)
            {
                Single delta = j;

                delta = delta / 100;

                for(Int32 i = 0; i < 100; ++i)
                {
                    Matrix44 a = GetNextRandomMatrix44();
                    Matrix44 b = GetNextRandomMatrix44();

                    Matrix44 result;
                    Matrix44.Lerp (ref a, ref b, delta, out result);

                    Matrix44 expected = a + ( ( b - a ) * delta );

                    AssertEqualWithinReason(result, expected);
                }
            }
        }

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_ii ()
        {
            Matrix44 a = GetNextRandomMatrix44();
            Matrix44 b = GetNextRandomMatrix44();

            Single half; RealMaths.Half(out half);

            var tests = new Single[] { 2, half + 1, -half, -1 };

            foreach( var weighting in tests )
            {
                Matrix44 result; 
                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Matrix44.Lerp (
                            ref a, ref b, weighting, out result)
                    );
            }
        }    }
    /// <summary>
    /// 
    /// </summary>
    [TestFixture]
    public class QuaternionTests
    {
        /// <summary>
        /// The random number generator used for testing.
        /// </summary>
        static readonly System.Random rand;

        /// <summary>
        /// Static constructor used to ensure that the random number generator
        /// always gets initilised with the same seed, making the tests
        /// behave in a deterministic manner.
        /// </summary>
        static QuaternionTests ()
        {
            rand = new System.Random(0);
        }

        /// <summary>
        /// Helper function for getting the next random Single value.
        /// </summary>
        static Single GetNextRandomSingle ()
        {
            Single randomValue = rand.NextSingle();

            Single zero = 0;
            Single multiplier = 1000;

            randomValue *= multiplier;

            Boolean randomBoolean = (rand.Next(0, 1) == 0) ? true : false;

            if( randomBoolean )
                randomValue = zero - randomValue;

            return randomValue;
        }

        /// <summary>
        /// Helper function for getting the next random Quaternion.
        /// </summary>
        internal static Quaternion GetNextRandomQuaternion ()
        {
            Single a = GetNextRandomSingle();
            Single b = GetNextRandomSingle();
            Single c = GetNextRandomSingle();
            Single d = GetNextRandomSingle();

            return new Quaternion(a, b, c, d);
        }

        /// <summary>
        /// Helper to encapsulate asserting that two Quaternions are equal.
        /// </summary>
        internal static void AssertEqualWithinReason (Quaternion a, Quaternion b)
        {
            Single tolerance; RealMaths.TestTolerance(out tolerance);

            Assert.That(a.X, Is.EqualTo(b.X).Within(tolerance));
            Assert.That(a.Y, Is.EqualTo(b.Y).Within(tolerance));
            Assert.That(a.Z, Is.EqualTo(b.Z).Within(tolerance));
            Assert.That(a.W, Is.EqualTo(b.W).Within(tolerance));
        }
        

        // Test: StructLayout //----------------------------------------------//

        /// <summary>
        /// This test makes sure that the struct layout has been defined
        /// correctly.
        /// </summary>
        [Test]
        public void Test_StructLayout_i ()
        {
            Type t = typeof(Quaternion);

            Assert.That(
                t.StructLayoutAttribute.Value, 
                Is.EqualTo(LayoutKind.Sequential));
        }

        /// <summary>
        /// This test makes sure that when examining the memory addresses of the 
        /// X, Y, Z and W member variables of a number of randomly generated 
        /// Quaterion objects the results are as expected. 
        /// </summary>
        [Test]
        public unsafe void Test_StructLayout_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Quaternion quat = GetNextRandomQuaternion();

                GCHandle h_quat = GCHandle.Alloc(quat, GCHandleType.Pinned);

                IntPtr quatAddress = h_quat.AddrOfPinnedObject();

                Single[] data = new Single[4];

                // nb: when Fixed32 and Half are moved back into the main
                //     dev branch there will be need for an extension method for
                //     Marshal that will perform the copy for those types. 
                MarshalHelper.Copy(quatAddress, data, 0, 4);
                Assert.That(data[0], Is.EqualTo(quat.X));
                Assert.That(data[1], Is.EqualTo(quat.Y));
                Assert.That(data[2], Is.EqualTo(quat.Z));
                Assert.That(data[3], Is.EqualTo(quat.W));
                
                h_quat.Free();
            }
        }

        [Test]
        public void Test_Constructors ()
        {
            Assert.That(true, Is.EqualTo(false));
        }

        [Test]
        public void TestMemberFn_ToString ()
        {
            Assert.That(true, Is.EqualTo(false));
        }

        [Test]
        public void TestMemberFn_GetHashCode ()
        {
            Assert.That(true, Is.EqualTo(false));
        }

        // Test Constant: Identity //-----------------------------------------//

        /// <summary>
        /// Tests to make sure that a Quaternion initilised using the Identity 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Identity_i ()
        {
            Quaternion result = Quaternion.Identity;
            Quaternion expected = new Quaternion (
                0, 0, 0, 1);

            AssertEqualWithinReason(result, expected);
        }        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateTranslation_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromAxisAngle_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromYawPitchRoll_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromRotationMatrix_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Conjugate //---------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Conjugate_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Inverse //-----------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Inverse_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Distance //----------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Concatenate //-------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Concatenate_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Normalise //---------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Operator: Equality //-----------------------------------------//

        /// <summary>
        /// Helper method for testing equality.
        /// </summary>
        void TestEquality (Quaternion a, Quaternion b, Boolean expected )
        {
            // This test asserts the following:
            //   (a == b) == expected
            //   (b == a) == expected
            //   (a != b) == !expected
            //   (b != a) == !expected

            Boolean result_1a = (a == b);
            Boolean result_1b = (a.Equals(b));
            Boolean result_1c = (a.Equals((Object)b));
            
            Boolean result_2a = (b == a);
            Boolean result_2b = (b.Equals(a));
            Boolean result_2c = (b.Equals((Object)a));

            Boolean result_3a = (a != b);
            Boolean result_4a = (b != a);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_1c, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
            Assert.That(result_2c, Is.EqualTo(expected));
            Assert.That(result_3a, Is.EqualTo(!expected));
            Assert.That(result_4a, Is.EqualTo(!expected));
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of TRUE when two equal  
        /// Quaternion objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_i ()
        {
            var a = new Quaternion(44, -54, -22, 11);
            var b = new Quaternion(44, -54, -22, 11);

            Boolean expected = true;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of FALSE when two unequal  
        /// Quaternion objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_ii ()
        {
            var a = new Quaternion(44, 54, 2, 11);
            var b = new Quaternion(44, -54, 2, -1);

            Boolean expected = false;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Tests to make sure that all the equality opperators and functions 
        /// yield the expected result of TRUE when used on a number of randomly 
        /// generated pairs of equal Quaternion objects.
        /// </summary>
        [Test]
        public void TestOperator_Equality_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomQuaternion();

                Quaternion b = a;

                this.TestEquality(a, b, true);
            }
        }


        // Test Operator: Addition //-----------------------------------------//

        /// <summary>
        /// Helper method for testing addition.
        /// </summary>
        void TestAddition (Quaternion a, Quaternion b, Quaternion expected )
        {
            // This test asserts the following:
            //   a + b == expected
            //   b + a == expected

            var result_1a = a + b;
            var result_2a = b + a;

            Quaternion result_1b; Quaternion.Add(ref a, ref b, out result_1b);
            Quaternion result_2b; Quaternion.Add(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the addition opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_i ()
        {
            var a = new Quaternion(3, -6, 44, 11);
            var b = new Quaternion(-6, 12, 18, -3);

            var expected = new Quaternion(-3, 6, 62, 8);

            this.TestAddition(a, b, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving the zero quaternion, all the 
        /// addition opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_ii ()
        {
            var a = new Quaternion(-2313, 88, 199, 42);

            var expected = a;

            this.TestAddition(a, Quaternion.Identity, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving two zero quaternions, all the 
        /// addition opperators and functions yield the correct result of zero.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iii ()
        {
            this.TestAddition(Quaternion.Identity, Quaternion.Identity, Quaternion.Identity);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// addition opperators and functions yield the same results as a
        /// manual addition calculation.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomQuaternion();
                var b = GetNextRandomQuaternion();

                var expected = new Quaternion(
                    a.X + b.X, a.Y + b.Y, a.Z + b.Z, a.W + b.W);

                this.TestAddition(a, b, expected);
            }
        }

        // Test Operator: Subtraction //--------------------------------------//
        
        /// <summary>
        /// Helper method for testing subtraction.
        /// </summary>
        void TestSubtraction (Quaternion a, Quaternion b, Quaternion expected )
        {
            // This test asserts the following:
            //   a - b == expected
            //   b - a == -expected

            var result_1a = a - b;
            var result_2a = b - a;

            Quaternion result_1b; Quaternion.Subtract(ref a, ref b, out result_1b);
            Quaternion result_2b; Quaternion.Subtract(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(-expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(-expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the subtraction opperators
        /// and functions yield the correct result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_i ()
        {
            var a = new Quaternion(12, -4, 14, 18);
            var b = new Quaternion(15, 11, 7, 27);
            var expected = new Quaternion(-3, -15, 7, -9);
            this.TestSubtraction(a, b, expected);

            var c = new Quaternion(-423, 342, 7, -800);
            this.TestSubtraction(c, Quaternion.Identity, c);
        }

        /// <summary>
        /// Assert that when subtracting the zero quaternion fromt the zero quaternion, 
        /// all the subtraction opperators and functions yield the correct 
        /// result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_ii ()
        {
            this.TestSubtraction(Quaternion.Identity, Quaternion.Identity, Quaternion.Identity);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// subtraction opperators and functions yield the same results as a
        /// manual subtraction calculation.
        /// </summary>
        [Test]
        public void TestOperator_Subtraction_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomQuaternion();
                var b = GetNextRandomQuaternion();

                var expected = new Quaternion(
                    a.X - b.X, a.Y - b.Y, a.Z - b.Z, a.W - b.W);

                this.TestSubtraction(a, b, expected);
            }
        }

        // Test Operator: Negation //-----------------------------------------//
        
        /// <summary>
        /// Helper method for testing negation.
        /// </summary>
        void TestNegation (Quaternion a, Quaternion expected )
        {
            // This test asserts the following:
            //   -a == expected

            var result_1a = -a;

            Quaternion result_1b; Quaternion.Negate(ref a, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the negation opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_i ()
        {
            Single r = 3432;
            Single s = -6218;
            Single t = -3432;
            Single u = 6218;

            var a = new Quaternion(r, s, t, u);
            var b = new Quaternion(u, t, s, r);
            var c = new Quaternion(t, u, r, s);
            var d = new Quaternion(s, r, u, t);

            this.TestNegation(a, c);
            this.TestNegation(b, d);
        }

        /// <summary>
        /// Assert that, for known examples involving the zero quaternion, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_ii ()
        {
            Single t = -3432;
            Single u = 6218;
            Single r = 3432;
            Single s = -6218;

            var c = new Quaternion(t, u, r, s);
            var d = new Quaternion(s, r, u, t);

            this.TestNegation(c, Quaternion.Identity - c);
            this.TestNegation(d, Quaternion.Identity - d);
        }

        /// <summary>
        /// Assert that when negating the zero quaternion, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iii ()
        {
            this.TestNegation(Quaternion.Identity, Quaternion.Identity);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// negation opperators and functions yield the same results as a
        /// manual negation calculation.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomQuaternion();
                this.TestNegation(a, Quaternion.Identity - a);
            }
        }

        // Test Operator: Multiplication //-----------------------------------//

        /// <summary>
        /// Helper method for testing multiplication.
        /// </summary>
        void TestMultiplication (Quaternion a, Quaternion b, Quaternion expected )
        {
            // This test asserts the following:
            //   a * b == expected
            //   b * a == expected

            var result_1a = a * b;
            var result_2a = b * a;

            Quaternion result_1b; Quaternion.Multiply(ref a, ref b, out result_1b);
            Quaternion result_2b; Quaternion.Multiply(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the multiplication opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_i ()
        {
            Single r = -27;
            Single s = 36;
            Single t = 9;
            Single u = -54;

            Single x = 3;
            Single y = 6;
            Single z = -9;

            var a = new Quaternion(x, y, x, y);
            var b = new Quaternion(z, y, x, z);
            var c = new Quaternion(r, s, t, u);

            this.TestMultiplication(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// multiplication opperators and functions yield the same results as a
        /// manual multiplication calculation.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomQuaternion();
                var b = GetNextRandomQuaternion();

                var c = new Quaternion(
                    a.X * b.X, a.Y * b.Y, a.Z * b.Z, a.W * b.W);

                this.TestMultiplication(a, b, c);
            }
        }


        // Test Operator: Division //-----------------------------------------//

        /// <summary>
        /// Helper method for testing division.
        /// </summary>
        void TestDivision (Quaternion a, Quaternion b, Quaternion expected )
        {
            // This test asserts the following:
            //   a / b == expected

            var result_1a = a / b;

            Quaternion result_1b; Quaternion.Divide(ref a, ref b, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example using whole numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_i ()
        {
            Single r = 10;
            Single s = -40;
            Single t = 1;
            Single u = -400;

            Single x = 2000;
            Single y = 200;
            Single z = -5;

            var a = new Quaternion(x, y, x, x);
            var b = new Quaternion(y, z, x, z);
            var c = new Quaternion(r, s, t, u);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a known example using fractional numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_ii ()
        {
            Single s = 4;
            Single t = ((Single) 1 ) / ((Single) 10);
            Single u = ((Single) (-1) ) / ((Single) 40 );
            Single v = -20;
            Single w = 100;
            Single x = 2000;
            Single y = 200;
            Single z = -5;

            var a = new Quaternion(y, z, w, v);
            var b = new Quaternion(x, y, z, z);
            var c = new Quaternion(t, u, v, s);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// division opperators and functions yield the same results as a
        /// manual addition division.
        /// </summary>
        [Test]
        public void TestOperator_Division_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomQuaternion();
                var b = GetNextRandomQuaternion();

                var c = new Quaternion(
                    a.X / b.X, a.Y / b.Y, a.Z / b.Z, a.W / b.W);

                this.TestDivision(a, b, c);
            }
        }

        /// <summary>
        /// todo
        /// </summary>
        public static void Slerp (ref Quaternion quaternion1, ref Quaternion quaternion2, Single amount, out Quaternion result)
        {
            Single zero = 0;
            Single one = 1;

            Single nineninenine;
            RealMaths.FromString("0.999999", out nineninenine);

            Single a;
            Single b;
            Single c = amount;
            
            Single d = 
                (quaternion1.X * quaternion2.X) + 
                (quaternion1.Y * quaternion2.Y) + 
                (quaternion1.Z * quaternion2.Z) + 
                (quaternion1.W * quaternion2.W);
            
            Boolean flag = false;

            if (d < zero)
            {
                flag = true;
                d = -d;
            }


            if (d >nineninenine)
            {
                b = one - c;
                a = flag ? -c : c;
            }
            else
            {
                Single e = RealMaths.ArcCos (d);
                Single f = one / RealMaths.Sin (e);

                b = RealMaths.Sin ((one - c) * e) * f;

                a = flag ? -RealMaths.Sin (c * e) * f : RealMaths.Sin (c * e) * f;
            }

            result.X = (b * quaternion1.X) + (a * quaternion2.X);
            result.Y = (b * quaternion1.Y) + (a * quaternion2.Y);
            result.Z = (b * quaternion1.Z) + (a * quaternion2.Z);
            result.W = (b * quaternion1.W) + (a * quaternion2.W);
        }

        /// <summary>
        /// todo
        /// </summary>
        public static void Lerp (ref Quaternion quaternion1, ref Quaternion quaternion2, Single amount, out Quaternion result)
        {
            Single zero = 0;
            Single one = 1;

            Single a = amount;
            Single b = one - a;
            Single c = 
                (quaternion1.X * quaternion2.X) + 
                (quaternion1.Y * quaternion2.Y) + 
                (quaternion1.Z * quaternion2.Z) + 
                (quaternion1.W * quaternion2.W);
            
            if (c >= zero)
            {
                result.X = (b * quaternion1.X) + (a * quaternion2.X);
                result.Y = (b * quaternion1.Y) + (a * quaternion2.Y);
                result.Z = (b * quaternion1.Z) + (a * quaternion2.Z);
                result.W = (b * quaternion1.W) + (a * quaternion2.W);
            }
            else
            {
                result.X = (b * quaternion1.X) - (a * quaternion2.X);
                result.Y = (b * quaternion1.Y) - (a * quaternion2.Y);
                result.Z = (b * quaternion1.Z) - (a * quaternion2.Z);
                result.W = (b * quaternion1.W) - (a * quaternion2.W);
            }

            Single d = 
                (result.X * result.X) + 
                (result.Y * result.Y) + 
                (result.Z * result.Z) + 
                (result.W * result.W);

            Single e = one / RealMaths.Sqrt (d);

            result.X *= e;
            result.Y *= e;
            result.Z *= e;
            result.W *= e;
        }

    }
        /// <summary>
    /// todo
    /// </summary>
    [TestFixture]
    public class Vector2Tests
    {
        /// <summary>
        /// The random number generator used for testing.
        /// </summary>
        static readonly System.Random rand;

        /// <summary>
        /// Static constructor used to ensure that the random number generator
        /// always gets initilised with the same seed, making the tests
        /// behave in a deterministic manner.
        /// </summary>
        static Vector2Tests ()
        {
            rand = new System.Random(0);
        }

        /// <summary>
        /// Helper function for getting the next random Single value.
        /// </summary>
        static Single GetNextRandomSingle ()
        {
            Single randomValue = rand.NextSingle();

            Single zero = 0;
            Single multiplier = 1000;

            randomValue *= multiplier;

            Boolean randomBoolean = (rand.Next(0, 1) == 0) ? true : false;

            if( randomBoolean )
                randomValue = zero - randomValue;

            return randomValue;
        }

        /// <summary>
        /// Helper function for getting the next random Vector2.
        /// </summary>
        static Vector2 GetNextRandomVector2 ()
        {
            Single a = GetNextRandomSingle();
            Single b = GetNextRandomSingle();

            return new Vector2(a, b);
        }

        /// <summary>
        /// Helper to encapsulate asserting that two Vector2s are equal.
        /// </summary>
        static void AssertEqualWithinReason (Vector2 a, Vector2 b)
        {
            Single tolerance; RealMaths.TestTolerance(out tolerance);

            Assert.That(a.X, Is.EqualTo(b.X).Within(tolerance));
            Assert.That(a.Y, Is.EqualTo(b.Y).Within(tolerance));
        }
        

        // Test: StructLayout //----------------------------------------------//

        /// <summary>
        /// This test makes sure that the struct layout has been defined
        /// correctly.
        /// </summary>
        [Test]
        public void Test_StructLayout_i ()
        {
            Type t = typeof(Vector2);

            Assert.That(
                t.StructLayoutAttribute.Value, 
                Is.EqualTo(LayoutKind.Sequential));
        }

        /// <summary>
        /// This test makes sure that when examining the memory addresses of the 
        /// X and Y member variables of a number of randomly generated Vector2
        /// objects the results are as expected. 
        /// </summary>
        [Test]
        public unsafe void Test_StructLayout_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector2 vec = GetNextRandomVector2();

                GCHandle h_vec = GCHandle.Alloc(vec, GCHandleType.Pinned);

                IntPtr vecAddress = h_vec.AddrOfPinnedObject();

                Single[] data = new Single[2];

                // nb: when Fixed32 and Half are moved back into the main
                //     dev branch there will be need for an extension method for
                //     Marshal that will perform the copy for those types. 
                MarshalHelper.Copy(vecAddress, data, 0, 2);
                Assert.That(data[0], Is.EqualTo(vec.X));
                Assert.That(data[1], Is.EqualTo(vec.Y));
                
                h_vec.Free();
            }
        }

        // Test: Constructors //----------------------------------------------//

        /// <summary>
        /// This test goes though each public constuctor and ensures that the 
        /// data members of the structure have been properly set.
        /// </summary>
        [Test]
        public void Test_Constructors_i ()
        {
            {
                // Test default values
                Vector2 a = new Vector2();
                Assert.That(a, Is.EqualTo(Vector2.Zero));
            }
            {
                // Test Vector2( Single, Single )
                Single u = -189;
                Single v = 429;
                Vector2 c = new Vector2(u, v);
                Assert.That(c.X, Is.EqualTo(u));
                Assert.That(c.Y, Is.EqualTo(v));
            }
            {
                // Test no constructor
                Vector2 e;
                e.X = 0;
                e.Y = 0;
                Assert.That(e, Is.EqualTo(Vector2.Zero));
            }
        }

        // Test Member Fn: ToString //----------------------------------------//

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i ()
        {
            Vector2 a = new Vector2(42, -17);

            String result = a.ToString();

            String expected = "{X:42 Y:-17}";

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: GetHashCode //-------------------------------------//

        /// <summary>
        /// Makes sure that the hashing function is good by testing 10,000
        /// random scenarios and ensuring that there are no more than 10
        /// collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            var hs1 = new System.Collections.Generic.HashSet<Vector2>();
            var hs2 = new System.Collections.Generic.HashSet<Int32>();

            for(Int32 i = 0; i < 10000; ++i)
            {
                var a = GetNextRandomVector2();

                hs1.Add(a);
                hs2.Add(a.GetHashCode());
            }

            Assert.That(hs1.Count, Is.EqualTo(hs2.Count).Within(10));
        }

        // Test Member Fn: Length //------------------------------------------//

        /// <summary>
        /// Tests that for a known example the Length member function yields
        /// the correct result.
        /// </summary>
        [Test]
        public void TestMemberFn_Length_i ()
        {
            Vector2 a = new Vector2(3, -4);

            Single expected = 5;

            Single result = a.Length();

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: LengthSquared //-----------------------------------//

        /// <summary>
        /// Tests that for a known example the LengthSquared member function 
        /// yields the correct result.
        /// </summary>
        [Test]
        public void TestMemberFn_LengthSquared_i ()
        {
            Vector2 a = new Vector2(3, -4);

            Single expected = 25;

            Single result = a.LengthSquared();

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: IsUnit //------------------------------------------//

        /// <summary>
        /// Tests that for the simple vectors the IsUnit member function
        /// returns the correct result of TRUE.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_i ()
        {
            Vector2 a = new Vector2( 1,  0);
            Vector2 b = new Vector2(-1,  0);
            Vector2 c = new Vector2( 0,  1);
            Vector2 d = new Vector2( 0, -1);
            Vector2 e = new Vector2( 1,  1);
            Vector2 f = new Vector2( 0,  0);

            Assert.That(a.IsUnit(), Is.EqualTo(true));
            Assert.That(b.IsUnit(), Is.EqualTo(true));
            Assert.That(c.IsUnit(), Is.EqualTo(true));
            Assert.That(d.IsUnit(), Is.EqualTo(true));

            Assert.That(e.IsUnit(), Is.EqualTo(false));
            Assert.That(f.IsUnit(), Is.EqualTo(false));
        }

        /// <summary>
        /// This test makes sure that the IsUnit member function returns the 
        /// correct result of TRUE for a number of scenarios where the test 
        /// vector is both random and normalised.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector2 a = GetNextRandomVector2();

                Vector2 b; Vector2.Normalise(ref a, out b);

                Assert.That(b.IsUnit(), Is.EqualTo(true));
            }
        }

        /// <summary>
        /// This test ensures that the IsUnit member function correctly
        /// returns TRUE for a collection of vectors, all known to be of unit 
        /// length.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_iii ()
        {
            Single radius = 1;

            Single pi; RealMaths.Pi(out pi);

            for( Int32 i = 0; i <= 1000; ++ i)
            {
                Single theta = 2 * pi * i * radius / 100;

                Single x = RealMaths.Sin(theta);
                Single y = RealMaths.Cos(theta);               

                Assert.That(
                    new Vector2(x,  y).IsUnit(), 
                    Is.EqualTo(true));
            }
        }

        /// <summary>
        /// This test makes sure that the IsUnit member function returns the 
        /// correct result of FALSE for a number of scenarios where the test 
        /// vector is randomly generated and not normalised.  It's highly
        /// unlikely that the random generator will create a unit vector!
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_iv ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector2 a = GetNextRandomVector2();

                Assert.That(a.IsUnit(), Is.EqualTo(false));
            }
        }
            
        // Test Constant: Zero //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector2 initilised using the Zero constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Zero_i ()
        {
            Vector2 result = Vector2.Zero;
            Vector2 expected = new Vector2(0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: One //----------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector2 initilised using the One constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_One_i ()
        {
            Vector2 result = Vector2.One;
            Vector2 expected = new Vector2(1, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitX //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector2 initilised using the UnitX 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitX_i ()
        {
            Vector2 result = Vector2.UnitX;
            Vector2 expected = new Vector2(1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitY //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector2 initilised using the UnitY
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitY_i ()
        {
            Vector2 result = Vector2.UnitY;
            Vector2 expected = new Vector2(0, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Static Fn: Distance //----------------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the Distance method
        /// yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_Distance_i ()
        {
            {
                Vector2 a = new Vector2(0, 4);
                Vector2 b = new Vector2(3, 0);

                Single expected = 5;
                Single result;

                Vector2.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector2 a = new Vector2(0, -4);
                Vector2 b = new Vector2(3, 0);

                Single expected = 5;
                Single result;

                Vector2.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector2 a = new Vector2(0, -4);
                Vector2 b = new Vector2(-3, 0);

                Single expected = 5;
                Single result;

                Vector2.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector2 a = Vector2.Zero;

                Single expected = 0;
                Single result;

                Vector2.Distance(ref a, ref a, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Distance method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Distance_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector2 a = GetNextRandomVector2();

                Single expected =
                    RealMaths.Sqrt((a.X * a.X) + (a.Y * a.Y));

                Assert.That(a.Length(), Is.EqualTo(expected));
            }
        }

        // Test Static Fn: DistanceSquared //---------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the DistanceSquared
        /// method yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_DistanceSquared_i ()
        {
            {
                Vector2 a = new Vector2(0, 4);
                Vector2 b = new Vector2(3, 0);

                Single expected = 25;
                Single result;

                Vector2.DistanceSquared(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector2 a = Vector2.Zero;

                Single expected = 0;
                Single result;

                Vector2.DistanceSquared(ref a, ref a, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }


        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// DistanceSquared method yeilds the same results as those obtained
        /// from performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_DistanceSquared_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector2 a = GetNextRandomVector2();
                Vector2 b = GetNextRandomVector2();

                Vector2 c = b - a;

                Single expected = (c.X * c.X) + (c.Y * c.Y);
                Single result;

                Vector2.DistanceSquared(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        // Test Static Fn: Dot //---------------------------------------------//

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Dot method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector2 a = GetNextRandomVector2();
                Vector2 b = GetNextRandomVector2();

                Single expected = (a.X * b.X) + (a.Y * b.Y);
                Single result; Vector2.Dot(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        /// <summary>
        /// Assert that two unit vectors pointing in opposing directions yeild a
        /// dot product of negative one.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_ii ()
        {
            Vector2 a = new Vector2(1, 0);
            Vector2 b = new Vector2(-1, 0);

            Single expected = -1;
            Single result; Vector2.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that two unit vectors pointing in the same direction yeild a
        /// dot product of one.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_iii ()
        {
            Vector2 a = new Vector2(1, 0);
            Vector2 b = new Vector2(1, 0);

            Single expected = 1;
            Single result; Vector2.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that two perpendicular unit vectors yeild a dot product of
        /// zero.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_iv ()
        {
            Vector2 a = new Vector2(1, 0);
            Vector2 b = new Vector2(0, 1);

            Single expected = 0;
            Single result; Vector2.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Static Fn: Normalise //---------------------------------------//

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_i()
        {
            {
                Vector2 a = Vector2.Zero;

                Vector2 b;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException),
                    () =>
                    Vector2.Normalise(ref a, out b)
                );
            }

            {
                Vector2 a = new Vector2(
                    Single.MaxValue,
                    Single.MaxValue);

                Vector2 b;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException),
                    () =>
                    Vector2.Normalise(ref a, out b)
                );
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Normalise method yeilds a unit vector (with length equal to one);
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_ii ()
        {
            Single epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector2 a = GetNextRandomVector2();

                Vector2 b; Vector2.Normalise(ref a, out b);
                Single expected = 1;
                Single result1 = b.Length();
                Assert.That(result1, Is.EqualTo(expected).Within(epsilon));

                // The normalise function takes both a ref and out parameter,
                // need to check that if we pass in the same value as both
                // parameters we get the same results.
                Vector2 c = a;
                Vector2.Normalise(ref c, out c);
                Single result2 = c.Length();
                Assert.That(result2, Is.EqualTo(expected).Within(epsilon));
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Normalise method yeilds a vector, which when multipled by the
        /// length of the original vector results in the same vector as the
        /// original vector;
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_iii ()
        {
            Single epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector2 a = GetNextRandomVector2();
                Single l = a.Length();
                Vector2 expected = a;

                Vector2 b; Vector2.Normalise(ref a, out b);
                Vector2 result1 = b * l;
                AssertEqualWithinReason(result1, expected);

                Vector2 c = a;

                // The normalise function takes both a ref and out parameter,
                // need to check that if we pass in the same value as both
                // parameters we get the same results.
                Vector2.Normalise(ref c, out c);
                Vector2 result2 = c * l;
                AssertEqualWithinReason(result2, expected);
            }
        }

        // Test Static Fn: Reflect //-----------------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the Reflect method
        /// yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_Reflect_i ()
        {
            {
                Vector2 incident = new Vector2(20, -5);

                Vector2 normal = new Vector2(1, -1);
                Vector2.Normalise(ref normal, out normal);

                Vector2 expected = new Vector2(-5, 20);
                Vector2 result;
                Vector2.Reflect(ref incident, ref normal, out result);

                AssertEqualWithinReason(result, expected);
            }

            {
                Vector2 incident = new Vector2(20, -5);

                Vector2 normal = new Vector2(2, -1);
                Vector2.Normalise(ref normal, out normal);

                Vector2 expected = new Vector2(-16, 13);
                Vector2 result;
                Vector2.Reflect(ref incident, ref normal, out result);

                AssertEqualWithinReason(result, expected);
            }

            {
                Vector2 incident = Vector2.Zero;

                Vector2 normal = new Vector2(1, 0);

                Vector2 result;
                Vector2.Reflect(ref incident, ref normal, out result);

                AssertEqualWithinReason(result, Vector2.Zero);
            }
        }


        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Reflect method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Reflect_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector2 a = GetNextRandomVector2();

                Vector2 b = GetNextRandomVector2();

                Vector2.Normalise(ref b, out b);

                Vector2 result;
                Vector2.Reflect(ref a, ref b, out result);

                Single dot;
                Vector2.Dot(ref a, ref b, out dot);

                Vector2 expected = a - (2 * dot * b);

                AssertEqualWithinReason(result, expected);
            }
        }

        /// <summary>
        /// Assert that an argument exception is thrown if the value passed in
        /// to the normal parameter is not normalised.
        /// </summary>
        [Test]
        public void TestStaticFn_Reflect_iii ()
        {
            Vector2 incident = GetNextRandomVector2();
            Vector2 normal = new Vector2(12, -241);

            Vector2 result;

            Assert.Throws(
                typeof(ArgumentOutOfRangeException),
                () =>
                Vector2.Reflect(ref incident, ref normal, out result)
            );
        }

        // Test Static Fn: TransformMatrix44 //-------------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformMatix44_i ()
        {
            Vector2 position = new Vector2 (8, 70);

            Single pi; RealMaths.Pi (out pi);

            Matrix44 rotmati = Matrix44.Identity;
            Matrix44 rotmatx; Matrix44.CreateRotationX(pi, out rotmatx);
            Matrix44 rotmaty; Matrix44.CreateRotationY(pi, out rotmaty);
            Matrix44 rotmatxy = rotmatx * rotmaty;

            Vector2 expected1 = new Vector2 ( 8,  70);
            Vector2 expected2 = new Vector2 ( 8, -70);
            Vector2 expected3 = new Vector2 (-8,  70);
            Vector2 expected4 = new Vector2 (-8, -70);

            Vector2 test1; Vector2.Transform (ref position, ref rotmati, out test1);
            Vector2 test2; Vector2.Transform (ref position, ref rotmatx, out test2);
            Vector2 test3; Vector2.Transform (ref position, ref rotmaty, out test3);
            Vector2 test4; Vector2.Transform (ref position, ref rotmatxy, out test4);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
        }

        // Test Static Fn: TransformNormal //---------------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformNormal_i ()
        {
            Vector2 position = new Vector2 (8, 70);
            Vector2.Normalise (ref position, out position);
            Single pi; RealMaths.Pi (out pi);

            Matrix44 rotmati = Matrix44.Identity;
            Matrix44 rotmatx; Matrix44.CreateRotationX(pi, out rotmatx);
            Matrix44 rotmaty; Matrix44.CreateRotationY(pi, out rotmaty);
            Matrix44 rotmatxy = rotmatx * rotmaty;

            Vector2 expected1 = new Vector2 ( 8,  70);
            Vector2 expected2 = new Vector2 ( 8, -70);
            Vector2 expected3 = new Vector2 (-8,  70);
            Vector2 expected4 = new Vector2 (-8, -70);

            Vector2.Normalise (ref expected1, out expected1);
            Vector2.Normalise (ref expected2, out expected2);
            Vector2.Normalise (ref expected3, out expected3);
            Vector2.Normalise (ref expected4, out expected4);

            Vector2 test1; Vector2.TransformNormal (ref position, ref rotmati, out test1);
            Vector2 test2; Vector2.TransformNormal (ref position, ref rotmatx, out test2);
            Vector2 test3; Vector2.TransformNormal (ref position, ref rotmaty, out test3);
            Vector2 test4; Vector2.TransformNormal (ref position, ref rotmatxy, out test4);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);

            // should also work with the standard transform fn
            Vector2 test1n; Vector2.Transform (ref position, ref rotmati, out test1n);
            Vector2 test2n; Vector2.Transform (ref position, ref rotmatx, out test2n);
            Vector2 test3n; Vector2.Transform (ref position, ref rotmaty, out test3n);
            Vector2 test4n; Vector2.Transform (ref position, ref rotmatxy, out test4n);

            AssertEqualWithinReason(test1n, expected1);
            AssertEqualWithinReason(test2n, expected2);
            AssertEqualWithinReason(test3n, expected3);
            AssertEqualWithinReason(test4n, expected4);
        }

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformNormal_ii ()
        {
            Matrix44 rotmat = Matrix44.Identity;
            Vector2 normal = new Vector2 (21, -532);
            Vector2 result;
            Assert.Throws(
                typeof(ArgumentOutOfRangeException),
                () =>
                Vector2.TransformNormal(ref normal, ref rotmat, out result)
            );
        }

        // Test Static Fn: TransformQuaternion //-----------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformQuaternion_i ()
        {
            Vector2 position = new Vector2 (8, 70);
            Single pi; RealMaths.Pi (out pi);

            Quaternion quatmati = new Quaternion (0, 0, 0, 1);
            Quaternion quatmatx = new Quaternion (1, 0, 0, 0);
            Quaternion quatmaty = new Quaternion (0, 1, 0, 0);
            Quaternion quatmatxy = new Quaternion (0, 0, 1, 0);

            Vector2 expected1 = new Vector2 ( 8,  70);
            Vector2 expected2 = new Vector2 ( 8, -70);
            Vector2 expected3 = new Vector2 (-8,  70);
            Vector2 expected4 = new Vector2 (-8, -70);

            Vector2 test1; Vector2.Transform (ref position, ref quatmati, out test1);
            Vector2 test2; Vector2.Transform (ref position, ref quatmatx, out test2);
            Vector2 test3; Vector2.Transform (ref position, ref quatmaty, out test3);
            Vector2 test4; Vector2.Transform (ref position, ref quatmatxy, out test4);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
        }

        // Test Operator: Equality //-----------------------------------------//

        /// <summary>
        /// Helper method for testing equality.
        /// </summary>
        void TestEquality (Vector2 a, Vector2 b, Boolean expected )
        {
            // This test asserts the following:
            //   (a == b) == expected
            //   (b == a) == expected
            //   (a != b) == !expected
            //   (b != a) == !expected

            Boolean result_1a = (a == b);
            Boolean result_1b = (a.Equals(b));
            Boolean result_1c = (a.Equals((Object)b));
            
            Boolean result_2a = (b == a);
            Boolean result_2b = (b.Equals(a));
            Boolean result_2c = (b.Equals((Object)a));

            Boolean result_3a = (a != b);
            Boolean result_4a = (b != a);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_1c, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
            Assert.That(result_2c, Is.EqualTo(expected));
            Assert.That(result_3a, Is.EqualTo(!expected));
            Assert.That(result_4a, Is.EqualTo(!expected));
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of TRUE when two equal  
        /// Vector2 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_i ()
        {
            var a = new Vector2(44, -54);
            var b = new Vector2(44, -54);

            Boolean expected = true;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of FALSE when two unequal  
        /// Vector2 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_ii ()
        {
            var a = new Vector2(44, 54);
            var b = new Vector2(44, -54);

            Boolean expected = false;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Tests to make sure that all the equality opperators and functions 
        /// yield the expected result of TRUE when used on a number of randomly 
        /// generated pairs of equal Vector2 objects.
        /// </summary>
        [Test]
        public void TestOperator_Equality_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();

                Vector2 b = a;

                this.TestEquality(a, b, true);
            }
        }


        // Test Operator: Addition //-----------------------------------------//

        /// <summary>
        /// Helper method for testing addition.
        /// </summary>
        void TestAddition (Vector2 a, Vector2 b, Vector2 expected )
        {
            // This test asserts the following:
            //   a + b == expected
            //   b + a == expected

            var result_1a = a + b;
            var result_2a = b + a;

            Vector2 result_1b; Vector2.Add(ref a, ref b, out result_1b);
            Vector2 result_2b; Vector2.Add(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the addition opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_i ()
        {
            var a = new Vector2(3, -6);
            var b = new Vector2(-6, 12);

            var expected = new Vector2(-3, 6);

            this.TestAddition(a, b, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving the zero vector, all the 
        /// addition opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_ii ()
        {
            var a = new Vector2(-2313, 88);

            var expected = a;

            this.TestAddition(a, Vector2.Zero, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving two zero vectors, all the 
        /// addition opperators and functions yield the correct result of zero.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iii ()
        {
            this.TestAddition(Vector2.Zero, Vector2.Zero, Vector2.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// addition opperators and functions yield the same results as a
        /// manual addition calculation.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();
                var b = GetNextRandomVector2();

                var expected = new Vector2(a.X + b.X, a.Y + b.Y);

                this.TestAddition(a, b, expected);
            }
        }

        // Test Operator: Subtraction //--------------------------------------//
        
        /// <summary>
        /// Helper method for testing subtraction.
        /// </summary>
        void TestSubtraction (Vector2 a, Vector2 b, Vector2 expected )
        {
            // This test asserts the following:
            //   a - b == expected
            //   b - a == -expected

            var result_1a = a - b;
            var result_2a = b - a;

            Vector2 result_1b; Vector2.Subtract(ref a, ref b, out result_1b);
            Vector2 result_2b; Vector2.Subtract(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(-expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(-expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the subtraction opperators
        /// and functions yield the correct result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_i ()
        {
            var a = new Vector2(12, -4);
            var b = new Vector2(15, 11);
            var expected = new Vector2(-3, -15);
            this.TestSubtraction(a, b, expected);

            var c = new Vector2(-423, 342);
            this.TestSubtraction(c, Vector2.Zero, c);
        }

        /// <summary>
        /// Assert that when subtracting the zero vector fromt the zero vector, 
        /// all the subtraction opperators and functions yield the correct 
        /// result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_ii ()
        {
            this.TestSubtraction(Vector2.Zero, Vector2.Zero, Vector2.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// subtraction opperators and functions yield the same results as a
        /// manual subtraction calculation.
        /// </summary>
        [Test]
        public void TestOperator_Subtraction_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();
                var b = GetNextRandomVector2();

                var expected = new Vector2(a.X - b.X, a.Y - b.Y);

                this.TestSubtraction(a, b, expected);
            }
        }

        // Test Operator: Negation //-----------------------------------------//
        
        /// <summary>
        /// Helper method for testing negation.
        /// </summary>
        void TestNegation (Vector2 a, Vector2 expected )
        {
            // This test asserts the following:
            //   -a == expected

            var result_1a = -a;

            Vector2 result_1b; Vector2.Negate(ref a, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the negation opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_i ()
        {
            Single r = 3432;
            Single s = -6218;
            Single t = -3432;
            Single u = 6218;

            var a = new Vector2(r, s);
            var b = new Vector2(u, t);
            var c = new Vector2(t, u);
            var d = new Vector2(s, r);

            this.TestNegation(a, c);
            this.TestNegation(b, d);
        }

        /// <summary>
        /// Assert that, for known examples involving the zero vector, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_ii ()
        {
            Single t = -3432;
            Single u = 6218;
            Single r = 3432;
            Single s = -6218;

            var c = new Vector2(t, u);
            var d = new Vector2(s, r);

            this.TestNegation(c, Vector2.Zero - c);
            this.TestNegation(d, Vector2.Zero - d);
        }

        /// <summary>
        /// Assert that when negating the zero vector, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iii ()
        {
            this.TestNegation(Vector2.Zero, Vector2.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// negation opperators and functions yield the same results as a
        /// manual negation calculation.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();
                this.TestNegation(a, Vector2.Zero - a);
            }
        }

        // Test Operator: Multiplication //-----------------------------------//

        /// <summary>
        /// Helper method for testing multiplication.
        /// </summary>
        void TestMultiplication (Vector2 a, Vector2 b, Vector2 expected )
        {
            // This test asserts the following:
            //   a * b == expected
            //   b * a == expected

            var result_1a = a * b;
            var result_2a = b * a;

            Vector2 result_1b; Vector2.Multiply(ref a, ref b, out result_1b);
            Vector2 result_2b; Vector2.Multiply(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the multiplication opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_i ()
        {
            Single r = 18;
            Single s = -54;

            Single x = 3;
            Single y = 6;
            Single z = -9;

            var a = new Vector2(x, y);
            var b = new Vector2(y, z);
            var c = new Vector2(r, s);

            this.TestMultiplication(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// multiplication opperators and functions yield the same results as a
        /// manual multiplication calculation.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();
                var b = GetNextRandomVector2();

                var c = new Vector2(a.X * b.X, a.Y * b.Y);

                this.TestMultiplication(a, b, c);
            }
        }


        // Test Operator: Division //-----------------------------------------//

        /// <summary>
        /// Helper method for testing division.
        /// </summary>
        void TestDivision (Vector2 a, Vector2 b, Vector2 expected )
        {
            // This test asserts the following:
            //   a / b == expected

            var result_1a = a / b;

            Vector2 result_1b; Vector2.Divide(ref a, ref b, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example using whole numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_i ()
        {
            Single r = 10;
            Single s = -40;

            Single x = 2000;
            Single y = 200;
            Single z = -5;

            var a = new Vector2(x, y);
            var b = new Vector2(y, z);
            var c = new Vector2(r, s);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a known example using fractional numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_ii ()
        {
            Single t = ((Single) 1 ) / ((Single) 10);
            Single u = ((Single) (-1) ) / ((Single) 40 );
            Single x = 2000;
            Single y = 200;
            Single z = -5;

            var a = new Vector2(y, z);
            var b = new Vector2(x, y);
            var c = new Vector2(t, u);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// division opperators and functions yield the same results as a
        /// manual addition division.
        /// </summary>
        [Test]
        public void TestOperator_Division_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();
                var b = GetNextRandomVector2();

                var c = new Vector2(a.X / b.X, a.Y / b.Y);

                this.TestDivision(a, b, c);
            }
        }

        // Test Static Fn: SmoothStep //--------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();
                var b = GetNextRandomVector2();

                Single amount1 = 0;
                Vector2 result1;

                Vector2.SmoothStep (
                    ref a, ref b, amount1, out result1);

                AssertEqualWithinReason(result1, a);

                Single amount2 = 1;
                Vector2 result2;

                Vector2.SmoothStep (
                    ref a, ref b, amount2, out result2);

                AssertEqualWithinReason(result2, b);
            }
        }

        /// <summary>
        /// Assert that, for known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_ii ()
        {
            var a = GetNextRandomVector2();
            var b = GetNextRandomVector2();

            Single half; RealMaths.Half(out half);

            var tests = new Single[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector2 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector2.SmoothStep (
                            ref a, ref b, amount, out result)
                    );
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_iii ()
        {
            var a = new Vector2( -30, -30 );
            var b = new Vector2( +30, +30 );

            Single one = 1;

            Single i;
            RealMaths.FromFraction(1755, 64, out i); // 27.421875
            
            Single j;
            RealMaths.FromFraction( 165,  8, out j); // 20.625
            
            Single k;
            RealMaths.FromFraction( 705, 64, out k); // 11.015625

            Single a0 = 0;
            Single a1 = (one * 1) / 8;
            Single a2 = (one * 2) / 8;
            Single a3 = (one * 3) / 8;
            Single a4 = (one * 4) / 8;
            Single a5 = (one * 5) / 8;
            Single a6 = (one * 6) / 8;
            Single a7 = (one * 7) / 8;
            Single a8 = 1;

            Vector2 r0 = a;
            Vector2 r1 = new Vector2( -i, -i );
            Vector2 r2 = new Vector2( -j, -j );
            Vector2 r3 = new Vector2( -k, -k );
            Vector2 r4 = Vector2.Zero;
            Vector2 r5 = new Vector2(  k,  k );
            Vector2 r6 = new Vector2(  j,  j );
            Vector2 r7 = new Vector2(  i,  i );
            Vector2 r8 = b;

            var knownResults = new List<Tuple<Single, Vector2>>
            {
                new Tuple<Single, Vector2>( a0, r0 ),
                new Tuple<Single, Vector2>( a1, r1 ),
                new Tuple<Single, Vector2>( a2, r2 ),
                new Tuple<Single, Vector2>( a3, r3 ),
                new Tuple<Single, Vector2>( a4, r4 ),
                new Tuple<Single, Vector2>( a5, r5 ),
                new Tuple<Single, Vector2>( a6, r6 ),
                new Tuple<Single, Vector2>( a7, r7 ),
                new Tuple<Single, Vector2>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector2 result;

                Vector2.SmoothStep (
                    ref a, ref b, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        // Test Static Fn: CatmullRom //--------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();
                var b = GetNextRandomVector2();
                var c = GetNextRandomVector2();
                var d = GetNextRandomVector2();

                Single amount1 = 0;
                Vector2 result1;

                Vector2.CatmullRom (
                    ref a, ref b, ref c, ref d, amount1, out result1);

                AssertEqualWithinReason(result1, b);

                Single amount2 = 1;
                Vector2 result2;

                Vector2.CatmullRom (
                    ref a, ref b, ref c, ref d, amount2, out result2);

                AssertEqualWithinReason(result2, c);
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_ii ()
        {
            var a = new Vector2( -90, +30 );
            var b = new Vector2( -30, -30 );
            var c = new Vector2( +30, +30 );
            var d = new Vector2( +90, -30 );

            Single one = 1;

            Single u = 15;
            Single v = (Single) 165  / (Single)  8; // 20.5
            Single w = (Single) 45   / (Single)  2; // 20.625
            Single x = (Single) 1755 / (Single) 64; // 27.421875
            Single y = (Single) 15   / (Single)  2; // 14.5
            Single z = (Single) 705  / (Single) 64; // 11.015625

            Single a0 = 0;
            Single a1 = (one * 1) / 8;
            Single a2 = (one * 2) / 8;
            Single a3 = (one * 3) / 8;
            Single a4 = (one * 4) / 8;
            Single a5 = (one * 5) / 8;
            Single a6 = (one * 6) / 8;
            Single a7 = (one * 7) / 8;
            Single a8 = 1;

            Vector2 r0 = b;
            Vector2 r1 = new Vector2( -w, -x );
            Vector2 r2 = new Vector2( -u, -v );
            Vector2 r3 = new Vector2( -y, -z );
            Vector2 r4 = Vector2.Zero;
            Vector2 r5 = new Vector2(  y,  z );
            Vector2 r6 = new Vector2(  u,  v );
            Vector2 r7 = new Vector2(  w,  x );
            Vector2 r8 = c;

            var knownResults = new List<Tuple<Single, Vector2>>
            {
                new Tuple<Single, Vector2>( a0, r0 ),
                new Tuple<Single, Vector2>( a1, r1 ),
                new Tuple<Single, Vector2>( a2, r2 ),
                new Tuple<Single, Vector2>( a3, r3 ),
                new Tuple<Single, Vector2>( a4, r4 ),
                new Tuple<Single, Vector2>( a5, r5 ),
                new Tuple<Single, Vector2>( a6, r6 ),
                new Tuple<Single, Vector2>( a7, r7 ),
                new Tuple<Single, Vector2>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector2 result;

                Vector2.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        /// <summary>
        /// Assert that, for known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_iii ()
        {
            var a = GetNextRandomVector2();
            var b = GetNextRandomVector2();
            var c = GetNextRandomVector2();
            var d = GetNextRandomVector2();
            
            Single half; RealMaths.Half(out half);

            var tests = new Single[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector2 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector2.CatmullRom (
                            ref a, ref b, ref c, ref d, amount, out result)
                );
            }
        }

        /// <summary>
        /// This tests compares results against an example where all the control
        /// points are in a straight line.  In this case the resulting spline
        /// should be a straight line.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_iv ()
        {
            var a = new Vector2( -90, -90 );
            var b = new Vector2( -30, -30 );
            var c = new Vector2( +30, +30 );
            var d = new Vector2( +90, +90 );

            Single one = 1;

            Single a0 = 0;
            Single a1 = (one * 1) / 4;
            Single a2 = (one * 2) / 4;
            Single a3 = (one * 3) / 4;
            Single a4 = 1;

            Vector2 r0 = b;
            Vector2 r1 = new Vector2( -15, -15 );
            Vector2 r2 = Vector2.Zero;
            Vector2 r3 = new Vector2( 15, 15 );
            Vector2 r4 = c;

            var knownResults = new List<Tuple<Single, Vector2>>
            {
                new Tuple<Single, Vector2>( a0, r0 ),
                new Tuple<Single, Vector2>( a1, r1 ),
                new Tuple<Single, Vector2>( a2, r2 ),
                new Tuple<Single, Vector2>( a3, r3 ),
                new Tuple<Single, Vector2>( a4, r4 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector2 result;

                Vector2.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        // Test Static Fn: Hermite //-----------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a  = GetNextRandomVector2();
                var b  = GetNextRandomVector2();

                var c = GetNextRandomVector2();
                var d = GetNextRandomVector2();

                Vector2 an; Vector2.Normalise(ref c, out an);
                Vector2 bn; Vector2.Normalise(ref d, out bn);

                Single amount1 = 0;
                Vector2 result1;

                Vector2.Hermite (
                    ref a, ref an, ref b, ref bn, amount1, out result1);

                AssertEqualWithinReason(result1, a);

                Single amount2 = 1;
                Vector2 result2;

                Vector2.Hermite (
                    ref a, ref an, ref b, ref bn, amount2, out result2);

                AssertEqualWithinReason(result2, b);
            }
        }

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_ii ()
        {
            var a = GetNextRandomVector2();
            var b = GetNextRandomVector2();
            var c = GetNextRandomVector2();
            var d = GetNextRandomVector2();

            Vector2 an; Vector2.Normalise(ref c, out an);
            Vector2 bn; Vector2.Normalise(ref d, out bn);

            Single half; RealMaths.Half(out half);

            var tests = new Single[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector2 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector2.Hermite (
                            ref a, ref an, ref b, ref bn, amount, out result)
                    );
                
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_iii ()
        {
            var a = new Vector2( -100, +50 );
            var b = new Vector2( +100, -50 );

            var c = new Vector2( -10, +5 );
            var d = new Vector2( +10, -5 );

            Vector2 an; Vector2.Normalise(ref c, out an);
            Vector2 bn; Vector2.Normalise(ref d, out bn);

            Single one = 1;
            
            // 100.1953125
            Single e = (Single) 51300 / (Single) 512;

            // 50.09765625
            Single f = (Single) 12825 / (Single) 256;

            // 91.25
            Single g = (Single) 365 / (Single) 4;

            // 45.625
            Single h = (Single) 365 / (Single) 8;

            // 75.7421875
            Single i = (Single) 9695 / (Single) 128;

            // 37.87109375
            Single j = (Single) 9695 / (Single) 256;

            // 56.25
            Single k = (Single) 225 / (Single) 4;

            // 28.125
            Single l = (Single) 225 / (Single) 8;

            // 35.3515625
            Single m = (Single) 4525 / (Single) 128;

            // 17.67578125
            Single n = (Single) 4525 / (Single) 256;

            // 15.625
            Single o = (Single) 125 / (Single) 8;

            // 7.8125
            Single p = (Single) 125 / (Single) 16;

            // 0.3515625
            Single q = (Single) 45 / (Single) 128;

            // 0.17578125
            Single r = (Single) 45 / (Single) 256;

            Single a0 = 0;
            Single a1 = (one * 1) / 8;
            Single a2 = (one * 2) / 8;
            Single a3 = (one * 3) / 8;
            Single a4 = (one * 4) / 8;
            Single a5 = (one * 5) / 8;
            Single a6 = (one * 6) / 8;
            Single a7 = (one * 7) / 8;
            Single a8 = 1;

            Vector2 r0 = b;
            Vector2 r1 = new Vector2(  e, -f );
            Vector2 r2 = new Vector2(  g, -h );
            Vector2 r3 = new Vector2(  i, -j );
            Vector2 r4 = new Vector2(  k, -l );
            Vector2 r5 = new Vector2(  m, -n );
            Vector2 r6 = new Vector2(  o, -p );
            Vector2 r7 = new Vector2( -q,  r );
            Vector2 r8 = c;

            var knownResults = new List<Tuple<Single, Vector2>>
            {
                new Tuple<Single, Vector2>( a0, r0 ),
                new Tuple<Single, Vector2>( a1, r1 ),
                new Tuple<Single, Vector2>( a2, r2 ),
                new Tuple<Single, Vector2>( a3, r3 ),
                new Tuple<Single, Vector2>( a4, r4 ),
                new Tuple<Single, Vector2>( a5, r5 ),
                new Tuple<Single, Vector2>( a6, r6 ),
                new Tuple<Single, Vector2>( a7, r7 ),
                new Tuple<Single, Vector2>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector2 result;

                Vector2.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

                /// <summary>
        /// Assert that, running the Min function on a number of randomly
        /// generated pairs of Vector2 objects, yields the same results as those
        /// obtained from performing a manual Min calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Min ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector2 a = GetNextRandomVector2();
                Vector2 b = a * 2;

                Vector2 result;
                Vector2.Min (ref a, ref b, out result);

                Assert.That(result.X, Is.EqualTo(a.X < b.X ? a.X : b.X ));
                Assert.That(result.Y, Is.EqualTo(a.Y < b.Y ? a.Y : b.Y ));
            }
        }

        /// <summary>
        /// Assert that, running the Max function on a number of randomly
        /// generated pairs of Vector2 objects, yields the same results as those
        /// obtained from performing a manual Max calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Max ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector2 a = GetNextRandomVector2();
                Vector2 b = GetNextRandomVector2();

                Vector2 result;
                Vector2.Max (ref a, ref b, out result);

                Assert.That(result.X, Is.EqualTo(a.X > b.X ? a.X : b.X ));
                Assert.That(result.Y, Is.EqualTo(a.Y > b.Y ? a.Y : b.Y ));
            }
        }

        /// <summary>
        /// Assert that, running the Clamp function on a number of randomly
        /// generated Vector2 objects for a given min-max range, yields
        /// results that fall within that range.
        /// </summary>
        [Test]
        public void TestStaticFn_Clamp_i ()
        {
            Vector2 min = new Vector2(-30, 1);
            Vector2 max = new Vector2(32, 130);

            for(Int32 i = 0; i < 100; ++i)
            {
                Vector2 a = GetNextRandomVector2();

                Vector2 result;
                Vector2.Clamp (ref a, ref min, ref max, out result);

                Assert.That(result.X, Is.LessThanOrEqualTo(max.X));
                Assert.That(result.Y, Is.LessThanOrEqualTo(max.Y));
                Assert.That(result.X, Is.GreaterThanOrEqualTo(min.X));
                Assert.That(result.Y, Is.GreaterThanOrEqualTo(min.Y));
            }
        }

        /// <summary>
        /// Assert that, running the Clamp function on an a Vector2 object known
        /// to fall outside of a given min-max range, yields a result that fall 
        /// within that range.
        /// </summary>
        [Test]
        public void TestStaticFn_Clamp_ii ()
        {
            Vector2 min = new Vector2(-30, 1);
            Vector2 max = new Vector2(32, 130);

            Vector2 a = new Vector2(-100, 1113);

            Vector2 expected = new Vector2(-30, 130);

            Vector2 result;
            Vector2.Clamp (ref a, ref min, ref max, out result);

            Assert.That(result.X, Is.LessThanOrEqualTo(max.X));
            Assert.That(result.Y, Is.LessThanOrEqualTo(max.Y));
            Assert.That(result.X, Is.GreaterThanOrEqualTo(min.X));
            Assert.That(result.Y, Is.GreaterThanOrEqualTo(min.Y));

            AssertEqualWithinReason(result, expected);

        }

        /// <summary>
        /// Assert that, running the Lerp function on a number of randomly
        /// generated pairs of Vector2 objects for a range of weighting amounts, 
        /// yields the same results as those obtained from performing a manual 
        /// Lerp calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_i ()
        {
            for(Int32 j = 0; j < 100; ++j)
            {
                Single delta = j;

                delta = delta / 100;

                for(Int32 i = 0; i < 100; ++i)
                {
                    Vector2 a = GetNextRandomVector2();
                    Vector2 b = GetNextRandomVector2();

                    Vector2 result;
                    Vector2.Lerp (ref a, ref b, delta, out result);

                    Vector2 expected = a + ( ( b - a ) * delta );

                    AssertEqualWithinReason(result, expected);
                }
            }
        }

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_ii ()
        {
            Vector2 a = GetNextRandomVector2();
            Vector2 b = GetNextRandomVector2();

            Single half; RealMaths.Half(out half);

            var tests = new Single[] { 2, half + 1, -half, -1 };

            foreach( var weighting in tests )
            {
                Vector2 result; 
                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector2.Lerp (
                            ref a, ref b, weighting, out result)
                    );
            }
        }


    }    /// <summary>
    /// 
    /// </summary>
    [TestFixture]
    public class Vector3Tests
    {
        /// <summary>
        /// The random number generator used for testing.
        /// </summary>
        static readonly System.Random rand;

        /// <summary>
        /// Static constructor used to ensure that the random number generator
        /// always gets initilised with the same seed, making the tests
        /// behave in a deterministic manner.
        /// </summary>
        static Vector3Tests ()
        {
            rand = new System.Random(0);
        }

        /// <summary>
        /// Helper function for getting the next random Single value.
        /// </summary>
        static Single GetNextRandomSingle ()
        {
            Single randomValue = rand.NextSingle();

            Single zero = 0;
            Single multiplier = 1000;

            randomValue *= multiplier;

            Boolean randomBoolean = (rand.Next(0, 1) == 0) ? true : false;

            if( randomBoolean )
                randomValue = zero - randomValue;

            return randomValue;
        }

        /// <summary>
        /// Helper function for getting the next random Vector3.
        /// </summary>
        static Vector3 GetNextRandomVector3 ()
        {
            Single a = GetNextRandomSingle();
            Single b = GetNextRandomSingle();
            Single c = GetNextRandomSingle();

            return new Vector3(a, b, c);
        }

        /// <summary>
        /// Helper to encapsulate asserting that two Vector3s are equal.
        /// </summary>
        static void AssertEqualWithinReason (Vector3 a, Vector3 b)
        {
            Single tolerance; RealMaths.TestTolerance(out tolerance);

            Assert.That(a.X, Is.EqualTo(b.X).Within(tolerance));
            Assert.That(a.Y, Is.EqualTo(b.Y).Within(tolerance));
            Assert.That(a.Z, Is.EqualTo(b.Z).Within(tolerance));
        }
        

        // Test: StructLayout //----------------------------------------------//

        /// <summary>
        /// This test makes sure that the struct layout has been defined
        /// correctly.
        /// </summary>
        [Test]
        public void Test_StructLayout_i ()
        {
            Type t = typeof(Vector3);

            Assert.That(
                t.StructLayoutAttribute.Value, 
                Is.EqualTo(LayoutKind.Sequential));
        }

        /// <summary>
        /// This test makes sure that when examining the memory addresses of the 
        /// X, Y and Z member variables of a number of randomly generated 
        /// Vector3 objects the results are as expected. 
        /// </summary>
        [Test]
        public unsafe void Test_StructLayout_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector3 vec = GetNextRandomVector3();

                GCHandle h_vec = GCHandle.Alloc(vec, GCHandleType.Pinned);

                IntPtr vecAddress = h_vec.AddrOfPinnedObject();

                Single[] data = new Single[3];

                // nb: when Fixed32 and Half are moved back into the main
                //     dev branch there will be need for an extension method for
                //     Marshal that will perform the copy for those types. 
                MarshalHelper.Copy(vecAddress, data, 0, 3);
                Assert.That(data[0], Is.EqualTo(vec.X));
                Assert.That(data[1], Is.EqualTo(vec.Y));
                Assert.That(data[2], Is.EqualTo(vec.Z));
                
                h_vec.Free();
            }
        }

        // Test: Constructors //----------------------------------------------//

        /// <summary>
        /// This test goes though each public constuctor and ensures that the 
        /// data members of the structure have been properly set.
        /// </summary>
        [Test]
        public void Test_Constructors_i ()
        {
            {
                // Test default values
                Vector3 a = new Vector3();
                Assert.That(a, Is.EqualTo(Vector3.Zero));
            }
            {
                // Test Vector3( Single, Single, Single )
                Single a = -189;
                Single b = 429;
                Single c = 4298;
                Vector3 d = new Vector3(a, b, c);
                Assert.That(d.X, Is.EqualTo(a));
                Assert.That(d.Y, Is.EqualTo(b));
                Assert.That(d.Z, Is.EqualTo(c));
            }
            {
                // Test Vector3( Vector2, Single )
                Vector2 a = new Vector2(-189, 429);
                Single b = 4298;
                Vector3 c = new Vector3(a, b);
                Assert.That(c.X, Is.EqualTo(a.X));
                Assert.That(c.Y, Is.EqualTo(a.Y));
                Assert.That(c.Z, Is.EqualTo(b));
            }
            {
                // Test no constructor
                Vector3 a;
                a.X = 0;
                a.Y = 0;
                a.Z = 0;
                Assert.That(a, Is.EqualTo(Vector3.Zero));
            }
        }

        // Test Member Fn: ToString //----------------------------------------//

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i ()
        {
            Vector3 a = new Vector3(42, -17, 13);

            String result = a.ToString();

            String expected = "{X:42 Y:-17 Z:13}";

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: GetHashCode //-------------------------------------//

        /// <summary>
        /// Makes sure that the hashing function is good by testing 10,000
        /// random scenarios and ensuring that there are no more than 10
        /// collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            var hs1 = new System.Collections.Generic.HashSet<Vector3>();
            var hs2 = new System.Collections.Generic.HashSet<Int32>();

            for(Int32 i = 0; i < 10000; ++i)
            {
                var a = GetNextRandomVector3();

                hs1.Add(a);
                hs2.Add(a.GetHashCode());
            }

            Assert.That(hs1.Count, Is.EqualTo(hs2.Count).Within(10));
        }

        // Test Member Fn: Length //------------------------------------------//

        /// <summary>
        /// Tests that for a known example the Length member function yields
        /// the correct result.
        /// </summary>
        [Test]
        public void TestMemberFn_Length_i ()
        {
            Vector3 a = new Vector3(3, -4, 12);

            Single expected = 13;

            Single result = a.Length();

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: LengthSquared //-----------------------------------//

        /// <summary>
        /// Tests that for a known example the LengthSquared member function 
        /// yields the correct result.
        /// </summary>
        [Test]
        public void TestMemberFn_LengthSquared_i ()
        {
            Vector3 a = new Vector3(3, -4, 12);

            Single expected = 169;

            Single result = a.LengthSquared();

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: IsUnit //------------------------------------------//

        /// <summary>
        /// Tests that for the simple vectors the IsUnit member function
        /// returns the correct result of TRUE.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_i ()
        {
            Vector3 a = new Vector3( 1,  0,  0);
            Vector3 b = new Vector3(-1,  0,  0);
            Vector3 c = new Vector3( 0,  1,  0);
            Vector3 d = new Vector3( 0, -1,  0);
            Vector3 e = new Vector3( 0,  0,  1);
            Vector3 f = new Vector3( 0,  0, -1);
            Vector3 g = new Vector3( 1,  1,  1);
            Vector3 h = new Vector3( 0,  0,  0);

            Assert.That(a.IsUnit(), Is.EqualTo(true));
            Assert.That(b.IsUnit(), Is.EqualTo(true));
            Assert.That(c.IsUnit(), Is.EqualTo(true));
            Assert.That(d.IsUnit(), Is.EqualTo(true));
            Assert.That(e.IsUnit(), Is.EqualTo(true));
            Assert.That(f.IsUnit(), Is.EqualTo(true));

            Assert.That(g.IsUnit(), Is.EqualTo(false));
            Assert.That(h.IsUnit(), Is.EqualTo(false));
        }

        /// <summary>
        /// This test makes sure that the IsUnit member function returns the 
        /// correct result of TRUE for a number of scenarios where the test 
        /// vector is both random and normalised.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector3 a = GetNextRandomVector3();

                Vector3 b; Vector3.Normalise(ref a, out b);

                Assert.That(b.IsUnit(), Is.EqualTo(true));
            }
        }

        /// <summary>
        /// This test ensures that the IsUnit member function correctly
        /// returns TRUE for a collection of vectors, all known to be of unit 
        /// length.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_iii ()
        {
            Single radius = 1;

            Single pi; RealMaths.Pi(out pi);

            for( Int32 i = 0; i <= 31; ++ i)
            {
                for( Int32 j = 0; j <= 31; ++ j)
                {
                    Single theta = 2 * pi * i / 100;
                    Single phi = 2 * pi * j / 100;

                    Single x = 
                        RealMaths.Cos(theta) * 
                        RealMaths.Sin(phi) * radius;

                    Single y = 
                        RealMaths.Sin(theta) * 
                        RealMaths.Sin(phi) * radius;

                    Single z = 
                        RealMaths.Cos(phi) * radius;                

                    Assert.That(
                        new Vector3( x,  y,  z).IsUnit(), 
                        Is.EqualTo(true));
                }
            }
        }

        /// <summary>
        /// This test makes sure that the IsUnit member function returns the 
        /// correct result of FALSE for a number of scenarios where the test 
        /// vector is randomly generated and not normalised.  It's highly
        /// unlikely that the random generator will create a unit vector!
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_iv ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector3 a = GetNextRandomVector3();

                Assert.That(a.IsUnit(), Is.EqualTo(false));
            }
        }
            
        // Test Constant: Zero //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the Zero constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Zero_i ()
        {
            Vector3 result = Vector3.Zero;
            Vector3 expected = new Vector3(0, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: One //----------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the One constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_One_i ()
        {
            Vector3 result = Vector3.One;
            Vector3 expected = new Vector3(1, 1, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitX //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the UnitX 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitX_i ()
        {
            Vector3 result = Vector3.UnitX;
            Vector3 expected = new Vector3(1, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitY //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the UnitY
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitY_i ()
        {
            Vector3 result = Vector3.UnitY;
            Vector3 expected = new Vector3(0, 1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitZ //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the UnitZ
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitZ_i ()
        {
            Vector3 result = Vector3.UnitZ;
            Vector3 expected = new Vector3(0, 0, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Up //-----------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the Up
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Up_i ()
        {
            Vector3 result = Vector3.Up;
            Vector3 expected = new Vector3(0, 1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Down //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the Down
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Down_i ()
        {
            Vector3 result = Vector3.Down;
            Vector3 expected = new Vector3(0, -1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Right //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the Right
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Right_i ()
        {
            Vector3 result = Vector3.Right;
            Vector3 expected = new Vector3(1, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Left //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the Left
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Left_i ()
        {
            Vector3 result = Vector3.Left;
            Vector3 expected = new Vector3(-1, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Forward //------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the Forward
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Forward_i ()
        {
            Vector3 result = Vector3.Forward;
            Vector3 expected = new Vector3(0, 0, -1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Backward //-----------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the Backward
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Backward_i ()
        {
            Vector3 result = Vector3.Backward;
            Vector3 expected = new Vector3(0, 0, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Static Fn: Distance //----------------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the Distance method
        /// yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_Distance_i ()
        {
            {
                Vector3 a = new Vector3(0, 4, 12);
                Vector3 b = new Vector3(3, 0, 0);

                Single expected = 13;
                Single result;

                Vector3.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector3 a = new Vector3(0, -4, 12);
                Vector3 b = new Vector3(3, 0, 0);

                Single expected = 13;
                Single result;

                Vector3.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector3 a = new Vector3(0, -4, -12);
                Vector3 b = new Vector3(-3, 0, 0);

                Single expected = 13;
                Single result;

                Vector3.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector3 a = Vector3.Zero;

                Single expected = 0;
                Single result;

                Vector3.Distance(ref a, ref a, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Distance method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Distance_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector3 a = GetNextRandomVector3();

                Single expected =
                    RealMaths.Sqrt((a.X * a.X) + (a.Y * a.Y) + (a.Z * a.Z));

                Assert.That(a.Length(), Is.EqualTo(expected));
            }
        }

        // Test Static Fn: DistanceSquared //---------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the DistanceSquared
        /// method yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_DistanceSquared_i ()
        {
            {
                Vector3 a = new Vector3(0, 4, 12);
                Vector3 b = new Vector3(3, 0, 0);

                Single expected = 161;
                Single result;

                Vector3.DistanceSquared(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector3 a = Vector3.Zero;

                Single expected = 0;
                Single result;

                Vector3.DistanceSquared(ref a, ref a, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }


        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// DistanceSquared method yeilds the same results as those obtained
        /// from performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_DistanceSquared_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector3 a = GetNextRandomVector3();
                Vector3 b = GetNextRandomVector3();

                Vector3 c = b - a;

                Single expected = (c.X * c.X) + (c.Y * c.Y) + (c.Z * c.Z);
                Single result;

                Vector3.DistanceSquared(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        // Test Static Fn: Dot //---------------------------------------------//

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Dot method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector3 a = GetNextRandomVector3();
                Vector3 b = GetNextRandomVector3();

                Single expected = (a.X * b.X) + (a.Y * b.Y) + (a.Z * b.Z);
                Single result; Vector3.Dot(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        /// <summary>
        /// Assert that two unit vectors pointing in opposing directions yeild a
        /// dot product of negative one.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_ii ()
        {
            Vector3 a = new Vector3(0, 0, 1);
            Vector3 b = new Vector3(0, 0, -1);

            Single expected = -1;
            Single result; Vector3.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that two unit vectors pointing in the same direction yeild a
        /// dot product of one.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_iii ()
        {
            Vector3 a = new Vector3(0, 0, 1);
            Vector3 b = new Vector3(0, 0, 1);

            Single expected = 1;
            Single result; Vector3.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that two perpendicular unit vectors yeild a dot product of
        /// zero.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_iv ()
        {
            Vector3 a = new Vector3(0, 1, 0);
            Vector3 b = new Vector3(0, 0, 1);

            Single expected = 0;
            Single result; Vector3.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Static Fn: Normalise //---------------------------------------//

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_i()
        {
            {
                Vector3 a = Vector3.Zero;

                Vector3 b;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException),
                    () =>
                    Vector3.Normalise(ref a, out b)
                );
            }

            {
                Vector3 a = new Vector3(
                    Single.MaxValue,
                    Single.MaxValue,
                    Single.MaxValue);

                Vector3 b;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException),
                    () =>
                    Vector3.Normalise(ref a, out b)
                );
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Normalise method yeilds a unit vector (with length equal to one);
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_ii ()
        {
            Single epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector3 a = GetNextRandomVector3();

                Vector3 b; Vector3.Normalise(ref a, out b);
                Single expected = 1;
                Single result1 = b.Length();
                Assert.That(result1, Is.EqualTo(expected).Within(epsilon));

                // The normalise function takes both a ref and out parameter,
                // need to check that if we pass in the same value as both
                // parameters we get the same results.
                Vector3 c = a;
                Vector3.Normalise(ref c, out c);
                Single result2 = c.Length();
                Assert.That(result2, Is.EqualTo(expected).Within(epsilon));
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Normalise method yeilds a vector, which when multipled by the
        /// length of the original vector results in the same vector as the
        /// original vector;
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_iii ()
        {
            Single epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector3 a = GetNextRandomVector3();
                Single l = a.Length();
                Vector3 expected = a;

                Vector3 b; Vector3.Normalise(ref a, out b);
                Vector3 result1 = b * l;
                AssertEqualWithinReason(result1, expected);

                Vector3 c = a;

                // The normalise function takes both a ref and out parameter,
                // need to check that if we pass in the same value as both
                // parameters we get the same results.
                Vector3.Normalise(ref c, out c);
                Vector3 result2 = c * l;
                AssertEqualWithinReason(result2, expected);
            }
        }

        // Test Static Fn: Cross //-------------------------------------------//
        [Test]
        public void TestStaticFn_Cross_i ()
        {
            Assert.That(true, Is.EqualTo(false));
        }

        // Test Static Fn: Reflect //-----------------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the Reflect method
        /// yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_Reflect_i ()
        {
            {
                Vector3 incident = new Vector3(20, -5, 10);

                Vector3 normal = new Vector3(1, -1, 2);
                Vector3.Normalise(ref normal, out normal);

                Vector3 expected = new Vector3(-5, 20, 2);
                Vector3 result;
                Vector3.Reflect(ref incident, ref normal, out result);

                AssertEqualWithinReason(result, expected);
            }

            {
                Vector3 incident = new Vector3(20, -5, 10);

                Vector3 normal = new Vector3(2, -1, 2);
                Vector3.Normalise(ref normal, out normal);

                Vector3 expected = new Vector3(-16, 13, 2);
                Vector3 result;
                Vector3.Reflect(ref incident, ref normal, out result);

                AssertEqualWithinReason(result, expected);
            }

            {
                Vector3 incident = Vector3.Zero;

                Vector3 normal = new Vector3(0, 0, 1);

                Vector3 result;
                Vector3.Reflect(ref incident, ref normal, out result);

                AssertEqualWithinReason(result, Vector3.Zero);
            }
        }


        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Reflect method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Reflect_ii ()
        {
            Single epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector3 a = GetNextRandomVector3();

                Vector3 b = GetNextRandomVector3();

                Vector3.Normalise(ref b, out b);

                Vector3 result;
                Vector3.Reflect(ref a, ref b, out result);

                Single dot;
                Vector3.Dot(ref a, ref b, out dot);

                Vector3 expected = a - (2 * dot * b);

                AssertEqualWithinReason(result, expected);
            }
        }

        /// <summary>
        /// Assert that an argument exception is thrown if the value passed in
        /// to the normal parameter is not normalised.
        /// </summary>
        [Test]
        public void TestStaticFn_Reflect_iii ()
        {
            Vector3 incident = GetNextRandomVector3();
            Vector3 normal = new Vector3(12, -241, 123);

            Vector3 result;

            Assert.Throws(
                typeof(ArgumentOutOfRangeException),
                () =>
                Vector3.Reflect(ref incident, ref normal, out result)
            );
        }

        // Test Static Fn: TransformMatrix44 //-------------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformMatix44_i ()
        {
            Vector3 position = new Vector3 (10, 50, -20);

            Single pi; RealMaths.Pi (out pi);
            Single tau; RealMaths.Tau (out tau);

            Matrix44 rotmati = Matrix44.Identity;
            Matrix44 rotmatx; Matrix44.CreateRotationX(pi, out rotmatx);
            Matrix44 rotmaty; Matrix44.CreateRotationY(tau, out rotmaty);
            Matrix44 rotmatz; Matrix44.CreateRotationZ(-pi, out rotmatz);
            Matrix44 rotmatxyz = rotmatx * rotmaty * rotmatz;

            Vector3 expected1 = new Vector3 ( 10,  50, -20);
            Vector3 expected2 = new Vector3 ( 10, -50,  20);
            Vector3 expected3 = new Vector3 ( 10,  50, -20);
            Vector3 expected4 = new Vector3 (-10, -50, -20);
            Vector3 expected5 = new Vector3 (-10,  50,  20);

            Vector3 test1; Vector3.Transform (ref position, ref rotmati, out test1);
            Vector3 test2; Vector3.Transform (ref position, ref rotmatx, out test2);
            Vector3 test3; Vector3.Transform (ref position, ref rotmaty, out test3);
            Vector3 test4; Vector3.Transform (ref position, ref rotmatz, out test4);
            Vector3 test5; Vector3.Transform (ref position, ref rotmatxyz, out test5);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
            AssertEqualWithinReason(test5, expected5);
        }

        // Test Static Fn: TransformNormal //---------------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformNormal_i ()
        {
            Vector3 position = new Vector3 (10, 50, -20);
            Vector3.Normalise (ref position, out position);

            Single pi; RealMaths.Pi (out pi);
            Single tau; RealMaths.Tau (out tau);

            Matrix44 rotmati = Matrix44.Identity;
            Matrix44 rotmatx; Matrix44.CreateRotationX(pi, out rotmatx);
            Matrix44 rotmaty; Matrix44.CreateRotationY(tau, out rotmaty);
            Matrix44 rotmatz; Matrix44.CreateRotationZ(-pi, out rotmatz);
            Matrix44 rotmatxyz = rotmatx * rotmaty * rotmatz;

            Vector3 expected1 = new Vector3 ( 10,  50, -20);
            Vector3 expected2 = new Vector3 ( 10, -50,  20);
            Vector3 expected3 = new Vector3 ( 10,  50, -20);
            Vector3 expected4 = new Vector3 (-10, -50, -20);
            Vector3 expected5 = new Vector3 (-10,  50,  20);

            Vector3.Normalise (ref expected1, out expected1);
            Vector3.Normalise (ref expected2, out expected2);
            Vector3.Normalise (ref expected3, out expected3);
            Vector3.Normalise (ref expected4, out expected4);
            Vector3.Normalise (ref expected5, out expected5);

            Vector3 test1; Vector3.TransformNormal (ref position, ref rotmati, out test1);
            Vector3 test2; Vector3.TransformNormal (ref position, ref rotmatx, out test2);
            Vector3 test3; Vector3.TransformNormal (ref position, ref rotmaty, out test3);
            Vector3 test4; Vector3.TransformNormal (ref position, ref rotmatz, out test4);
            Vector3 test5; Vector3.TransformNormal (ref position, ref rotmatxyz, out test5);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
            AssertEqualWithinReason(test5, expected5);

            // should also work with the standard transform fn
            Vector3 test1n; Vector3.TransformNormal (ref position, ref rotmati, out test1n);
            Vector3 test2n; Vector3.TransformNormal (ref position, ref rotmatx, out test2n);
            Vector3 test3n; Vector3.TransformNormal (ref position, ref rotmaty, out test3n);
            Vector3 test4n; Vector3.TransformNormal (ref position, ref rotmatz, out test4n);
            Vector3 test5n; Vector3.TransformNormal (ref position, ref rotmatxyz, out test5n);

            AssertEqualWithinReason(test1n, expected1);
            AssertEqualWithinReason(test2n, expected2);
            AssertEqualWithinReason(test3n, expected3);
            AssertEqualWithinReason(test4n, expected4);
            AssertEqualWithinReason(test5n, expected5);
        }

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformNormal_ii ()
        {
            Matrix44 rotmat = Matrix44.Identity;
            Vector3 normal = new Vector3 (21, -532, 0);
            Vector3 result;
            Assert.Throws(
                typeof(ArgumentOutOfRangeException),
                () =>
                Vector3.TransformNormal(ref normal, ref rotmat, out result)
            );
        }

        // Test Static Fn: TransformQuaternion //-----------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformQuaternion_i ()
        {
            Vector3 position = new Vector3 (10, 50, -20);

            Single pi;
            RealMaths.Pi (out pi);

            Quaternion quatmati = new Quaternion (0, 0, 0, 1);
            Quaternion quatmatx = new Quaternion (1, 0, 0, 0);
            Quaternion quatmaty = new Quaternion (0, 0, 0, 1);
            Quaternion quatmatz = new Quaternion (0, 0, 1, 0);
            Quaternion quatmatxyz = new Quaternion (0, 1, 0, 0);

            Vector3 expected1 = new Vector3 ( 10,  50, -20);
            Vector3 expected2 = new Vector3 ( 10, -50,  20);
            Vector3 expected3 = new Vector3 ( 10,  50, -20);
            Vector3 expected4 = new Vector3 (-10, -50, -20);
            Vector3 expected5 = new Vector3 (-10,  50,  20);

            Vector3 test1; Vector3.Transform (ref position, ref quatmati, out test1);
            Vector3 test2; Vector3.Transform (ref position, ref quatmatx, out test2);
            Vector3 test3; Vector3.Transform (ref position, ref quatmaty, out test3);
            Vector3 test4; Vector3.Transform (ref position, ref quatmatz, out test4);
            Vector3 test5; Vector3.Transform (ref position, ref quatmatxyz, out test5);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
            AssertEqualWithinReason(test5, expected5);
        }

        // Test Operator: Equality //-----------------------------------------//

        /// <summary>
        /// Helper method for testing equality.
        /// </summary>
        void TestEquality (Vector3 a, Vector3 b, Boolean expected )
        {
            // This test asserts the following:
            //   (a == b) == expected
            //   (b == a) == expected
            //   (a != b) == !expected
            //   (b != a) == !expected

            Boolean result_1a = (a == b);
            Boolean result_1b = (a.Equals(b));
            Boolean result_1c = (a.Equals((Object)b));
            
            Boolean result_2a = (b == a);
            Boolean result_2b = (b.Equals(a));
            Boolean result_2c = (b.Equals((Object)a));

            Boolean result_3a = (a != b);
            Boolean result_4a = (b != a);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_1c, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
            Assert.That(result_2c, Is.EqualTo(expected));
            Assert.That(result_3a, Is.EqualTo(!expected));
            Assert.That(result_4a, Is.EqualTo(!expected));
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of TRUE when two equal  
        /// Vector3 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_i ()
        {
            var a = new Vector3(44, -54, -22);
            var b = new Vector3(44, -54, -22);

            Boolean expected = true;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of FALSE when two unequal  
        /// Vector3 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_ii ()
        {
            var a = new Vector3(44, 54, 2);
            var b = new Vector3(44, -54, 2);

            Boolean expected = false;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Tests to make sure that all the equality opperators and functions 
        /// yield the expected result of TRUE when used on a number of randomly 
        /// generated pairs of equal Vector3 objects.
        /// </summary>
        [Test]
        public void TestOperator_Equality_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();

                Vector3 b = a;

                this.TestEquality(a, b, true);
            }
        }


        // Test Operator: Addition //-----------------------------------------//

        /// <summary>
        /// Helper method for testing addition.
        /// </summary>
        void TestAddition (Vector3 a, Vector3 b, Vector3 expected )
        {
            // This test asserts the following:
            //   a + b == expected
            //   b + a == expected

            var result_1a = a + b;
            var result_2a = b + a;

            Vector3 result_1b; Vector3.Add(ref a, ref b, out result_1b);
            Vector3 result_2b; Vector3.Add(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the addition opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_i ()
        {
            var a = new Vector3(3, -6, 44);
            var b = new Vector3(-6, 12, 18);

            var expected = new Vector3(-3, 6, 62);

            this.TestAddition(a, b, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving the zero vector, all the 
        /// addition opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_ii ()
        {
            var a = new Vector3(-2313, 88, 199);

            var expected = a;

            this.TestAddition(a, Vector3.Zero, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving two zero vectors, all the 
        /// addition opperators and functions yield the correct result of zero.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iii ()
        {
            this.TestAddition(Vector3.Zero, Vector3.Zero, Vector3.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// addition opperators and functions yield the same results as a
        /// manual addition calculation.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();
                var b = GetNextRandomVector3();

                var expected = new Vector3(
                    a.X + b.X, a.Y + b.Y, a.Z + b.Z);

                this.TestAddition(a, b, expected);
            }
        }

        // Test Operator: Subtraction //--------------------------------------//
        
        /// <summary>
        /// Helper method for testing subtraction.
        /// </summary>
        void TestSubtraction (Vector3 a, Vector3 b, Vector3 expected )
        {
            // This test asserts the following:
            //   a - b == expected
            //   b - a == -expected

            var result_1a = a - b;
            var result_2a = b - a;

            Vector3 result_1b; Vector3.Subtract(ref a, ref b, out result_1b);
            Vector3 result_2b; Vector3.Subtract(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(-expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(-expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the subtraction opperators
        /// and functions yield the correct result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_i ()
        {
            var a = new Vector3(12, -4, 14);
            var b = new Vector3(15, 11, 7);
            var expected = new Vector3(-3, -15, 7);
            this.TestSubtraction(a, b, expected);

            var c = new Vector3(-423, 342, 7);
            this.TestSubtraction(c, Vector3.Zero, c);
        }

        /// <summary>
        /// Assert that when subtracting the zero vector fromt the zero vector, 
        /// all the subtraction opperators and functions yield the correct 
        /// result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_ii ()
        {
            this.TestSubtraction(Vector3.Zero, Vector3.Zero, Vector3.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// subtraction opperators and functions yield the same results as a
        /// manual subtraction calculation.
        /// </summary>
        [Test]
        public void TestOperator_Subtraction_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();
                var b = GetNextRandomVector3();

                var expected = new Vector3(a.X - b.X, a.Y - b.Y, a.Z - b.Z);

                this.TestSubtraction(a, b, expected);
            }
        }

        // Test Operator: Negation //-----------------------------------------//
        
        /// <summary>
        /// Helper method for testing negation.
        /// </summary>
        void TestNegation (Vector3 a, Vector3 expected )
        {
            // This test asserts the following:
            //   -a == expected

            var result_1a = -a;

            Vector3 result_1b; Vector3.Negate(ref a, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the negation opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_i ()
        {
            Single r = 3432;
            Single s = -6218;
            Single t = -3432;
            Single u = 6218;

            var a = new Vector3(r, s, t);
            var b = new Vector3(u, t, s);
            var c = new Vector3(t, u, r);
            var d = new Vector3(s, r, u);

            this.TestNegation(a, c);
            this.TestNegation(b, d);
        }

        /// <summary>
        /// Assert that, for known examples involving the zero vector, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_ii ()
        {
            Single t = -3432;
            Single u = 6218;
            Single r = 3432;
            Single s = -6218;

            var c = new Vector3(t, u, r);
            var d = new Vector3(s, r, u);

            this.TestNegation(c, Vector3.Zero - c);
            this.TestNegation(d, Vector3.Zero - d);
        }

        /// <summary>
        /// Assert that when negating the zero vector, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iii ()
        {
            this.TestNegation(Vector3.Zero, Vector3.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// negation opperators and functions yield the same results as a
        /// manual negation calculation.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();
                this.TestNegation(a, Vector3.Zero - a);
            }
        }

        // Test Operator: Multiplication //-----------------------------------//

        /// <summary>
        /// Helper method for testing multiplication.
        /// </summary>
        void TestMultiplication (Vector3 a, Vector3 b, Vector3 expected )
        {
            // This test asserts the following:
            //   a * b == expected
            //   b * a == expected

            var result_1a = a * b;
            var result_2a = b * a;

            Vector3 result_1b; Vector3.Multiply(ref a, ref b, out result_1b);
            Vector3 result_2b; Vector3.Multiply(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the multiplication opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_i ()
        {
            Single r = -27;
            Single s = 36;
            Single t = 9;

            Single x = 3;
            Single y = 6;
            Single z = -9;

            var a = new Vector3(x, y, x);
            var b = new Vector3(z, y, x);
            var c = new Vector3(r, s, t);

            this.TestMultiplication(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// multiplication opperators and functions yield the same results as a
        /// manual multiplication calculation.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();
                var b = GetNextRandomVector3();

                var c = new Vector3(a.X * b.X, a.Y * b.Y, a.Z * b.Z);

                this.TestMultiplication(a, b, c);
            }
        }


        // Test Operator: Division //-----------------------------------------//

        /// <summary>
        /// Helper method for testing division.
        /// </summary>
        void TestDivision (Vector3 a, Vector3 b, Vector3 expected )
        {
            // This test asserts the following:
            //   a / b == expected

            var result_1a = a / b;

            Vector3 result_1b; Vector3.Divide(ref a, ref b, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example using whole numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_i ()
        {
            Single r = 10;
            Single s = -40;
            Single t = 1;

            Single x = 2000;
            Single y = 200;
            Single z = -5;

            var a = new Vector3(x, y, x);
            var b = new Vector3(y, z, x);
            var c = new Vector3(r, s, t);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a known example using fractional numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_ii ()
        {
            Single t = ((Single) 1 ) / ((Single) 10);
            Single u = ((Single) (-1) ) / ((Single) 40 );
            Single v = -20;
            Single w = 100;
            Single x = 2000;
            Single y = 200;
            Single z = -5;

            var a = new Vector3(y, z, w);
            var b = new Vector3(x, y, z);
            var c = new Vector3(t, u, v);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// division opperators and functions yield the same results as a
        /// manual addition division.
        /// </summary>
        [Test]
        public void TestOperator_Division_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();
                var b = GetNextRandomVector3();

                var c = new Vector3(a.X / b.X, a.Y / b.Y, a.Z / b.Z);

                this.TestDivision(a, b, c);
            }
        }

        // Test Static Fn: SmoothStep //--------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();
                var b = GetNextRandomVector3();

                Single amount1 = 0;
                Vector3 result1;

                Vector3.SmoothStep (
                    ref a, ref b, amount1, out result1);

                AssertEqualWithinReason(result1, a);

                Single amount2 = 1;
                Vector3 result2;

                Vector3.SmoothStep (
                    ref a, ref b, amount2, out result2);

                AssertEqualWithinReason(result2, b);
            }
        }

        /// <summary>
        /// Assert that, for known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_ii ()
        {
            var a = GetNextRandomVector3();
            var b = GetNextRandomVector3();

            Single half; RealMaths.Half(out half);

            var tests = new Single[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector3 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector3.SmoothStep (
                            ref a, ref b, amount, out result)
                    );
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_iii ()
        {
            var a = new Vector3( -30, -30, -30 );
            var b = new Vector3( +30, +30, +30 );

            Single one = 1;

            Single i;
            RealMaths.FromFraction(1755, 64, out i); // 27.421875
            
            Single j;
            RealMaths.FromFraction( 165,  8, out j); // 20.625
            
            Single k;
            RealMaths.FromFraction( 705, 64, out k); // 11.015625

            Single a0 = 0;
            Single a1 = (one * 1) / 8;
            Single a2 = (one * 2) / 8;
            Single a3 = (one * 3) / 8;
            Single a4 = (one * 4) / 8;
            Single a5 = (one * 5) / 8;
            Single a6 = (one * 6) / 8;
            Single a7 = (one * 7) / 8;
            Single a8 = 1;

            Vector3 r0 = a;
            Vector3 r1 = new Vector3( -i, -i, -i );
            Vector3 r2 = new Vector3( -j, -j, -j );
            Vector3 r3 = new Vector3( -k, -k, -k );
            Vector3 r4 = Vector3.Zero;
            Vector3 r5 = new Vector3(  k,  k,  k );
            Vector3 r6 = new Vector3(  j,  j,  j );
            Vector3 r7 = new Vector3(  i,  i,  i );
            Vector3 r8 = b;

            var knownResults = new List<Tuple<Single, Vector3>>
            {
                new Tuple<Single, Vector3>( a0, r0 ),
                new Tuple<Single, Vector3>( a1, r1 ),
                new Tuple<Single, Vector3>( a2, r2 ),
                new Tuple<Single, Vector3>( a3, r3 ),
                new Tuple<Single, Vector3>( a4, r4 ),
                new Tuple<Single, Vector3>( a5, r5 ),
                new Tuple<Single, Vector3>( a6, r6 ),
                new Tuple<Single, Vector3>( a7, r7 ),
                new Tuple<Single, Vector3>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector3 result;

                Vector3.SmoothStep (
                    ref a, ref b, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        // Test Static Fn: CatmullRom //--------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();
                var b = GetNextRandomVector3();
                var c = GetNextRandomVector3();
                var d = GetNextRandomVector3();

                Single amount1 = 0;
                Vector3 result1;

                Vector3.CatmullRom (
                    ref a, ref b, ref c, ref d, amount1, out result1);

                AssertEqualWithinReason(result1, b);

                Single amount2 = 1;
                Vector3 result2;

                Vector3.CatmullRom (
                    ref a, ref b, ref c, ref d, amount2, out result2);

                AssertEqualWithinReason(result2, c);
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_ii ()
        {
            var a = new Vector3( -90, +30, +90 );
            var b = new Vector3( -30, -30, +30 );
            var c = new Vector3( +30, +30, -30 );
            var d = new Vector3( +90, -30, -90 );

            Single one = 1;

            Single u = 15;
            Single v = (Single) 165  / (Single)  8; // 20.5
            Single w = (Single) 45   / (Single)  2; // 20.625
            Single x = (Single) 1755 / (Single) 64; // 27.421875
            Single y = (Single) 15   / (Single)  2; // 14.5
            Single z = (Single) 705  / (Single) 64; // 11.015625

            Single a0 = 0;
            Single a1 = (one * 1) / 8;
            Single a2 = (one * 2) / 8;
            Single a3 = (one * 3) / 8;
            Single a4 = (one * 4) / 8;
            Single a5 = (one * 5) / 8;
            Single a6 = (one * 6) / 8;
            Single a7 = (one * 7) / 8;
            Single a8 = 1;

            Vector3 r0 = b;
            Vector3 r1 = new Vector3( -w, -x,  w );
            Vector3 r2 = new Vector3( -u, -v,  u );
            Vector3 r3 = new Vector3( -y, -z,  y );
            Vector3 r4 = Vector3.Zero;
            Vector3 r5 = new Vector3(  y,  z, -y );
            Vector3 r6 = new Vector3(  u,  v, -u );
            Vector3 r7 = new Vector3(  w,  x, -w );
            Vector3 r8 = c;

            var knownResults = new List<Tuple<Single, Vector3>>
            {
                new Tuple<Single, Vector3>( a0, r0 ),
                new Tuple<Single, Vector3>( a1, r1 ),
                new Tuple<Single, Vector3>( a2, r2 ),
                new Tuple<Single, Vector3>( a3, r3 ),
                new Tuple<Single, Vector3>( a4, r4 ),
                new Tuple<Single, Vector3>( a5, r5 ),
                new Tuple<Single, Vector3>( a6, r6 ),
                new Tuple<Single, Vector3>( a7, r7 ),
                new Tuple<Single, Vector3>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector3 result;

                Vector3.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_iii ()
        {
            var a = GetNextRandomVector3();
            var b = GetNextRandomVector3();
            var c = GetNextRandomVector3();
            var d = GetNextRandomVector3();
            
            Single half; RealMaths.Half(out half);

            var tests = new Single[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector3 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector3.CatmullRom (
                            ref a, ref b, ref c, ref d, amount, out result)
                );
            }
        }

        /// <summary>
        /// This tests compares results against an example where all the control
        /// points are in a straight line.  In this case the resulting spline
        /// should be a straight line.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_iv ()
        {
            var a = new Vector3( -90, -90, +90 );
            var b = new Vector3( -30, -30, +30 );
            var c = new Vector3( +30, +30, -30 );
            var d = new Vector3( +90, +90, -90 );

            Single one = 1;

            Single a0 = 0;
            Single a1 = (one * 1) / 4;
            Single a2 = (one * 2) / 4;
            Single a3 = (one * 3) / 4;
            Single a4 = 1;

            Vector3 r0 = b;
            Vector3 r1 = new Vector3( -15, -15,  15 );
            Vector3 r2 = Vector3.Zero;
            Vector3 r3 = new Vector3(  15,  15, -15 );
            Vector3 r4 = c;

            var knownResults = new List<Tuple<Single, Vector3>>
            {
                new Tuple<Single, Vector3>( a0, r0 ),
                new Tuple<Single, Vector3>( a1, r1 ),
                new Tuple<Single, Vector3>( a2, r2 ),
                new Tuple<Single, Vector3>( a3, r3 ),
                new Tuple<Single, Vector3>( a4, r4 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector3 result;

                Vector3.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        // Test Static Fn: Hermite //-----------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a  = GetNextRandomVector3();
                var b  = GetNextRandomVector3();

                var c = GetNextRandomVector3();
                var d = GetNextRandomVector3();

                Vector3 an; Vector3.Normalise(ref c, out an);
                Vector3 bn; Vector3.Normalise(ref d, out bn);

                Single amount1 = 0;
                Vector3 result1;

                Vector3.Hermite (
                    ref a, ref an, ref b, ref bn, amount1, out result1);

                AssertEqualWithinReason(result1, a);

                Single amount2 = 1;
                Vector3 result2;

                Vector3.Hermite (
                    ref a, ref an, ref b, ref bn, amount2, out result2);

                AssertEqualWithinReason(result2, b);
            }
        }

        /// <summary>
        /// Assert that, for known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_ii ()
        {
            var a = GetNextRandomVector3();
            var b = GetNextRandomVector3();
            var c = GetNextRandomVector3();
            var d = GetNextRandomVector3();

            Vector3 an; Vector3.Normalise(ref c, out an);
            Vector3 bn; Vector3.Normalise(ref d, out bn);

            Single half; RealMaths.Half(out half);

            var tests = new Single[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector3 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector3.Hermite (
                            ref a, ref an, ref b, ref bn, amount, out result)
                    );
                
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_iii ()
        {
            var a = new Vector3( -100, +50, +100 );
            var b = new Vector3( +100, -50, -100 );

            var c = new Vector3( -10, +5, +10 );
            var d = new Vector3( +10, -5, -10 );

            Vector3 an; Vector3.Normalise(ref c, out an);
            Vector3 bn; Vector3.Normalise(ref d, out bn);

            Single one = 1;
            
            // 100.1953125
            Single e = (Single) 51300 / (Single) 512;

            // 50.09765625
            Single f = (Single) 12825 / (Single) 256;

            // 91.25
            Single g = (Single) 365 / (Single) 4;

            // 45.625
            Single h = (Single) 365 / (Single) 8;

            // 75.7421875
            Single i = (Single) 9695 / (Single) 128;

            // 37.87109375
            Single j = (Single) 9695 / (Single) 256;

            // 56.25
            Single k = (Single) 225 / (Single) 4;

            // 28.125
            Single l = (Single) 225 / (Single) 8;

            // 35.3515625
            Single m = (Single) 4525 / (Single) 128;

            // 17.67578125
            Single n = (Single) 4525 / (Single) 256;

            // 15.625
            Single o = (Single) 125 / (Single) 8;

            // 7.8125
            Single p = (Single) 125 / (Single) 16;

            // 0.3515625
            Single q = (Single) 45 / (Single) 128;

            // 0.17578125
            Single r = (Single) 45 / (Single) 256;

            Single a0 = 0;
            Single a1 = (one * 1) / 8;
            Single a2 = (one * 2) / 8;
            Single a3 = (one * 3) / 8;
            Single a4 = (one * 4) / 8;
            Single a5 = (one * 5) / 8;
            Single a6 = (one * 6) / 8;
            Single a7 = (one * 7) / 8;
            Single a8 = 1;

            Vector3 r0 = b;
            Vector3 r1 = new Vector3(  e, -f, -e );
            Vector3 r2 = new Vector3(  g, -h, -g );
            Vector3 r3 = new Vector3(  i, -j, -i );
            Vector3 r4 = new Vector3(  k, -l, -k );
            Vector3 r5 = new Vector3(  m, -n, -m );
            Vector3 r6 = new Vector3(  o, -p, -o );
            Vector3 r7 = new Vector3( -q,  r,  q );
            Vector3 r8 = c;

            var knownResults = new List<Tuple<Single, Vector3>>
            {
                new Tuple<Single, Vector3>( a0, r0 ),
                new Tuple<Single, Vector3>( a1, r1 ),
                new Tuple<Single, Vector3>( a2, r2 ),
                new Tuple<Single, Vector3>( a3, r3 ),
                new Tuple<Single, Vector3>( a4, r4 ),
                new Tuple<Single, Vector3>( a5, r5 ),
                new Tuple<Single, Vector3>( a6, r6 ),
                new Tuple<Single, Vector3>( a7, r7 ),
                new Tuple<Single, Vector3>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector3 result;

                Vector3.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

                /// <summary>
        /// Assert that, running the Min function on a number of randomly
        /// generated pairs of Vector3 objects, yields the same results as those
        /// obtained from performing a manual Min calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Min ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector3 a = GetNextRandomVector3();
                Vector3 b = a * 2;

                Vector3 result;
                Vector3.Min (ref a, ref b, out result);

                Assert.That(result.X, Is.EqualTo(a.X < b.X ? a.X : b.X ));
                Assert.That(result.Y, Is.EqualTo(a.Y < b.Y ? a.Y : b.Y ));
                Assert.That(result.Z, Is.EqualTo(a.Z < b.Z ? a.Z : b.Z ));
            }
        }

        /// <summary>
        /// Assert that, running the Max function on a number of randomly
        /// generated pairs of Vector3 objects, yields the same results as those
        /// obtained from performing a manual Max calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Max ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector3 a = GetNextRandomVector3();
                Vector3 b = GetNextRandomVector3();

                Vector3 result;
                Vector3.Max (ref a, ref b, out result);

                Assert.That(result.X, Is.EqualTo(a.X > b.X ? a.X : b.X ));
                Assert.That(result.Y, Is.EqualTo(a.Y > b.Y ? a.Y : b.Y ));
                Assert.That(result.Z, Is.EqualTo(a.Z > b.Z ? a.Z : b.Z ));
            }
        }

        /// <summary>
        /// Assert that, running the Clamp function on a number of randomly
        /// generated Vector3 objects for a given min-max range, yields
        /// results that fall within that range.
        /// </summary>
        [Test]
        public void TestStaticFn_Clamp_i ()
        {
            Vector3 min = new Vector3(-30, 1, 18);
            Vector3 max = new Vector3(32, 130, 47);

            for(Int32 i = 0; i < 100; ++i)
            {
                Vector3 a = GetNextRandomVector3();

                Vector3 result;
                Vector3.Clamp (ref a, ref min, ref max, out result);

                Assert.That(result.X, Is.LessThanOrEqualTo(max.X));
                Assert.That(result.Y, Is.LessThanOrEqualTo(max.Y));
                Assert.That(result.X, Is.GreaterThanOrEqualTo(min.X));
                Assert.That(result.Y, Is.GreaterThanOrEqualTo(min.Y));
            }
        }

        /// <summary>
        /// Assert that, running the Clamp function on an a Vector3 object known
        /// to fall outside of a given min-max range, yields a result that fall 
        /// within that range.
        /// </summary>
        [Test]
        public void TestStaticFn_Clamp_ii ()
        {
            Vector3 min = new Vector3(-30, 1, 18);
            Vector3 max = new Vector3(32, 130, 47);

            Vector3 a = new Vector3(-100, 1113, 50);

            Vector3 expected = new Vector3(-30, 130, 47);

            Vector3 result;
            Vector3.Clamp (ref a, ref min, ref max, out result);

            Assert.That(result.X, Is.LessThanOrEqualTo(max.X));
            Assert.That(result.Y, Is.LessThanOrEqualTo(max.Y));
            Assert.That(result.Z, Is.LessThanOrEqualTo(max.Z));
            Assert.That(result.X, Is.GreaterThanOrEqualTo(min.X));
            Assert.That(result.Y, Is.GreaterThanOrEqualTo(min.Y));
            Assert.That(result.Z, Is.GreaterThanOrEqualTo(min.Z));

            AssertEqualWithinReason(result, expected);

        }

        /// <summary>
        /// Assert that, running the Lerp function on a number of randomly
        /// generated pairs of Vector3 objects for a range of weighting amounts, 
        /// yields the same results as those obtained from performing a manual 
        /// Lerp calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_i ()
        {
            for(Int32 j = 0; j < 100; ++j)
            {
                Single delta = j;

                delta = delta / 100;

                for(Int32 i = 0; i < 100; ++i)
                {
                    Vector3 a = GetNextRandomVector3();
                    Vector3 b = GetNextRandomVector3();

                    Vector3 result;
                    Vector3.Lerp (ref a, ref b, delta, out result);

                    Vector3 expected = a + ( ( b - a ) * delta );

                    AssertEqualWithinReason(result, expected);
                }
            }
        }

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_ii ()
        {
            Vector3 a = GetNextRandomVector3();
            Vector3 b = GetNextRandomVector3();

            Single half; RealMaths.Half(out half);

            var tests = new Single[] { 2, half + 1, -half, -1 };

            foreach( var weighting in tests )
            {
                Vector3 result; 
                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector3.Lerp (
                            ref a, ref b, weighting, out result)
                    );
            }
        }


    }    /// <summary>
    /// 
    /// </summary>
    [TestFixture]
    public class Vector4Tests
    {
        /// <summary>
        /// The random number generator used for testing.
        /// </summary>
        static readonly System.Random rand;

        /// <summary>
        /// Static constructor used to ensure that the random number generator
        /// always gets initilised with the same seed, making the tests
        /// behave in a deterministic manner.
        /// </summary>
        static Vector4Tests ()
        {
            rand = new System.Random(0);
        }

        /// <summary>
        /// Helper function for getting the next random Single value.
        /// </summary>
        static Single GetNextRandomSingle ()
        {
            Single randomValue = rand.NextSingle();

            Single zero = 0;
            Single multiplier = 1000;

            randomValue *= multiplier;

            Boolean randomBoolean = (rand.Next(0, 1) == 0) ? true : false;

            if( randomBoolean )
                randomValue = zero - randomValue;

            return randomValue;
        }

        /// <summary>
        /// Helper function for getting the next random Vector4.
        /// </summary>
        static Vector4 GetNextRandomVector4 ()
        {
            Single a = GetNextRandomSingle();
            Single b = GetNextRandomSingle();
            Single c = GetNextRandomSingle();
            Single d = GetNextRandomSingle();

            return new Vector4(a, b, c, d);
        }

        /// <summary>
        /// Helper to encapsulate asserting that two Vector4s are equal.
        /// </summary>
        static void AssertEqualWithinReason (Vector4 a, Vector4 b)
        {
            Single tolerance; RealMaths.TestTolerance(out tolerance);

            Assert.That(a.X, Is.EqualTo(b.X).Within(tolerance));
            Assert.That(a.Y, Is.EqualTo(b.Y).Within(tolerance));
            Assert.That(a.Z, Is.EqualTo(b.Z).Within(tolerance));
            Assert.That(a.W, Is.EqualTo(b.W).Within(tolerance));
        }
        

        // Test: StructLayout //----------------------------------------------//

        /// <summary>
        /// This test makes sure that the struct layout has been defined
        /// correctly.
        /// </summary>
        [Test]
        public void Test_StructLayout_i ()
        {
            Type t = typeof(Vector4);

            Assert.That(
                t.StructLayoutAttribute.Value, 
                Is.EqualTo(LayoutKind.Sequential));
        }

        /// <summary>
        /// This test makes sure that when examining the memory addresses of the 
        /// X, Y, Z and W member variables of a number of randomly generated 
        /// Vector4 objects the results are as expected. 
        /// </summary>
        [Test]
        public unsafe void Test_StructLayout_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector4 vec = GetNextRandomVector4();

                GCHandle h_vec = GCHandle.Alloc(vec, GCHandleType.Pinned);

                IntPtr vecAddress = h_vec.AddrOfPinnedObject();

                Single[] data = new Single[4];

                // nb: when Fixed32 and Half are moved back into the main
                //     dev branch there will be need for an extension method for
                //     Marshal that will perform the copy for those types. 
                MarshalHelper.Copy(vecAddress, data, 0, 4);
                Assert.That(data[0], Is.EqualTo(vec.X));
                Assert.That(data[1], Is.EqualTo(vec.Y));
                Assert.That(data[2], Is.EqualTo(vec.Z));
                Assert.That(data[3], Is.EqualTo(vec.W));
                
                h_vec.Free();
            }
        }

        // Test: Constructors //----------------------------------------------//

        /// <summary>
        /// This test goes though each public constuctor and ensures that the 
        /// data members of the structure have been properly set.
        /// </summary>
        [Test]
        public void Test_Constructors_i ()
        {
            {
                // Test default values
                Vector4 a = new Vector4();
                Assert.That(a, Is.EqualTo(Vector4.Zero));
            }
            {
                // Test Vector4( Single, Single, Single )
                Single a = -189;
                Single b = 429;
                Single c = 4298;
                Single d = 341;
                Vector4 e = new Vector4(a, b, c, d);
                Assert.That(e.X, Is.EqualTo(a));
                Assert.That(e.Y, Is.EqualTo(b));
                Assert.That(e.Z, Is.EqualTo(c));
                Assert.That(e.W, Is.EqualTo(d));
            }
            {
                // Test Vector4( Vector2, Single, Single )
                Vector2 a = new Vector2(-189, 429);
                Single b = 4298;
                Single c = 341;
                Vector4 d = new Vector4(a, b, c);
                Assert.That(d.X, Is.EqualTo(a.X));
                Assert.That(d.Y, Is.EqualTo(a.Y));
                Assert.That(d.Z, Is.EqualTo(b));
                Assert.That(d.W, Is.EqualTo(c));
            }
            {
                // Test Vector4( Vector3, Single )
                Vector3 a = new Vector3(-189, 429, 4298);
                Single b = 341;
                Vector4 c = new Vector4(a, b);
                Assert.That(c.X, Is.EqualTo(a.X));
                Assert.That(c.Y, Is.EqualTo(a.Y));
                Assert.That(c.Z, Is.EqualTo(a.Z));
                Assert.That(c.W, Is.EqualTo(b));
            }
            {
                // Test no constructor
                Vector4 a;
                a.X = 0;
                a.Y = 0;
                a.Z = 0;
                a.W = 0;
                Assert.That(a, Is.EqualTo(Vector4.Zero));
            }
        }

        // Test Member Fn: ToString //----------------------------------------//

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i ()
        {
            Vector4 a = new Vector4(42, -17, 13, 44);

            String result = a.ToString();

            String expected = "{X:42 Y:-17 Z:13 W:44}";

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: GetHashCode //-------------------------------------//

        /// <summary>
        /// Makes sure that the hashing function is good by testing 10,000
        /// random scenarios and ensuring that there are no more than 10
        /// collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            var hs1 = new System.Collections.Generic.HashSet<Vector4>();
            var hs2 = new System.Collections.Generic.HashSet<Int32>();

            for(Int32 i = 0; i < 10000; ++i)
            {
                var a = GetNextRandomVector4();

                hs1.Add(a);
                hs2.Add(a.GetHashCode());
            }

            Assert.That(hs1.Count, Is.EqualTo(hs2.Count).Within(10));
        }

        // Test Member Fn: Length //------------------------------------------//

        /// <summary>
        /// Tests that for a known example the Length member function yields
        /// the correct result.
        /// </summary>
        [Test]
        public void TestMemberFn_Length_i ()
        {
            Vector4 a = new Vector4(3, -4, 12, 84);

            Single expected = 85;

            Single result = a.Length();

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: LengthSquared //-----------------------------------//

        /// <summary>
        /// Tests that for a known example the LengthSquared member function 
        /// yields the correct result.
        /// </summary>
        [Test]
        public void TestMemberFn_LengthSquared_i ()
        {
            Vector4 a = new Vector4(3, -4, 12, 84);

            Single expected = 7225;

            Single result = a.LengthSquared();

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: IsUnit //------------------------------------------//

        /// <summary>
        /// Tests that for the simple vectors the IsUnit member function
        /// returns the correct result of TRUE.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_i ()
        {
            Vector4 a = new Vector4( 1,  0,  0,  0);
            Vector4 b = new Vector4(-1,  0,  0,  0);
            Vector4 c = new Vector4( 0,  1,  0,  0);
            Vector4 d = new Vector4( 0, -1,  0,  0);
            Vector4 e = new Vector4( 0,  0,  1,  0);
            Vector4 f = new Vector4( 0,  0, -1,  0);
            Vector4 g = new Vector4( 0,  0,  0,  1);
            Vector4 h = new Vector4( 0,  0,  0, -1);
            Vector4 i = new Vector4( 1,  1,  1,  1);
            Vector4 j = new Vector4( 0,  0,  0,  0);

            Assert.That(a.IsUnit(), Is.EqualTo(true));
            Assert.That(b.IsUnit(), Is.EqualTo(true));
            Assert.That(c.IsUnit(), Is.EqualTo(true));
            Assert.That(d.IsUnit(), Is.EqualTo(true));
            Assert.That(e.IsUnit(), Is.EqualTo(true));
            Assert.That(f.IsUnit(), Is.EqualTo(true));
            Assert.That(g.IsUnit(), Is.EqualTo(true));
            Assert.That(h.IsUnit(), Is.EqualTo(true));

            Assert.That(i.IsUnit(), Is.EqualTo(false));
            Assert.That(j.IsUnit(), Is.EqualTo(false));
        }

        /// <summary>
        /// This test makes sure that the IsUnit member function returns the 
        /// correct result of TRUE for a number of scenarios where the test 
        /// vector is both random and normalised.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector4 a = GetNextRandomVector4();

                Vector4 b; Vector4.Normalise(ref a, out b);

                Assert.That(b.IsUnit(), Is.EqualTo(true));
            }
        }

        /// <summary>
        /// This test ensures that the IsUnit member function correctly
        /// returns TRUE for a collection of vectors, all known to be of unit 
        /// length.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_iii ()
        {
            Single radius = 1;

            Single pi; RealMaths.Pi(out pi);

            for( Int32 i = 0; i <= 10; ++ i)
            {
                for( Int32 j = 0; j <= 10; ++ j)
                {
                    for( Int32 k = 0; k <= 10; ++ k)
                    {
                        Single theta = 2 * pi * i / 100;
                        Single phi = 2 * pi * j / 100;
                        Single gamma = 2 * pi * k / 100;

                        Single x = 
                            RealMaths.Cos(theta) * 
                            RealMaths.Sin(phi) * 
                            RealMaths.Sin(gamma) * radius;
                        
                        Single y = 
                            RealMaths.Sin(theta) * 
                            RealMaths.Sin(phi) * 
                            RealMaths.Sin(gamma) * radius;
                        
                        Single z = 
                            RealMaths.Cos(phi) * 
                            RealMaths.Sin(gamma) * radius;
                        
                        Single w = 
                            RealMaths.Cos(gamma) * radius;          

                        Assert.That(
                            new Vector4(x, y,  z, w).IsUnit(), 
                            Is.EqualTo(true));
                    }
                }
            }
        }

        /// <summary>
        /// This test makes sure that the IsUnit member function returns the 
        /// correct result of FALSE for a number of scenarios where the test 
        /// vector is randomly generated and not normalised.  It's highly
        /// unlikely that the random generator will create a unit vector!
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_iv ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector4 a = GetNextRandomVector4();

                Assert.That(a.IsUnit(), Is.EqualTo(false));
            }
        }
            
        // Test Constant: Zero //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector4 initilised using the Zero constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Zero_i ()
        {
            Vector4 result = Vector4.Zero;
            Vector4 expected = new Vector4(0, 0, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: One //----------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector4 initilised using the One constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_One_i ()
        {
            Vector4 result = Vector4.One;
            Vector4 expected = new Vector4(1, 1, 1, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitX //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector4 initilised using the UnitX 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitX_i ()
        {
            Vector4 result = Vector4.UnitX;
            Vector4 expected = new Vector4(1, 0, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitY //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector4 initilised using the UnitY
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitY_i ()
        {
            Vector4 result = Vector4.UnitY;
            Vector4 expected = new Vector4(0, 1, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitZ //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector4 initilised using the UnitZ 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitZ_i ()
        {
            Vector4 result = Vector4.UnitZ;
            Vector4 expected = new Vector4(0, 0, 1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitW //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector4 initilised using the UnitW
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitW_i ()
        {
            Vector4 result = Vector4.UnitW;
            Vector4 expected = new Vector4(0, 0, 0, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Static Fn: Distance //----------------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the Distance method
        /// yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_Distance_i ()
        {
            {
                Vector4 a = new Vector4(0, 4, 12, 0);
                Vector4 b = new Vector4(3, 0, 0, 84);

                Single expected = 85;
                Single result;

                Vector4.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector4 a = new Vector4(0, -4, 12, 0);
                Vector4 b = new Vector4(3, 0, 0, 84);

                Single expected = 85;
                Single result;

                Vector4.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector4 a = new Vector4(0, -4, -12, 0);
                Vector4 b = new Vector4(-3, 0, 0, -84);

                Single expected = 85;
                Single result;

                Vector4.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector4 a = Vector4.Zero;

                Single expected = 0;
                Single result;

                Vector4.Distance(ref a, ref a, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Distance method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Distance_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector4 a = GetNextRandomVector4();

                Single expected =
                    RealMaths.Sqrt((a.X * a.X) + (a.Y * a.Y) + (a.Z * a.Z) + (a.W * a.W));

                Assert.That(a.Length(), Is.EqualTo(expected));
            }
        }

        // Test Static Fn: DistanceSquared //---------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the DistanceSquared
        /// method yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_DistanceSquared_i ()
        {
            {
                Vector4 a = new Vector4(0, 4, 12, 0);
                Vector4 b = new Vector4(3, 0, 0, 84);

                Single expected = 7225;
                Single result;

                Vector4.DistanceSquared(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector4 a = Vector4.Zero;

                Single expected = 0;
                Single result;

                Vector4.DistanceSquared(ref a, ref a, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }


        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// DistanceSquared method yeilds the same results as those obtained
        /// from performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_DistanceSquared_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector4 a = GetNextRandomVector4();
                Vector4 b = GetNextRandomVector4();

                Vector4 c = b - a;

                Single expected = (c.X * c.X) + (c.Y * c.Y) + (c.Z * c.Z) + (c.W * c.W);
                Single result;

                Vector4.DistanceSquared(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        // Test Static Fn: Dot //---------------------------------------------//

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Dot method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector4 a = GetNextRandomVector4();
                Vector4 b = GetNextRandomVector4();

                Single expected = (a.X * b.X) + (a.Y * b.Y) + (a.Z * b.Z) + (a.W * b.W);
                Single result; Vector4.Dot(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        /// <summary>
        /// Assert that two unit vectors pointing in opposing directions yeild a
        /// dot product of negative one.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_ii ()
        {
            Vector4 a = new Vector4(0, 0, 0, 1);
            Vector4 b = new Vector4(0, 0, 0, -1);

            Single expected = -1;
            Single result; Vector4.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that two unit vectors pointing in the same direction yeild a
        /// dot product of one.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_iii ()
        {
            Vector4 a = new Vector4(0, 0, 0, 1);
            Vector4 b = new Vector4(0, 0, 0, 1);

            Single expected = 1;
            Single result; Vector4.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that two perpendicular unit vectors yeild a dot product of
        /// zero.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_iv ()
        {
            Vector4 a = new Vector4(0, 0, 1, 0);
            Vector4 b = new Vector4(0, 0, 0, 1);

            Single expected = 0;
            Single result; Vector4.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Static Fn: Normalise //---------------------------------------//

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_i()
        {
            {
                Vector4 a = Vector4.Zero;

                Vector4 b;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException),
                    () =>
                    Vector4.Normalise(ref a, out b)
                );
            }

            {
                Vector4 a = new Vector4(
                    Single.MaxValue,
                    Single.MaxValue,
                    Single.MaxValue,
                    Single.MaxValue);

                Vector4 b;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException),
                    () =>
                    Vector4.Normalise(ref a, out b)
                );
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Normalise method yeilds a unit vector (with length equal to one);
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_ii ()
        {
            Single epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector4 a = GetNextRandomVector4();

                Vector4 b; Vector4.Normalise(ref a, out b);
                Single expected = 1;
                Single result1 = b.Length();
                Assert.That(result1, Is.EqualTo(expected).Within(epsilon));

                // The normalise function takes both a ref and out parameter,
                // need to check that if we pass in the same value as both
                // parameters we get the same results.
                Vector4 c = a;
                Vector4.Normalise(ref c, out c);
                Single result2 = c.Length();
                Assert.That(result2, Is.EqualTo(expected).Within(epsilon));
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Normalise method yeilds a vector, which when multipled by the
        /// length of the original vector results in the same vector as the
        /// original vector;
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_iii ()
        {
            Single epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector4 a = GetNextRandomVector4();
                Single l = a.Length();
                Vector4 expected = a;

                Vector4 b; Vector4.Normalise(ref a, out b);
                Vector4 result1 = b * l;
                AssertEqualWithinReason(result1, expected);

                Vector4 c = a;

                // The normalise function takes both a ref and out parameter,
                // need to check that if we pass in the same value as both
                // parameters we get the same results.
                Vector4.Normalise(ref c, out c);
                Vector4 result2 = c * l;
                AssertEqualWithinReason(result2, expected);
            }
        }

        // Test Static Fn: TransformMatrix44 //-------------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformMatix44_i ()
        {
            Vector4 position = new Vector4 (-40, -20, 10, 20);

            Single pi; RealMaths.Pi (out pi);
            Single tau; RealMaths.Tau (out tau);

            Matrix44 rotmati = Matrix44.Identity;
            Matrix44 rotmatx; Matrix44.CreateRotationX(tau, out rotmatx);
            Matrix44 rotmaty; Matrix44.CreateRotationY(pi, out rotmaty);
            Matrix44 rotmatz; Matrix44.CreateRotationZ(-tau, out rotmatz);
            Matrix44 rotmatxyz = rotmatx * rotmaty * rotmatz;

            Vector4 expected1 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected2 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected3 = new Vector4 ( 40, -20, -10, 20);
            Vector4 expected4 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected5 = new Vector4 ( 40, -20, -10, 20);

            Vector4 test1; Vector4.Transform (ref position, ref rotmati, out test1);
            Vector4 test2; Vector4.Transform (ref position, ref rotmatx, out test2);
            Vector4 test3; Vector4.Transform (ref position, ref rotmaty, out test3);
            Vector4 test4; Vector4.Transform (ref position, ref rotmatz, out test4);
            Vector4 test5; Vector4.Transform (ref position, ref rotmatxyz, out test5);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
            AssertEqualWithinReason(test5, expected5);
        }

        // Test Static Fn: TransformNormal //---------------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformNormal_i ()
        {
            Vector4 position = new Vector4 (-40, -20, 10, 20);
            Vector4.Normalise (ref position, out position);

            Single pi; RealMaths.Pi (out pi);
            Single tau; RealMaths.Tau (out tau);

            Matrix44 rotmati = Matrix44.Identity;
            Matrix44 rotmatx; Matrix44.CreateRotationX(pi, out rotmatx);
            Matrix44 rotmaty; Matrix44.CreateRotationY(tau, out rotmaty);
            Matrix44 rotmatz; Matrix44.CreateRotationZ(-pi, out rotmatz);
            Matrix44 rotmatxyz = rotmatx * rotmaty * rotmatz;

            Vector4 expected1 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected2 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected3 = new Vector4 ( 40, -20, -10, 20);
            Vector4 expected4 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected5 = new Vector4 ( 40, -20, -10, 20);

            Vector4.Normalise (ref expected1, out expected1);
            Vector4.Normalise (ref expected2, out expected2);
            Vector4.Normalise (ref expected3, out expected3);
            Vector4.Normalise (ref expected4, out expected4);
            Vector4.Normalise (ref expected5, out expected5);

            Vector4 test1; Vector4.TransformNormal (ref position, ref rotmati, out test1);
            Vector4 test2; Vector4.TransformNormal (ref position, ref rotmatx, out test2);
            Vector4 test3; Vector4.TransformNormal (ref position, ref rotmaty, out test3);
            Vector4 test4; Vector4.TransformNormal (ref position, ref rotmatz, out test4);
            Vector4 test5; Vector4.TransformNormal (ref position, ref rotmatxyz, out test5);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
            AssertEqualWithinReason(test5, expected5);

            // should also work with the standard transform fn
            Vector4 test1n; Vector4.Transform (ref position, ref rotmati, out test1n);
            Vector4 test2n; Vector4.Transform (ref position, ref rotmatx, out test2n);
            Vector4 test3n; Vector4.Transform (ref position, ref rotmaty, out test3n);
            Vector4 test4n; Vector4.Transform (ref position, ref rotmatz, out test4n);
            Vector4 test5n; Vector4.Transform (ref position, ref rotmatxyz, out test5n);

            AssertEqualWithinReason(test1n, expected1);
            AssertEqualWithinReason(test2n, expected2);
            AssertEqualWithinReason(test3n, expected3);
            AssertEqualWithinReason(test4n, expected4);
            AssertEqualWithinReason(test5n, expected5);
        }

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformNormal_ii ()
        {
            Matrix44 rotmat = Matrix44.Identity;
            Vector4 normal = new Vector4 (21, -532, 0, 91);
            Vector4 result;
            Assert.Throws(
                typeof(ArgumentOutOfRangeException),
                () =>
                Vector4.TransformNormal(ref normal, ref rotmat, out result)
            );
        }

        // Test Static Fn: TransformQuaternion //-----------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformQuaternion_i ()
        {
            Vector4 position = new Vector4 (-40, -20, 10, 20);

            Single pi;
            RealMaths.Pi (out pi);

            Quaternion quatmati = new Quaternion (0, 0, 0, 1);
            Quaternion quatmatx = new Quaternion (0, 0, 0, 1);
            Quaternion quatmaty = new Quaternion (0, 1, 0, 0);
            Quaternion quatmatz = new Quaternion (0, 0, 0, 1);
            Quaternion quatmatxyz = new Quaternion (0, 1, 0, 0);

            Vector4 expected1 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected2 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected3 = new Vector4 ( 40, -20, -10, 20);
            Vector4 expected4 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected5 = new Vector4 ( 40, -20, -10, 20);

            Vector4 test1; Vector4.Transform (ref position, ref quatmati, out test1);
            Vector4 test2; Vector4.Transform (ref position, ref quatmatx, out test2);
            Vector4 test3; Vector4.Transform (ref position, ref quatmaty, out test3);
            Vector4 test4; Vector4.Transform (ref position, ref quatmatz, out test4);
            Vector4 test5; Vector4.Transform (ref position, ref quatmatxyz, out test5);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
            AssertEqualWithinReason(test5, expected5);
        }

        // Test Operator: Equality //-----------------------------------------//

        /// <summary>
        /// Helper method for testing equality.
        /// </summary>
        void TestEquality (Vector4 a, Vector4 b, Boolean expected )
        {
            // This test asserts the following:
            //   (a == b) == expected
            //   (b == a) == expected
            //   (a != b) == !expected
            //   (b != a) == !expected

            Boolean result_1a = (a == b);
            Boolean result_1b = (a.Equals(b));
            Boolean result_1c = (a.Equals((Object)b));
            
            Boolean result_2a = (b == a);
            Boolean result_2b = (b.Equals(a));
            Boolean result_2c = (b.Equals((Object)a));

            Boolean result_3a = (a != b);
            Boolean result_4a = (b != a);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_1c, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
            Assert.That(result_2c, Is.EqualTo(expected));
            Assert.That(result_3a, Is.EqualTo(!expected));
            Assert.That(result_4a, Is.EqualTo(!expected));
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of TRUE when two equal  
        /// Vector4 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_i ()
        {
            var a = new Vector4(44, -54, -22, 11);
            var b = new Vector4(44, -54, -22, 11);

            Boolean expected = true;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of FALSE when two unequal  
        /// Vector4 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_ii ()
        {
            var a = new Vector4(44, 54, 2, 11);
            var b = new Vector4(44, -54, 2, -1);

            Boolean expected = false;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Tests to make sure that all the equality opperators and functions 
        /// yield the expected result of TRUE when used on a number of randomly 
        /// generated pairs of equal Vector4 objects.
        /// </summary>
        [Test]
        public void TestOperator_Equality_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();

                Vector4 b = a;

                this.TestEquality(a, b, true);
            }
        }


        // Test Operator: Addition //-----------------------------------------//

        /// <summary>
        /// Helper method for testing addition.
        /// </summary>
        void TestAddition (Vector4 a, Vector4 b, Vector4 expected )
        {
            // This test asserts the following:
            //   a + b == expected
            //   b + a == expected

            var result_1a = a + b;
            var result_2a = b + a;

            Vector4 result_1b; Vector4.Add(ref a, ref b, out result_1b);
            Vector4 result_2b; Vector4.Add(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the addition opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_i ()
        {
            var a = new Vector4(3, -6, 44, 11);
            var b = new Vector4(-6, 12, 18, -3);

            var expected = new Vector4(-3, 6, 62, 8);

            this.TestAddition(a, b, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving the zero vector, all the 
        /// addition opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_ii ()
        {
            var a = new Vector4(-2313, 88, 199, 42);

            var expected = a;

            this.TestAddition(a, Vector4.Zero, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving two zero vectors, all the 
        /// addition opperators and functions yield the correct result of zero.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iii ()
        {
            this.TestAddition(Vector4.Zero, Vector4.Zero, Vector4.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// addition opperators and functions yield the same results as a
        /// manual addition calculation.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();
                var b = GetNextRandomVector4();

                var expected = new Vector4(
                    a.X + b.X, a.Y + b.Y, a.Z + b.Z, a.W + b.W);

                this.TestAddition(a, b, expected);
            }
        }

        // Test Operator: Subtraction //--------------------------------------//
        
        /// <summary>
        /// Helper method for testing subtraction.
        /// </summary>
        void TestSubtraction (Vector4 a, Vector4 b, Vector4 expected )
        {
            // This test asserts the following:
            //   a - b == expected
            //   b - a == -expected

            var result_1a = a - b;
            var result_2a = b - a;

            Vector4 result_1b; Vector4.Subtract(ref a, ref b, out result_1b);
            Vector4 result_2b; Vector4.Subtract(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(-expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(-expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the subtraction opperators
        /// and functions yield the correct result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_i ()
        {
            var a = new Vector4(12, -4, 14, 18);
            var b = new Vector4(15, 11, 7, 27);
            var expected = new Vector4(-3, -15, 7, -9);
            this.TestSubtraction(a, b, expected);

            var c = new Vector4(-423, 342, 7, -800);
            this.TestSubtraction(c, Vector4.Zero, c);
        }

        /// <summary>
        /// Assert that when subtracting the zero vector fromt the zero vector, 
        /// all the subtraction opperators and functions yield the correct 
        /// result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_ii ()
        {
            this.TestSubtraction(Vector4.Zero, Vector4.Zero, Vector4.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// subtraction opperators and functions yield the same results as a
        /// manual subtraction calculation.
        /// </summary>
        [Test]
        public void TestOperator_Subtraction_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();
                var b = GetNextRandomVector4();

                var expected = new Vector4(
                    a.X - b.X, a.Y - b.Y, a.Z - b.Z, a.W - b.W);

                this.TestSubtraction(a, b, expected);
            }
        }

        // Test Operator: Negation //-----------------------------------------//
        
        /// <summary>
        /// Helper method for testing negation.
        /// </summary>
        void TestNegation (Vector4 a, Vector4 expected )
        {
            // This test asserts the following:
            //   -a == expected

            var result_1a = -a;

            Vector4 result_1b; Vector4.Negate(ref a, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the negation opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_i ()
        {
            Single r = 3432;
            Single s = -6218;
            Single t = -3432;
            Single u = 6218;

            var a = new Vector4(r, s, t, u);
            var b = new Vector4(u, t, s, r);
            var c = new Vector4(t, u, r, s);
            var d = new Vector4(s, r, u, t);

            this.TestNegation(a, c);
            this.TestNegation(b, d);
        }

        /// <summary>
        /// Assert that, for known examples involving the zero vector, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_ii ()
        {
            Single t = -3432;
            Single u = 6218;
            Single r = 3432;
            Single s = -6218;

            var c = new Vector4(t, u, r, s);
            var d = new Vector4(s, r, u, t);

            this.TestNegation(c, Vector4.Zero - c);
            this.TestNegation(d, Vector4.Zero - d);
        }

        /// <summary>
        /// Assert that when negating the zero vector, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iii ()
        {
            this.TestNegation(Vector4.Zero, Vector4.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// negation opperators and functions yield the same results as a
        /// manual negation calculation.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();
                this.TestNegation(a, Vector4.Zero - a);
            }
        }

        // Test Operator: Multiplication //-----------------------------------//

        /// <summary>
        /// Helper method for testing multiplication.
        /// </summary>
        void TestMultiplication (Vector4 a, Vector4 b, Vector4 expected )
        {
            // This test asserts the following:
            //   a * b == expected
            //   b * a == expected

            var result_1a = a * b;
            var result_2a = b * a;

            Vector4 result_1b; Vector4.Multiply(ref a, ref b, out result_1b);
            Vector4 result_2b; Vector4.Multiply(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the multiplication opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_i ()
        {
            Single r = -27;
            Single s = 36;
            Single t = 9;
            Single u = -54;

            Single x = 3;
            Single y = 6;
            Single z = -9;

            var a = new Vector4(x, y, x, y);
            var b = new Vector4(z, y, x, z);
            var c = new Vector4(r, s, t, u);

            this.TestMultiplication(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// multiplication opperators and functions yield the same results as a
        /// manual multiplication calculation.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();
                var b = GetNextRandomVector4();

                var c = new Vector4(
                    a.X * b.X, a.Y * b.Y, a.Z * b.Z, a.W * b.W);

                this.TestMultiplication(a, b, c);
            }
        }


        // Test Operator: Division //-----------------------------------------//

        /// <summary>
        /// Helper method for testing division.
        /// </summary>
        void TestDivision (Vector4 a, Vector4 b, Vector4 expected )
        {
            // This test asserts the following:
            //   a / b == expected

            var result_1a = a / b;

            Vector4 result_1b; Vector4.Divide(ref a, ref b, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example using whole numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_i ()
        {
            Single r = 10;
            Single s = -40;
            Single t = 1;
            Single u = -400;

            Single x = 2000;
            Single y = 200;
            Single z = -5;

            var a = new Vector4(x, y, x, x);
            var b = new Vector4(y, z, x, z);
            var c = new Vector4(r, s, t, u);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a known example using fractional numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_ii ()
        {
            Single s = 4;
            Single t = ((Single) 1 ) / ((Single) 10);
            Single u = ((Single) (-1) ) / ((Single) 40 );
            Single v = -20;
            Single w = 100;
            Single x = 2000;
            Single y = 200;
            Single z = -5;

            var a = new Vector4(y, z, w, v);
            var b = new Vector4(x, y, z, z);
            var c = new Vector4(t, u, v, s);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// division opperators and functions yield the same results as a
        /// manual addition division.
        /// </summary>
        [Test]
        public void TestOperator_Division_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();
                var b = GetNextRandomVector4();

                var c = new Vector4(
                    a.X / b.X, a.Y / b.Y, a.Z / b.Z, a.W / b.W);

                this.TestDivision(a, b, c);
            }
        }

        // Test Static Fn: SmoothStep //--------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();
                var b = GetNextRandomVector4();

                Single amount1 = 0;
                Vector4 result1;

                Vector4.SmoothStep (
                    ref a, ref b, amount1, out result1);

                AssertEqualWithinReason(result1, a);

                Single amount2 = 1;
                Vector4 result2;

                Vector4.SmoothStep (
                    ref a, ref b, amount2, out result2);

                AssertEqualWithinReason(result2, b);
            }
        }

        /// <summary>
        /// Assert that, for known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_ii ()
        {
            var a = GetNextRandomVector4();
            var b = GetNextRandomVector4();

            Single half; RealMaths.Half(out half);

            var tests = new Single[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector4 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector4.SmoothStep (
                            ref a, ref b, amount, out result)
                    );
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_iii ()
        {
            var a = new Vector4( -30, -30, -30, -30 );
            var b = new Vector4( +30, +30, +30, +30 );

            Single one = 1;

            Single i;
            RealMaths.FromFraction(1755, 64, out i); // 27.421875
            
            Single j;
            RealMaths.FromFraction( 165,  8, out j); // 20.625
            
            Single k;
            RealMaths.FromFraction( 705, 64, out k); // 11.015625

            Single a0 = 0;
            Single a1 = (one * 1) / 8;
            Single a2 = (one * 2) / 8;
            Single a3 = (one * 3) / 8;
            Single a4 = (one * 4) / 8;
            Single a5 = (one * 5) / 8;
            Single a6 = (one * 6) / 8;
            Single a7 = (one * 7) / 8;
            Single a8 = 1;

            Vector4 r0 = a;
            Vector4 r1 = new Vector4( -i, -i, -i, -i );
            Vector4 r2 = new Vector4( -j, -j, -j, -j );
            Vector4 r3 = new Vector4( -k, -k, -k, -k );
            Vector4 r4 = Vector4.Zero;
            Vector4 r5 = new Vector4(  k,  k,  k,  k );
            Vector4 r6 = new Vector4(  j,  j,  j,  j );
            Vector4 r7 = new Vector4(  i,  i,  i,  i );
            Vector4 r8 = b;

            var knownResults = new List<Tuple<Single, Vector4>>
            {
                new Tuple<Single, Vector4>( a0, r0 ),
                new Tuple<Single, Vector4>( a1, r1 ),
                new Tuple<Single, Vector4>( a2, r2 ),
                new Tuple<Single, Vector4>( a3, r3 ),
                new Tuple<Single, Vector4>( a4, r4 ),
                new Tuple<Single, Vector4>( a5, r5 ),
                new Tuple<Single, Vector4>( a6, r6 ),
                new Tuple<Single, Vector4>( a7, r7 ),
                new Tuple<Single, Vector4>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector4 result;

                Vector4.SmoothStep (
                    ref a, ref b, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        // Test Static Fn: CatmullRom //--------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();
                var b = GetNextRandomVector4();
                var c = GetNextRandomVector4();
                var d = GetNextRandomVector4();

                Single amount1 = 0;
                Vector4 result1;

                Vector4.CatmullRom (
                    ref a, ref b, ref c, ref d, amount1, out result1);

                AssertEqualWithinReason(result1, b);

                Single amount2 = 1;
                Vector4 result2;

                Vector4.CatmullRom (
                    ref a, ref b, ref c, ref d, amount2, out result2);

                AssertEqualWithinReason(result2, c);
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_ii ()
        {
            var a = new Vector4( -90, +30, +90, -30 );
            var b = new Vector4( -30, -30, +30, +30 );
            var c = new Vector4( +30, +30, -30, -30 );
            var d = new Vector4( +90, -30, -90, -30 );

            Single one = 1;

            Single u = 15;
            Single v = (Single) 165  / (Single)  8; // 20.5
            Single w = (Single) 45   / (Single)  2; // 20.625
            Single x = (Single) 1755 / (Single) 64; // 27.421875
            Single y = (Single) 15   / (Single)  2; // 14.5
            Single z = (Single) 705  / (Single) 64; // 11.015625

            Single a0 = 0;
            Single a1 = (one * 1) / 8;
            Single a2 = (one * 2) / 8;
            Single a3 = (one * 3) / 8;
            Single a4 = (one * 4) / 8;
            Single a5 = (one * 5) / 8;
            Single a6 = (one * 6) / 8;
            Single a7 = (one * 7) / 8;
            Single a8 = 1;

            Vector4 r0 = b;
            Vector4 r1 = new Vector4( -w, -x,  w,  x );
            Vector4 r2 = new Vector4( -u, -v,  u,  v );
            Vector4 r3 = new Vector4( -y, -z,  y,  z );
            Vector4 r4 = Vector4.Zero;
            Vector4 r5 = new Vector4(  y,  z, -y, -z );
            Vector4 r6 = new Vector4(  u,  v, -u, -v );
            Vector4 r7 = new Vector4(  w,  x, -w, -x );
            Vector4 r8 = c;

            var knownResults = new List<Tuple<Single, Vector4>>
            {
                new Tuple<Single, Vector4>( a0, r0 ),
                new Tuple<Single, Vector4>( a1, r1 ),
                new Tuple<Single, Vector4>( a2, r2 ),
                new Tuple<Single, Vector4>( a3, r3 ),
                new Tuple<Single, Vector4>( a4, r4 ),
                new Tuple<Single, Vector4>( a5, r5 ),
                new Tuple<Single, Vector4>( a6, r6 ),
                new Tuple<Single, Vector4>( a7, r7 ),
                new Tuple<Single, Vector4>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector4 result;

                Vector4.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        /// <summary>
        /// Assert that, for known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_iii ()
        {
            var a = GetNextRandomVector4();
            var b = GetNextRandomVector4();
            var c = GetNextRandomVector4();
            var d = GetNextRandomVector4();
            
            Single half; RealMaths.Half(out half);

            var tests = new Single[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector4 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector4.CatmullRom (
                            ref a, ref b, ref c, ref d, amount, out result)
                );
            }
        }

        /// <summary>
        /// This tests compares results against an example where all the control
        /// points are in a straight line.  In this case the resulting spline
        /// should be a straight line.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_iv ()
        {
            var a = new Vector4( -90, +30, +90, -30 );
            var b = new Vector4( -30, -30, +30, +30 );
            var c = new Vector4( +30, +30, -30, -30 );
            var d = new Vector4( +90, -30, -90, -30 );

            Single one = 1;

            Single a0 = 0;
            Single a1 = (one * 1) / 4;
            Single a2 = (one * 2) / 4;
            Single a3 = (one * 3) / 4;
            Single a4 = 1;

            Vector4 r0 = b;
            Vector4 r1 = new Vector4( -15, -15,  15,  15 );
            Vector4 r2 = Vector4.Zero;
            Vector4 r3 = new Vector4(  15,  15, -15, -15 );
            Vector4 r4 = c;

            var knownResults = new List<Tuple<Single, Vector4>>
            {
                new Tuple<Single, Vector4>( a0, r0 ),
                new Tuple<Single, Vector4>( a1, r1 ),
                new Tuple<Single, Vector4>( a2, r2 ),
                new Tuple<Single, Vector4>( a3, r3 ),
                new Tuple<Single, Vector4>( a4, r4 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector4 result;

                Vector4.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        // Test Static Fn: Hermite //-----------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a  = GetNextRandomVector4();
                var b  = GetNextRandomVector4();

                var c = GetNextRandomVector4();
                var d = GetNextRandomVector4();

                Vector4 an; Vector4.Normalise(ref c, out an);
                Vector4 bn; Vector4.Normalise(ref d, out bn);

                Single amount1 = 0;
                Vector4 result1;

                Vector4.Hermite (
                    ref a, ref an, ref b, ref bn, amount1, out result1);

                AssertEqualWithinReason(result1, a);

                Single amount2 = 1;
                Vector4 result2;

                Vector4.Hermite (
                    ref a, ref an, ref b, ref bn, amount2, out result2);

                AssertEqualWithinReason(result2, b);
            }
        }

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_ii ()
        {
            var a = GetNextRandomVector4();
            var b = GetNextRandomVector4();
            var c = GetNextRandomVector4();
            var d = GetNextRandomVector4();

            Vector4 an; Vector4.Normalise(ref c, out an);
            Vector4 bn; Vector4.Normalise(ref d, out bn);

            Single half; RealMaths.Half(out half);

            var tests = new Single[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector4 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector4.Hermite (
                            ref a, ref an, ref b, ref bn, amount, out result)
                    );
                
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_iii ()
        {
            var a = new Vector4( -100, +50, +100, -50 );
            var b = new Vector4( +100, -50, -100, +50 );

            var c = new Vector4( -10, +5, +10, -5 );
            var d = new Vector4( +10, -5, -10, +5 );

            Vector4 an; Vector4.Normalise(ref c, out an);
            Vector4 bn; Vector4.Normalise(ref d, out bn);

            Single one = 1;
            
            // 100.1953125
            Single e = (Single) 51300 / (Single) 512;

            // 50.09765625
            Single f = (Single) 12825 / (Single) 256;

            // 91.25
            Single g = (Single) 365 / (Single) 4;

            // 45.625
            Single h = (Single) 365 / (Single) 8;

            // 75.7421875
            Single i = (Single) 9695 / (Single) 128;

            // 37.87109375
            Single j = (Single) 9695 / (Single) 256;

            // 56.25
            Single k = (Single) 225 / (Single) 4;

            // 28.125
            Single l = (Single) 225 / (Single) 8;

            // 35.3515625
            Single m = (Single) 4525 / (Single) 128;

            // 17.67578125
            Single n = (Single) 4525 / (Single) 256;

            // 15.625
            Single o = (Single) 125 / (Single) 8;

            // 7.8125
            Single p = (Single) 125 / (Single) 16;

            // 0.3515625
            Single q = (Single) 45 / (Single) 128;

            // 0.17578125
            Single r = (Single) 45 / (Single) 256;

            Single a0 = 0;
            Single a1 = (one * 1) / 8;
            Single a2 = (one * 2) / 8;
            Single a3 = (one * 3) / 8;
            Single a4 = (one * 4) / 8;
            Single a5 = (one * 5) / 8;
            Single a6 = (one * 6) / 8;
            Single a7 = (one * 7) / 8;
            Single a8 = 1;

            Vector4 r0 = b;
            Vector4 r1 = new Vector4(  e, -f, -e,  f );
            Vector4 r2 = new Vector4(  g, -h, -g,  h );
            Vector4 r3 = new Vector4(  i, -j, -i,  j );
            Vector4 r4 = new Vector4(  k, -l, -k,  l );
            Vector4 r5 = new Vector4(  m, -n, -m,  n );
            Vector4 r6 = new Vector4(  o, -p, -o,  p );
            Vector4 r7 = new Vector4( -q,  r,  q, -r );
            Vector4 r8 = c;

            var knownResults = new List<Tuple<Single, Vector4>>
            {
                new Tuple<Single, Vector4>( a0, r0 ),
                new Tuple<Single, Vector4>( a1, r1 ),
                new Tuple<Single, Vector4>( a2, r2 ),
                new Tuple<Single, Vector4>( a3, r3 ),
                new Tuple<Single, Vector4>( a4, r4 ),
                new Tuple<Single, Vector4>( a5, r5 ),
                new Tuple<Single, Vector4>( a6, r6 ),
                new Tuple<Single, Vector4>( a7, r7 ),
                new Tuple<Single, Vector4>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector4 result;

                Vector4.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

                /// <summary>
        /// Assert that, running the Min function on a number of randomly
        /// generated pairs of Vector4 objects, yields the same results as those
        /// obtained from performing a manual Min calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Min ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector4 a = GetNextRandomVector4();
                Vector4 b = a * 2;

                Vector4 result;
                Vector4.Min (ref a, ref b, out result);

                Assert.That(result.X, Is.EqualTo(a.X < b.X ? a.X : b.X ));
                Assert.That(result.Y, Is.EqualTo(a.Y < b.Y ? a.Y : b.Y ));
                Assert.That(result.Z, Is.EqualTo(a.Z < b.Z ? a.Z : b.Z ));
                Assert.That(result.W, Is.EqualTo(a.W < b.W ? a.W : b.W ));
            }
        }

        /// <summary>
        /// Assert that, running the Max function on a number of randomly
        /// generated pairs of Vector4 objects, yields the same results as those
        /// obtained from performing a manual Max calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Max ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector4 a = GetNextRandomVector4();
                Vector4 b = GetNextRandomVector4();

                Vector4 result;
                Vector4.Max (ref a, ref b, out result);

                Assert.That(result.X, Is.EqualTo(a.X > b.X ? a.X : b.X ));
                Assert.That(result.Y, Is.EqualTo(a.Y > b.Y ? a.Y : b.Y ));
                Assert.That(result.Z, Is.EqualTo(a.Z > b.Z ? a.Z : b.Z ));
                Assert.That(result.W, Is.EqualTo(a.W > b.W ? a.W : b.W ));
            }
        }

        /// <summary>
        /// Assert that, running the Clamp function on a number of randomly
        /// generated Vector4 objects for a given min-max range, yields
        /// results that fall within that range.
        /// </summary>
        [Test]
        public void TestStaticFn_Clamp_i ()
        {
            Vector4 min = new Vector4(-30, 1, 18, -22);
            Vector4 max = new Vector4(32, 130, 47, -2);

            for(Int32 i = 0; i < 100; ++i)
            {
                Vector4 a = GetNextRandomVector4();

                Vector4 result;
                Vector4.Clamp (ref a, ref min, ref max, out result);

                Assert.That(result.X, Is.LessThanOrEqualTo(max.X));
                Assert.That(result.Y, Is.LessThanOrEqualTo(max.Y));
                Assert.That(result.X, Is.GreaterThanOrEqualTo(min.X));
                Assert.That(result.Y, Is.GreaterThanOrEqualTo(min.Y));
            }
        }

        /// <summary>
        /// Assert that, running the Clamp function on an a Vector4 object known
        /// to fall outside of a given min-max range, yields a result that fall 
        /// within that range.
        /// </summary>
        [Test]
        public void TestStaticFn_Clamp_ii ()
        {
            Vector4 min = new Vector4(-30, 1, 18, -22);
            Vector4 max = new Vector4(32, 130, 47, -2);

            Vector4 a = new Vector4(-100, 1113, 50, 14);

            Vector4 expected = new Vector4(-30, 130, 47, -2);

            Vector4 result;
            Vector4.Clamp (ref a, ref min, ref max, out result);

            Assert.That(result.X, Is.LessThanOrEqualTo(max.X));
            Assert.That(result.Y, Is.LessThanOrEqualTo(max.Y));
            Assert.That(result.Z, Is.LessThanOrEqualTo(max.Z));
            Assert.That(result.W, Is.LessThanOrEqualTo(max.W));
            Assert.That(result.X, Is.GreaterThanOrEqualTo(min.X));
            Assert.That(result.Y, Is.GreaterThanOrEqualTo(min.Y));
            Assert.That(result.Z, Is.GreaterThanOrEqualTo(min.Z));
            Assert.That(result.W, Is.GreaterThanOrEqualTo(min.W));

            AssertEqualWithinReason(result, expected);

        }

        /// <summary>
        /// Assert that, running the Lerp function on a number of randomly
        /// generated pairs of Vector4 objects for a range of weighting amounts, 
        /// yields the same results as those obtained from performing a manual 
        /// Lerp calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_i ()
        {
            for(Int32 j = 0; j < 100; ++j)
            {
                Single delta = j;

                delta = delta / 100;

                for(Int32 i = 0; i < 100; ++i)
                {
                    Vector4 a = GetNextRandomVector4();
                    Vector4 b = GetNextRandomVector4();

                    Vector4 result;
                    Vector4.Lerp (ref a, ref b, delta, out result);

                    Vector4 expected = a + ( ( b - a ) * delta );

                    AssertEqualWithinReason(result, expected);
                }
            }
        }

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_ii ()
        {
            Vector4 a = GetNextRandomVector4();
            Vector4 b = GetNextRandomVector4();

            Single half; RealMaths.Half(out half);

            var tests = new Single[] { 2, half + 1, -half, -1 };

            foreach( var weighting in tests )
            {
                Vector4 result; 
                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector4.Lerp (
                            ref a, ref b, weighting, out result)
                    );
            }
        }


    }}

namespace Abacus.DoublePrecision.Tests
{
    /// <summary>
    ///
    /// </summary>
    [TestFixture]
    public class Matrix44Tests
    {
        /// <summary>
        /// The random number generator used for testing.
        /// </summary>
        static readonly System.Random rand;

        /// <summary>
        /// Static constructor used to ensure that the random number generator
        /// always gets initilised with the same seed, making the tests
        /// behave in a deterministic manner.
        /// </summary>
        static Matrix44Tests ()
        {
            rand = new System.Random(0);
        }

        /// <summary>
        /// Helper function for getting the next random Double value.
        /// </summary>
        static Double GetNextRandomDouble ()
        {
            Double randomValue = rand.NextDouble();

            Double zero = 0;
            Double multiplier = 1000;

            randomValue *= multiplier;

            Boolean randomBoolean = (rand.Next(0, 1) == 0) ? true : false;

            if( randomBoolean )
                randomValue = zero - randomValue;

            return randomValue;
        }

        /// <summary>
        /// Helper function for getting the next random Matrix44.
        /// </summary>
        internal static Matrix44 GetNextRandomMatrix44 ()
        {
            Double a = GetNextRandomDouble();
            Double b = GetNextRandomDouble();
            Double c = GetNextRandomDouble();
            Double d = GetNextRandomDouble();
            Double e = GetNextRandomDouble();
            Double f = GetNextRandomDouble();
            Double g = GetNextRandomDouble();
            Double h = GetNextRandomDouble();
            Double i = GetNextRandomDouble();
            Double j = GetNextRandomDouble();
            Double k = GetNextRandomDouble();
            Double l = GetNextRandomDouble();
            Double m = GetNextRandomDouble();
            Double n = GetNextRandomDouble();
            Double o = GetNextRandomDouble();
            Double p = GetNextRandomDouble();

            return new Matrix44(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);
        }

        /// <summary>
        /// Helper to encapsulate asserting that two Matrix44s are equal.
        /// </summary>
        internal static void AssertEqualWithinReason (Matrix44 a, Matrix44 b)
        {
            Double tolerance; RealMaths.TestTolerance(out tolerance);

            Assert.That(a.M11, Is.EqualTo(b.M11).Within(tolerance));
            Assert.That(a.M12, Is.EqualTo(b.M12).Within(tolerance));
            Assert.That(a.M13, Is.EqualTo(b.M13).Within(tolerance));
            Assert.That(a.M14, Is.EqualTo(b.M14).Within(tolerance));
            Assert.That(a.M21, Is.EqualTo(b.M21).Within(tolerance));
            Assert.That(a.M22, Is.EqualTo(b.M22).Within(tolerance));
            Assert.That(a.M23, Is.EqualTo(b.M23).Within(tolerance));
            Assert.That(a.M24, Is.EqualTo(b.M24).Within(tolerance));
            Assert.That(a.M31, Is.EqualTo(b.M31).Within(tolerance));
            Assert.That(a.M32, Is.EqualTo(b.M32).Within(tolerance));
            Assert.That(a.M33, Is.EqualTo(b.M33).Within(tolerance));
            Assert.That(a.M34, Is.EqualTo(b.M34).Within(tolerance));
            Assert.That(a.M41, Is.EqualTo(b.M41).Within(tolerance));
            Assert.That(a.M42, Is.EqualTo(b.M42).Within(tolerance));
            Assert.That(a.M43, Is.EqualTo(b.M43).Within(tolerance));
            Assert.That(a.M44, Is.EqualTo(b.M44).Within(tolerance));
        }
        

        /// <summary>
        /// This test makes sure that the struct layout has been defined
        /// correctly.
        /// </summary>
        [Test]
        public void Test_StructLayout_i ()
        {
            Type t = typeof(Matrix44);

            Assert.That(
                t.StructLayoutAttribute.Value,
                Is.EqualTo(LayoutKind.Sequential));
        }

        /// <summary>
        /// This test makes sure that when examining the memory addresses of the
        /// member variables of a number of randomly generated Matrix44
        /// objects the results are as expected.
        /// </summary>
        [Test]
        public unsafe void Test_StructLayout_ii ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        [Test]
        public void Test_Constructors ()
        {
            Assert.That(true, Is.EqualTo(false));
        }

        [Test]
        public void TestMemberFn_ToString ()
        {
            Assert.That(true, Is.EqualTo(false));
        }

        [Test]
        public void TestMemberFn_GetHashCode ()
        {
            Assert.That(true, Is.EqualTo(false));
        }

        // Test Constant: Identity //-----------------------------------------//

        /// <summary>
        /// Tests to make sure that a Matrix44 initilised using the Identity 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Identity_i ()
        {
            Matrix44 result = Matrix44.Identity;
            Matrix44 expected = new Matrix44 (
                1, 0, 0, 0, 
                0, 1, 0, 0, 
                0, 0, 1, 0, 
                0, 0, 0, 1);

            AssertEqualWithinReason(result, expected);
        }        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateTranslation_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateTranslation_ii ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateScale_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        //// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateScale_ii ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateScale_iii ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateRotationX_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateRotationY_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateRotationZ_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromAxisAngle_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromAllAxis_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateWorldNew_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateWorld_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromQuaternion_i ()
        {
            Double yaw; RealMaths.Pi(out yaw); yaw /= (Double) 4;
            Double pitch; RealMaths.Pi(out pitch); pitch /= (Double) (-8);
            Double roll; RealMaths.Pi(out roll); roll /= (Double) 2;

            Quaternion q; Quaternion.CreateFromYawPitchRoll(yaw, pitch, roll, out q);
            q.Normalise();

            Matrix44 m; Matrix44.CreateFromQuaternion(ref q, out m);

            Matrix44 expected = new Matrix44 ();
            expected.M11 = Double.Parse("-0.270598"); // this is a grim way to do it, make it so we can cast double to fixed
            expected.M12 = Double.Parse("0.9238795");
            expected.M13 = Double.Parse("-0.270598");
            expected.M14 = 0;
            expected.M21 = Double.Parse("-0.7071067");
            expected.M22 = Double.Parse("6.705523E-08");
            expected.M23 = Double.Parse("0.7071067");
            expected.M24 = 0;
            expected.M31 = Double.Parse("0.6532815");
            expected.M32 = Double.Parse("0.3826834");
            expected.M33 = Double.Parse("0.6532815");
            expected.M34 = 0;
            expected.M41 = 0;
            expected.M42 = 0;
            expected.M43 = 0;
            expected.M44 = 1;


            AssertEqualWithinReason(m, expected);

        }

        /// <summary>
        /// Assert that, for a number of examples, a random quaternion can be
        /// selected, converted to a Matrix44 then converted back to the same
        /// quaternion (assuming that the conversion back is correct).
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromQuaternion_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Quaternion q = QuaternionTests.GetNextRandomQuaternion();
                Quaternion.Normalise(ref q, out q);

                Matrix44 m;
                Matrix44.CreateFromQuaternion(ref q, out m);

                Quaternion q2;
                Quaternion.CreateFromRotationMatrix(ref m, out q2);

                QuaternionTests.AssertEqualWithinReason(q, q2);
            }
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromYawPitchRoll_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateBillboard_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateConstrainedBillboard_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreatePerspectiveFieldOfView_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreatePerspective_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreatePerspectiveOffCenter_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateOrthographic_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void CreateOrthographicOffCenter_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateLookAt_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Transpose //---------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Transpose_i ()
        {
            Matrix44 startMatrix = new Matrix44(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);

            Matrix44 testMatrix = startMatrix;

            Matrix44 testMatrixExpectedTranspose = new Matrix44(0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15);

            // RUN THE STATIC VERSION OF THE FUNCTION
            Matrix44 resultMatrix = Matrix44.Identity;

            Matrix44.Transpose(ref testMatrix, out resultMatrix);

            Assert.That(resultMatrix, Is.EqualTo(testMatrixExpectedTranspose));
        }

        // Test Static Fn: Decompose //---------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Decompose_i ()
        {
            Matrix44 scale;
            Matrix44.CreateScale(4, 2, 3, out scale);

            Matrix44 rotation;
            Double pi; RealMaths.Pi(out pi);
            Matrix44.CreateRotationY(pi, out rotation);

            Matrix44 translation;
            Matrix44.CreateTranslation(100, 5, 3, out translation);

            Matrix44 m = rotation * scale;
            //m = translation * m;
            m.Translation = new Vector3(100, 5, 3);

            Vector3 outScale;
            Quaternion outRotation;
            Vector3 outTranslation;

            m.Decompose(out outScale, out outRotation, out outTranslation);

            Matrix44 mat;
            Matrix44.CreateFromQuaternion(ref outRotation, out mat);

            Assert.That(outScale, Is.EqualTo(new Vector3(4, 2, 3)));
            Assert.That(mat, Is.EqualTo(rotation));
            Assert.That(outTranslation, Is.EqualTo(new Vector3(100, 5, 3)));
        }

        // Test Static Fn: Determinant //-------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Determinant_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Invert //------------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Invert_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Transform //---------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Transform_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }
        // Test Operator: Equality //-----------------------------------------//

        /// <summary>
        /// Helper method for testing equality.
        /// </summary>
        void TestEquality (Matrix44 a, Matrix44 b, Boolean expected )
        {
            // This test asserts the following:
            //   (a == b) == expected
            //   (b == a) == expected
            //   (a != b) == !expected
            //   (b != a) == !expected

            Boolean result_1a = (a == b);
            Boolean result_1b = (a.Equals(b));
            Boolean result_1c = (a.Equals((Object)b));
            
            Boolean result_2a = (b == a);
            Boolean result_2b = (b.Equals(a));
            Boolean result_2c = (b.Equals((Object)a));

            Boolean result_3a = (a != b);
            Boolean result_4a = (b != a);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_1c, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
            Assert.That(result_2c, Is.EqualTo(expected));
            Assert.That(result_3a, Is.EqualTo(!expected));
            Assert.That(result_4a, Is.EqualTo(!expected));
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of TRUE when two equal  
        /// Matrix44 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_i ()
        {
            var a = new Matrix44(44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);
            var b = new Matrix44(44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);

            Boolean expected = true;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of FALSE when two unequal  
        /// Matrix44 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_ii ()
        {
            var a = new Matrix44(44, 54, 2, 11, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);
            var b = new Matrix44(44, -54, 2, -1, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);

            Boolean expected = false;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Tests to make sure that all the equality opperators and functions 
        /// yield the expected result of TRUE when used on a number of randomly 
        /// generated pairs of equal Matrix44 objects.
        /// </summary>
        [Test]
        public void TestOperator_Equality_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomMatrix44();

                Matrix44 b = a;

                this.TestEquality(a, b, true);
            }
        }


        // Test Operator: Addition //-----------------------------------------//

        /// <summary>
        /// Helper method for testing addition.
        /// </summary>
        void TestAddition (Matrix44 a, Matrix44 b, Matrix44 expected )
        {
            // This test asserts the following:
            //   a + b == expected
            //   b + a == expected

            var result_1a = a + b;
            var result_2a = b + a;

            Matrix44 result_1b; Matrix44.Add(ref a, ref b, out result_1b);
            Matrix44 result_2b; Matrix44.Add(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the addition opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_i ()
        {
            var a = new Matrix44(3, -6, 44, 11, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);
            var b = new Matrix44(-6, 12, 18, -3, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);

            var expected = new Matrix44(-3, 6, 62, 8, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);

            this.TestAddition(a, b, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving the zero matrix, all the 
        /// addition opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_ii ()
        {
            var a = new Matrix44(-2313, 88, 199, 42, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);

            var expected = a;

            this.TestAddition(a, Matrix44.Identity, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving two zero matrixs, all the 
        /// addition opperators and functions yield the correct result of zero.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iii ()
        {
            this.TestAddition(Matrix44.Identity, Matrix44.Identity, Matrix44.Identity);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// addition opperators and functions yield the same results as a
        /// manual addition calculation.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomMatrix44();
                var b = GetNextRandomMatrix44();

                var expected = new Matrix44(
                    a.M11 / b.M11, 
                    a.M12 / b.M12, 
                    a.M13 / b.M13, 
                    a.M14 / b.M14,
                    a.M21 / b.M21, 
                    a.M22 / b.M22, 
                    a.M23 / b.M23, 
                    a.M24 / b.M24,
                    a.M31 / b.M31, 
                    a.M32 / b.M32, 
                    a.M33 / b.M33, 
                    a.M34 / b.M34,
                    a.M41 / b.M41, 
                    a.M42 / b.M42, 
                    a.M43 / b.M43, 
                    a.M44 / b.M44
                    );

                this.TestAddition(a, b, expected);
            }
        }

        // Test Operator: Subtraction //--------------------------------------//
        
        /// <summary>
        /// Helper method for testing subtraction.
        /// </summary>
        void TestSubtraction (Matrix44 a, Matrix44 b, Matrix44 expected )
        {
            // This test asserts the following:
            //   a - b == expected
            //   b - a == -expected

            var result_1a = a - b;
            var result_2a = b - a;

            Matrix44 result_1b; Matrix44.Subtract(ref a, ref b, out result_1b);
            Matrix44 result_2b; Matrix44.Subtract(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(-expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(-expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the subtraction opperators
        /// and functions yield the correct result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_i ()
        {
            var a = new Matrix44(12, -4, 14, 18, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);
            var b = new Matrix44(15, 11, 7, 27, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);
            var expected = new Matrix44(-3, -15, 7, -9, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);
            this.TestSubtraction(a, b, expected);

            var c = new Matrix44(-423, 342, 7, -800, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);
            this.TestSubtraction(c, Matrix44.Identity, c);
        }

        /// <summary>
        /// Assert that when subtracting the zero matrix fromt the zero matrix, 
        /// all the subtraction opperators and functions yield the correct 
        /// result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_ii ()
        {
            this.TestSubtraction(Matrix44.Identity, Matrix44.Identity, Matrix44.Identity);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// subtraction opperators and functions yield the same results as a
        /// manual subtraction calculation.
        /// </summary>
        [Test]
        public void TestOperator_Subtraction_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomMatrix44();
                var b = GetNextRandomMatrix44();

                var expected = new Matrix44(
                    a.M11 / b.M11, 
                    a.M12 / b.M12, 
                    a.M13 / b.M13, 
                    a.M14 / b.M14,
                    a.M21 / b.M21, 
                    a.M22 / b.M22, 
                    a.M23 / b.M23, 
                    a.M24 / b.M24,
                    a.M31 / b.M31, 
                    a.M32 / b.M32, 
                    a.M33 / b.M33, 
                    a.M34 / b.M34,
                    a.M41 / b.M41, 
                    a.M42 / b.M42, 
                    a.M43 / b.M43, 
                    a.M44 / b.M44
                    );

                this.TestSubtraction(a, b, expected);
            }
        }

        // Test Operator: Negation //-----------------------------------------//
        
        /// <summary>
        /// Helper method for testing negation.
        /// </summary>
        void TestNegation (Matrix44 a, Matrix44 expected )
        {
            // This test asserts the following:
            //   -a == expected

            var result_1a = -a;

            Matrix44 result_1b;
            Matrix44.Negate(ref a, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the negation opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_i ()
        {
            Double r = 3432;
            Double s = -6218;
            Double t = -3432;
            Double u = 6218;

            var a = new Matrix44(r, s, t, u, r, s, t, u, r, s, t, u, r, s, t, u);
            var b = new Matrix44(u, t, s, r, r, s, t, u, r, s, t, u, r, s, t, u);
            var c = new Matrix44(t, u, r, s, r, s, t, u, r, s, t, u, r, s, t, u);
            var d = new Matrix44(s, r, u, t, r, s, t, u, r, s, t, u, r, s, t, u);

            this.TestNegation(a, c);
            this.TestNegation(b, d);
        }

        /// <summary>
        /// Assert that, for known examples involving the zero matrix, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_ii ()
        {
            Double t = -3432;
            Double u = 6218;
            Double r = 3432;
            Double s = -6218;

            var c = new Matrix44(t, u, r, s, r, s, t, u, r, s, t, u, r, s, t, u);
            var d = new Matrix44(s, r, u, t, r, s, t, u, r, s, t, u, r, s, t, u);

            this.TestNegation(c, Matrix44.Identity - c);
            this.TestNegation(d, Matrix44.Identity - d);
        }

        /// <summary>
        /// Assert that when negating the zero matrix, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iii ()
        {
            this.TestNegation(Matrix44.Identity, Matrix44.Identity);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// negation opperators and functions yield the same results as a
        /// manual negation calculation.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomMatrix44();
                this.TestNegation(a, Matrix44.Identity - a);
            }
        }

        // Test Operator: Multiplication //-----------------------------------//

        /// <summary>
        /// Helper method for testing multiplication.
        /// </summary>
        void TestMultiplication (Matrix44 a, Matrix44 b, Matrix44 expected )
        {
            // This test asserts the following:
            //   a * b == expected
            //   b * a == expected

            var result_1a = a * b;
            var result_2a = b * a;

            Matrix44 result_1b; Matrix44.Multiply(ref a, ref b, out result_1b);
            Matrix44 result_2b; Matrix44.Multiply(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the multiplication opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_i ()
        {
            var a = new Matrix44();
            a.M11 = -27;
            a.M12 = 36;
            a.M13 = 9;
            a.M14 = -54;
            
            a.M21 = 36;
            a.M22 = 3;
            a.M23 = 9;
            a.M24 = 9;
            
            a.M31 = 9;
            a.M32 = 9;
            a.M33 = -36;
            a.M34 = 6;
            
            a.M41 = -24;
            a.M42 = 9;
            a.M43 = 36;
            a.M44 = -12;

            var b = new Matrix44();
            b.M11 = 3402;
            b.M12 = -1269;
            b.M13 = -2187;
            b.M14 = 2484;
            
            b.M21 = -999;
            b.M22 = 1467;
            b.M23 = 351;
            b.M24 = -1971;
            
            b.M31 = -387;
            b.M32 = 81;
            b.M33 = 1674;
            b.M34 = -693;
            
            b.M41 = 1584;
            b.M42 = -621;
            b.M43 = -1863;
            b.M44 = 1737;

            this.TestMultiplication(a, a, b);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// multiplication opperators and functions yield the same results as a
        /// manual multiplication calculation.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomMatrix44();
                var b = GetNextRandomMatrix44();

                var c = new Matrix44(
                    a.M11 / b.M11, 
                    a.M12 / b.M12, 
                    a.M13 / b.M13, 
                    a.M14 / b.M14,
                    a.M21 / b.M21, 
                    a.M22 / b.M22, 
                    a.M23 / b.M23, 
                    a.M24 / b.M24,
                    a.M31 / b.M31, 
                    a.M32 / b.M32, 
                    a.M33 / b.M33, 
                    a.M34 / b.M34,
                    a.M41 / b.M41, 
                    a.M42 / b.M42, 
                    a.M43 / b.M43, 
                    a.M44 / b.M44
                    );

                this.TestMultiplication(a, b, c);
            }
        }


        // Test Operator: Division //-----------------------------------------//

        /// <summary>
        /// Helper method for testing division.
        /// </summary>
        void TestDivision (Matrix44 a, Matrix44 b, Matrix44 expected )
        {
            // This test asserts the following:
            //   a / b == expected

            var result_1a = a / b;

            Matrix44 result_1b; Matrix44.Divide(ref a, ref b, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example using whole numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_i ()
        {
            Double r = 10;
            Double s = -40;
            Double t = 1;
            Double u = -400;

            Double x = 2000;
            Double y = 200;
            Double z = -5;

            var a = new Matrix44(x, y, x, x, r, s, t, u, r, s, t, u, r, s, t, u);
            var b = new Matrix44(y, z, x, z, r, s, t, u, r, s, t, u, r, s, t, u);
            var c = new Matrix44(r, s, t, u, r, s, t, u, r, s, t, u, r, s, t, u);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a known example using fractional numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_ii ()
        {
            Double r = 5;
            Double s = 4;
            Double t = ((Double) 1 ) / ((Double) 10);
            Double u = ((Double) (-1) ) / ((Double) 40 );
            Double v = -20;
            Double w = 100;
            Double x = 2000;
            Double y = 200;
            Double z = -5;

            var a = new Matrix44(y, z, w, v, r, s, t, u, r, s, t, u, r, s, t, u);
            var b = new Matrix44(x, y, z, z, r, s, t, u, r, s, t, u, r, s, t, u);
            var c = new Matrix44(t, u, v, s, r, s, t, u, r, s, t, u, r, s, t, u);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// division opperators and functions yield the same results as a
        /// manual addition division.
        /// </summary>
        [Test]
        public void TestOperator_Division_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomMatrix44();
                var b = GetNextRandomMatrix44();

                var c = new Matrix44(
                    a.M11 / b.M11, 
                    a.M12 / b.M12, 
                    a.M13 / b.M13, 
                    a.M14 / b.M14,
                    a.M21 / b.M21, 
                    a.M22 / b.M22, 
                    a.M23 / b.M23, 
                    a.M24 / b.M24,
                    a.M31 / b.M31, 
                    a.M32 / b.M32, 
                    a.M33 / b.M33, 
                    a.M34 / b.M34,
                    a.M41 / b.M41, 
                    a.M42 / b.M42, 
                    a.M43 / b.M43, 
                    a.M44 / b.M44
                    );

                this.TestDivision(a, b, c);
            }
        }

        /// <summary>
        /// Assert that, running the Lerp function on a number of randomly
        /// generated pairs of Matrix44 objects for a range of weighting amounts, 
        /// yields the same results as those obtained from performing a manual 
        /// Lerp calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_i ()
        {
            for(Int32 j = 0; j < 100; ++j)
            {
                Double delta = j;

                delta = delta / 100;

                for(Int32 i = 0; i < 100; ++i)
                {
                    Matrix44 a = GetNextRandomMatrix44();
                    Matrix44 b = GetNextRandomMatrix44();

                    Matrix44 result;
                    Matrix44.Lerp (ref a, ref b, delta, out result);

                    Matrix44 expected = a + ( ( b - a ) * delta );

                    AssertEqualWithinReason(result, expected);
                }
            }
        }

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_ii ()
        {
            Matrix44 a = GetNextRandomMatrix44();
            Matrix44 b = GetNextRandomMatrix44();

            Double half; RealMaths.Half(out half);

            var tests = new Double[] { 2, half + 1, -half, -1 };

            foreach( var weighting in tests )
            {
                Matrix44 result; 
                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Matrix44.Lerp (
                            ref a, ref b, weighting, out result)
                    );
            }
        }    }
    /// <summary>
    /// 
    /// </summary>
    [TestFixture]
    public class QuaternionTests
    {
        /// <summary>
        /// The random number generator used for testing.
        /// </summary>
        static readonly System.Random rand;

        /// <summary>
        /// Static constructor used to ensure that the random number generator
        /// always gets initilised with the same seed, making the tests
        /// behave in a deterministic manner.
        /// </summary>
        static QuaternionTests ()
        {
            rand = new System.Random(0);
        }

        /// <summary>
        /// Helper function for getting the next random Double value.
        /// </summary>
        static Double GetNextRandomDouble ()
        {
            Double randomValue = rand.NextDouble();

            Double zero = 0;
            Double multiplier = 1000;

            randomValue *= multiplier;

            Boolean randomBoolean = (rand.Next(0, 1) == 0) ? true : false;

            if( randomBoolean )
                randomValue = zero - randomValue;

            return randomValue;
        }

        /// <summary>
        /// Helper function for getting the next random Quaternion.
        /// </summary>
        internal static Quaternion GetNextRandomQuaternion ()
        {
            Double a = GetNextRandomDouble();
            Double b = GetNextRandomDouble();
            Double c = GetNextRandomDouble();
            Double d = GetNextRandomDouble();

            return new Quaternion(a, b, c, d);
        }

        /// <summary>
        /// Helper to encapsulate asserting that two Quaternions are equal.
        /// </summary>
        internal static void AssertEqualWithinReason (Quaternion a, Quaternion b)
        {
            Double tolerance; RealMaths.TestTolerance(out tolerance);

            Assert.That(a.X, Is.EqualTo(b.X).Within(tolerance));
            Assert.That(a.Y, Is.EqualTo(b.Y).Within(tolerance));
            Assert.That(a.Z, Is.EqualTo(b.Z).Within(tolerance));
            Assert.That(a.W, Is.EqualTo(b.W).Within(tolerance));
        }
        

        // Test: StructLayout //----------------------------------------------//

        /// <summary>
        /// This test makes sure that the struct layout has been defined
        /// correctly.
        /// </summary>
        [Test]
        public void Test_StructLayout_i ()
        {
            Type t = typeof(Quaternion);

            Assert.That(
                t.StructLayoutAttribute.Value, 
                Is.EqualTo(LayoutKind.Sequential));
        }

        /// <summary>
        /// This test makes sure that when examining the memory addresses of the 
        /// X, Y, Z and W member variables of a number of randomly generated 
        /// Quaterion objects the results are as expected. 
        /// </summary>
        [Test]
        public unsafe void Test_StructLayout_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Quaternion quat = GetNextRandomQuaternion();

                GCHandle h_quat = GCHandle.Alloc(quat, GCHandleType.Pinned);

                IntPtr quatAddress = h_quat.AddrOfPinnedObject();

                Double[] data = new Double[4];

                // nb: when Fixed32 and Half are moved back into the main
                //     dev branch there will be need for an extension method for
                //     Marshal that will perform the copy for those types. 
                MarshalHelper.Copy(quatAddress, data, 0, 4);
                Assert.That(data[0], Is.EqualTo(quat.X));
                Assert.That(data[1], Is.EqualTo(quat.Y));
                Assert.That(data[2], Is.EqualTo(quat.Z));
                Assert.That(data[3], Is.EqualTo(quat.W));
                
                h_quat.Free();
            }
        }

        [Test]
        public void Test_Constructors ()
        {
            Assert.That(true, Is.EqualTo(false));
        }

        [Test]
        public void TestMemberFn_ToString ()
        {
            Assert.That(true, Is.EqualTo(false));
        }

        [Test]
        public void TestMemberFn_GetHashCode ()
        {
            Assert.That(true, Is.EqualTo(false));
        }

        // Test Constant: Identity //-----------------------------------------//

        /// <summary>
        /// Tests to make sure that a Quaternion initilised using the Identity 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Identity_i ()
        {
            Quaternion result = Quaternion.Identity;
            Quaternion expected = new Quaternion (
                0, 0, 0, 1);

            AssertEqualWithinReason(result, expected);
        }        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateTranslation_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromAxisAngle_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromYawPitchRoll_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromRotationMatrix_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Conjugate //---------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Conjugate_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Inverse //-----------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Inverse_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Distance //----------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Concatenate //-------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Concatenate_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Normalise //---------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Operator: Equality //-----------------------------------------//

        /// <summary>
        /// Helper method for testing equality.
        /// </summary>
        void TestEquality (Quaternion a, Quaternion b, Boolean expected )
        {
            // This test asserts the following:
            //   (a == b) == expected
            //   (b == a) == expected
            //   (a != b) == !expected
            //   (b != a) == !expected

            Boolean result_1a = (a == b);
            Boolean result_1b = (a.Equals(b));
            Boolean result_1c = (a.Equals((Object)b));
            
            Boolean result_2a = (b == a);
            Boolean result_2b = (b.Equals(a));
            Boolean result_2c = (b.Equals((Object)a));

            Boolean result_3a = (a != b);
            Boolean result_4a = (b != a);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_1c, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
            Assert.That(result_2c, Is.EqualTo(expected));
            Assert.That(result_3a, Is.EqualTo(!expected));
            Assert.That(result_4a, Is.EqualTo(!expected));
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of TRUE when two equal  
        /// Quaternion objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_i ()
        {
            var a = new Quaternion(44, -54, -22, 11);
            var b = new Quaternion(44, -54, -22, 11);

            Boolean expected = true;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of FALSE when two unequal  
        /// Quaternion objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_ii ()
        {
            var a = new Quaternion(44, 54, 2, 11);
            var b = new Quaternion(44, -54, 2, -1);

            Boolean expected = false;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Tests to make sure that all the equality opperators and functions 
        /// yield the expected result of TRUE when used on a number of randomly 
        /// generated pairs of equal Quaternion objects.
        /// </summary>
        [Test]
        public void TestOperator_Equality_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomQuaternion();

                Quaternion b = a;

                this.TestEquality(a, b, true);
            }
        }


        // Test Operator: Addition //-----------------------------------------//

        /// <summary>
        /// Helper method for testing addition.
        /// </summary>
        void TestAddition (Quaternion a, Quaternion b, Quaternion expected )
        {
            // This test asserts the following:
            //   a + b == expected
            //   b + a == expected

            var result_1a = a + b;
            var result_2a = b + a;

            Quaternion result_1b; Quaternion.Add(ref a, ref b, out result_1b);
            Quaternion result_2b; Quaternion.Add(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the addition opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_i ()
        {
            var a = new Quaternion(3, -6, 44, 11);
            var b = new Quaternion(-6, 12, 18, -3);

            var expected = new Quaternion(-3, 6, 62, 8);

            this.TestAddition(a, b, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving the zero quaternion, all the 
        /// addition opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_ii ()
        {
            var a = new Quaternion(-2313, 88, 199, 42);

            var expected = a;

            this.TestAddition(a, Quaternion.Identity, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving two zero quaternions, all the 
        /// addition opperators and functions yield the correct result of zero.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iii ()
        {
            this.TestAddition(Quaternion.Identity, Quaternion.Identity, Quaternion.Identity);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// addition opperators and functions yield the same results as a
        /// manual addition calculation.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomQuaternion();
                var b = GetNextRandomQuaternion();

                var expected = new Quaternion(
                    a.X + b.X, a.Y + b.Y, a.Z + b.Z, a.W + b.W);

                this.TestAddition(a, b, expected);
            }
        }

        // Test Operator: Subtraction //--------------------------------------//
        
        /// <summary>
        /// Helper method for testing subtraction.
        /// </summary>
        void TestSubtraction (Quaternion a, Quaternion b, Quaternion expected )
        {
            // This test asserts the following:
            //   a - b == expected
            //   b - a == -expected

            var result_1a = a - b;
            var result_2a = b - a;

            Quaternion result_1b; Quaternion.Subtract(ref a, ref b, out result_1b);
            Quaternion result_2b; Quaternion.Subtract(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(-expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(-expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the subtraction opperators
        /// and functions yield the correct result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_i ()
        {
            var a = new Quaternion(12, -4, 14, 18);
            var b = new Quaternion(15, 11, 7, 27);
            var expected = new Quaternion(-3, -15, 7, -9);
            this.TestSubtraction(a, b, expected);

            var c = new Quaternion(-423, 342, 7, -800);
            this.TestSubtraction(c, Quaternion.Identity, c);
        }

        /// <summary>
        /// Assert that when subtracting the zero quaternion fromt the zero quaternion, 
        /// all the subtraction opperators and functions yield the correct 
        /// result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_ii ()
        {
            this.TestSubtraction(Quaternion.Identity, Quaternion.Identity, Quaternion.Identity);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// subtraction opperators and functions yield the same results as a
        /// manual subtraction calculation.
        /// </summary>
        [Test]
        public void TestOperator_Subtraction_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomQuaternion();
                var b = GetNextRandomQuaternion();

                var expected = new Quaternion(
                    a.X - b.X, a.Y - b.Y, a.Z - b.Z, a.W - b.W);

                this.TestSubtraction(a, b, expected);
            }
        }

        // Test Operator: Negation //-----------------------------------------//
        
        /// <summary>
        /// Helper method for testing negation.
        /// </summary>
        void TestNegation (Quaternion a, Quaternion expected )
        {
            // This test asserts the following:
            //   -a == expected

            var result_1a = -a;

            Quaternion result_1b; Quaternion.Negate(ref a, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the negation opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_i ()
        {
            Double r = 3432;
            Double s = -6218;
            Double t = -3432;
            Double u = 6218;

            var a = new Quaternion(r, s, t, u);
            var b = new Quaternion(u, t, s, r);
            var c = new Quaternion(t, u, r, s);
            var d = new Quaternion(s, r, u, t);

            this.TestNegation(a, c);
            this.TestNegation(b, d);
        }

        /// <summary>
        /// Assert that, for known examples involving the zero quaternion, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_ii ()
        {
            Double t = -3432;
            Double u = 6218;
            Double r = 3432;
            Double s = -6218;

            var c = new Quaternion(t, u, r, s);
            var d = new Quaternion(s, r, u, t);

            this.TestNegation(c, Quaternion.Identity - c);
            this.TestNegation(d, Quaternion.Identity - d);
        }

        /// <summary>
        /// Assert that when negating the zero quaternion, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iii ()
        {
            this.TestNegation(Quaternion.Identity, Quaternion.Identity);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// negation opperators and functions yield the same results as a
        /// manual negation calculation.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomQuaternion();
                this.TestNegation(a, Quaternion.Identity - a);
            }
        }

        // Test Operator: Multiplication //-----------------------------------//

        /// <summary>
        /// Helper method for testing multiplication.
        /// </summary>
        void TestMultiplication (Quaternion a, Quaternion b, Quaternion expected )
        {
            // This test asserts the following:
            //   a * b == expected
            //   b * a == expected

            var result_1a = a * b;
            var result_2a = b * a;

            Quaternion result_1b; Quaternion.Multiply(ref a, ref b, out result_1b);
            Quaternion result_2b; Quaternion.Multiply(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the multiplication opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_i ()
        {
            Double r = -27;
            Double s = 36;
            Double t = 9;
            Double u = -54;

            Double x = 3;
            Double y = 6;
            Double z = -9;

            var a = new Quaternion(x, y, x, y);
            var b = new Quaternion(z, y, x, z);
            var c = new Quaternion(r, s, t, u);

            this.TestMultiplication(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// multiplication opperators and functions yield the same results as a
        /// manual multiplication calculation.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomQuaternion();
                var b = GetNextRandomQuaternion();

                var c = new Quaternion(
                    a.X * b.X, a.Y * b.Y, a.Z * b.Z, a.W * b.W);

                this.TestMultiplication(a, b, c);
            }
        }


        // Test Operator: Division //-----------------------------------------//

        /// <summary>
        /// Helper method for testing division.
        /// </summary>
        void TestDivision (Quaternion a, Quaternion b, Quaternion expected )
        {
            // This test asserts the following:
            //   a / b == expected

            var result_1a = a / b;

            Quaternion result_1b; Quaternion.Divide(ref a, ref b, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example using whole numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_i ()
        {
            Double r = 10;
            Double s = -40;
            Double t = 1;
            Double u = -400;

            Double x = 2000;
            Double y = 200;
            Double z = -5;

            var a = new Quaternion(x, y, x, x);
            var b = new Quaternion(y, z, x, z);
            var c = new Quaternion(r, s, t, u);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a known example using fractional numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_ii ()
        {
            Double s = 4;
            Double t = ((Double) 1 ) / ((Double) 10);
            Double u = ((Double) (-1) ) / ((Double) 40 );
            Double v = -20;
            Double w = 100;
            Double x = 2000;
            Double y = 200;
            Double z = -5;

            var a = new Quaternion(y, z, w, v);
            var b = new Quaternion(x, y, z, z);
            var c = new Quaternion(t, u, v, s);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// division opperators and functions yield the same results as a
        /// manual addition division.
        /// </summary>
        [Test]
        public void TestOperator_Division_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomQuaternion();
                var b = GetNextRandomQuaternion();

                var c = new Quaternion(
                    a.X / b.X, a.Y / b.Y, a.Z / b.Z, a.W / b.W);

                this.TestDivision(a, b, c);
            }
        }

        /// <summary>
        /// todo
        /// </summary>
        public static void Slerp (ref Quaternion quaternion1, ref Quaternion quaternion2, Double amount, out Quaternion result)
        {
            Double zero = 0;
            Double one = 1;

            Double nineninenine;
            RealMaths.FromString("0.999999", out nineninenine);

            Double a;
            Double b;
            Double c = amount;
            
            Double d = 
                (quaternion1.X * quaternion2.X) + 
                (quaternion1.Y * quaternion2.Y) + 
                (quaternion1.Z * quaternion2.Z) + 
                (quaternion1.W * quaternion2.W);
            
            Boolean flag = false;

            if (d < zero)
            {
                flag = true;
                d = -d;
            }


            if (d >nineninenine)
            {
                b = one - c;
                a = flag ? -c : c;
            }
            else
            {
                Double e = RealMaths.ArcCos (d);
                Double f = one / RealMaths.Sin (e);

                b = RealMaths.Sin ((one - c) * e) * f;

                a = flag ? -RealMaths.Sin (c * e) * f : RealMaths.Sin (c * e) * f;
            }

            result.X = (b * quaternion1.X) + (a * quaternion2.X);
            result.Y = (b * quaternion1.Y) + (a * quaternion2.Y);
            result.Z = (b * quaternion1.Z) + (a * quaternion2.Z);
            result.W = (b * quaternion1.W) + (a * quaternion2.W);
        }

        /// <summary>
        /// todo
        /// </summary>
        public static void Lerp (ref Quaternion quaternion1, ref Quaternion quaternion2, Double amount, out Quaternion result)
        {
            Double zero = 0;
            Double one = 1;

            Double a = amount;
            Double b = one - a;
            Double c = 
                (quaternion1.X * quaternion2.X) + 
                (quaternion1.Y * quaternion2.Y) + 
                (quaternion1.Z * quaternion2.Z) + 
                (quaternion1.W * quaternion2.W);
            
            if (c >= zero)
            {
                result.X = (b * quaternion1.X) + (a * quaternion2.X);
                result.Y = (b * quaternion1.Y) + (a * quaternion2.Y);
                result.Z = (b * quaternion1.Z) + (a * quaternion2.Z);
                result.W = (b * quaternion1.W) + (a * quaternion2.W);
            }
            else
            {
                result.X = (b * quaternion1.X) - (a * quaternion2.X);
                result.Y = (b * quaternion1.Y) - (a * quaternion2.Y);
                result.Z = (b * quaternion1.Z) - (a * quaternion2.Z);
                result.W = (b * quaternion1.W) - (a * quaternion2.W);
            }

            Double d = 
                (result.X * result.X) + 
                (result.Y * result.Y) + 
                (result.Z * result.Z) + 
                (result.W * result.W);

            Double e = one / RealMaths.Sqrt (d);

            result.X *= e;
            result.Y *= e;
            result.Z *= e;
            result.W *= e;
        }

    }
        /// <summary>
    /// todo
    /// </summary>
    [TestFixture]
    public class Vector2Tests
    {
        /// <summary>
        /// The random number generator used for testing.
        /// </summary>
        static readonly System.Random rand;

        /// <summary>
        /// Static constructor used to ensure that the random number generator
        /// always gets initilised with the same seed, making the tests
        /// behave in a deterministic manner.
        /// </summary>
        static Vector2Tests ()
        {
            rand = new System.Random(0);
        }

        /// <summary>
        /// Helper function for getting the next random Double value.
        /// </summary>
        static Double GetNextRandomDouble ()
        {
            Double randomValue = rand.NextDouble();

            Double zero = 0;
            Double multiplier = 1000;

            randomValue *= multiplier;

            Boolean randomBoolean = (rand.Next(0, 1) == 0) ? true : false;

            if( randomBoolean )
                randomValue = zero - randomValue;

            return randomValue;
        }

        /// <summary>
        /// Helper function for getting the next random Vector2.
        /// </summary>
        static Vector2 GetNextRandomVector2 ()
        {
            Double a = GetNextRandomDouble();
            Double b = GetNextRandomDouble();

            return new Vector2(a, b);
        }

        /// <summary>
        /// Helper to encapsulate asserting that two Vector2s are equal.
        /// </summary>
        static void AssertEqualWithinReason (Vector2 a, Vector2 b)
        {
            Double tolerance; RealMaths.TestTolerance(out tolerance);

            Assert.That(a.X, Is.EqualTo(b.X).Within(tolerance));
            Assert.That(a.Y, Is.EqualTo(b.Y).Within(tolerance));
        }
        

        // Test: StructLayout //----------------------------------------------//

        /// <summary>
        /// This test makes sure that the struct layout has been defined
        /// correctly.
        /// </summary>
        [Test]
        public void Test_StructLayout_i ()
        {
            Type t = typeof(Vector2);

            Assert.That(
                t.StructLayoutAttribute.Value, 
                Is.EqualTo(LayoutKind.Sequential));
        }

        /// <summary>
        /// This test makes sure that when examining the memory addresses of the 
        /// X and Y member variables of a number of randomly generated Vector2
        /// objects the results are as expected. 
        /// </summary>
        [Test]
        public unsafe void Test_StructLayout_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector2 vec = GetNextRandomVector2();

                GCHandle h_vec = GCHandle.Alloc(vec, GCHandleType.Pinned);

                IntPtr vecAddress = h_vec.AddrOfPinnedObject();

                Double[] data = new Double[2];

                // nb: when Fixed32 and Half are moved back into the main
                //     dev branch there will be need for an extension method for
                //     Marshal that will perform the copy for those types. 
                MarshalHelper.Copy(vecAddress, data, 0, 2);
                Assert.That(data[0], Is.EqualTo(vec.X));
                Assert.That(data[1], Is.EqualTo(vec.Y));
                
                h_vec.Free();
            }
        }

        // Test: Constructors //----------------------------------------------//

        /// <summary>
        /// This test goes though each public constuctor and ensures that the 
        /// data members of the structure have been properly set.
        /// </summary>
        [Test]
        public void Test_Constructors_i ()
        {
            {
                // Test default values
                Vector2 a = new Vector2();
                Assert.That(a, Is.EqualTo(Vector2.Zero));
            }
            {
                // Test Vector2( Double, Double )
                Double u = -189;
                Double v = 429;
                Vector2 c = new Vector2(u, v);
                Assert.That(c.X, Is.EqualTo(u));
                Assert.That(c.Y, Is.EqualTo(v));
            }
            {
                // Test no constructor
                Vector2 e;
                e.X = 0;
                e.Y = 0;
                Assert.That(e, Is.EqualTo(Vector2.Zero));
            }
        }

        // Test Member Fn: ToString //----------------------------------------//

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i ()
        {
            Vector2 a = new Vector2(42, -17);

            String result = a.ToString();

            String expected = "{X:42 Y:-17}";

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: GetHashCode //-------------------------------------//

        /// <summary>
        /// Makes sure that the hashing function is good by testing 10,000
        /// random scenarios and ensuring that there are no more than 10
        /// collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            var hs1 = new System.Collections.Generic.HashSet<Vector2>();
            var hs2 = new System.Collections.Generic.HashSet<Int32>();

            for(Int32 i = 0; i < 10000; ++i)
            {
                var a = GetNextRandomVector2();

                hs1.Add(a);
                hs2.Add(a.GetHashCode());
            }

            Assert.That(hs1.Count, Is.EqualTo(hs2.Count).Within(10));
        }

        // Test Member Fn: Length //------------------------------------------//

        /// <summary>
        /// Tests that for a known example the Length member function yields
        /// the correct result.
        /// </summary>
        [Test]
        public void TestMemberFn_Length_i ()
        {
            Vector2 a = new Vector2(3, -4);

            Double expected = 5;

            Double result = a.Length();

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: LengthSquared //-----------------------------------//

        /// <summary>
        /// Tests that for a known example the LengthSquared member function 
        /// yields the correct result.
        /// </summary>
        [Test]
        public void TestMemberFn_LengthSquared_i ()
        {
            Vector2 a = new Vector2(3, -4);

            Double expected = 25;

            Double result = a.LengthSquared();

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: IsUnit //------------------------------------------//

        /// <summary>
        /// Tests that for the simple vectors the IsUnit member function
        /// returns the correct result of TRUE.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_i ()
        {
            Vector2 a = new Vector2( 1,  0);
            Vector2 b = new Vector2(-1,  0);
            Vector2 c = new Vector2( 0,  1);
            Vector2 d = new Vector2( 0, -1);
            Vector2 e = new Vector2( 1,  1);
            Vector2 f = new Vector2( 0,  0);

            Assert.That(a.IsUnit(), Is.EqualTo(true));
            Assert.That(b.IsUnit(), Is.EqualTo(true));
            Assert.That(c.IsUnit(), Is.EqualTo(true));
            Assert.That(d.IsUnit(), Is.EqualTo(true));

            Assert.That(e.IsUnit(), Is.EqualTo(false));
            Assert.That(f.IsUnit(), Is.EqualTo(false));
        }

        /// <summary>
        /// This test makes sure that the IsUnit member function returns the 
        /// correct result of TRUE for a number of scenarios where the test 
        /// vector is both random and normalised.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector2 a = GetNextRandomVector2();

                Vector2 b; Vector2.Normalise(ref a, out b);

                Assert.That(b.IsUnit(), Is.EqualTo(true));
            }
        }

        /// <summary>
        /// This test ensures that the IsUnit member function correctly
        /// returns TRUE for a collection of vectors, all known to be of unit 
        /// length.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_iii ()
        {
            Double radius = 1;

            Double pi; RealMaths.Pi(out pi);

            for( Int32 i = 0; i <= 1000; ++ i)
            {
                Double theta = 2 * pi * i * radius / 100;

                Double x = RealMaths.Sin(theta);
                Double y = RealMaths.Cos(theta);               

                Assert.That(
                    new Vector2(x,  y).IsUnit(), 
                    Is.EqualTo(true));
            }
        }

        /// <summary>
        /// This test makes sure that the IsUnit member function returns the 
        /// correct result of FALSE for a number of scenarios where the test 
        /// vector is randomly generated and not normalised.  It's highly
        /// unlikely that the random generator will create a unit vector!
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_iv ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector2 a = GetNextRandomVector2();

                Assert.That(a.IsUnit(), Is.EqualTo(false));
            }
        }
            
        // Test Constant: Zero //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector2 initilised using the Zero constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Zero_i ()
        {
            Vector2 result = Vector2.Zero;
            Vector2 expected = new Vector2(0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: One //----------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector2 initilised using the One constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_One_i ()
        {
            Vector2 result = Vector2.One;
            Vector2 expected = new Vector2(1, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitX //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector2 initilised using the UnitX 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitX_i ()
        {
            Vector2 result = Vector2.UnitX;
            Vector2 expected = new Vector2(1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitY //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector2 initilised using the UnitY
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitY_i ()
        {
            Vector2 result = Vector2.UnitY;
            Vector2 expected = new Vector2(0, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Static Fn: Distance //----------------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the Distance method
        /// yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_Distance_i ()
        {
            {
                Vector2 a = new Vector2(0, 4);
                Vector2 b = new Vector2(3, 0);

                Double expected = 5;
                Double result;

                Vector2.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector2 a = new Vector2(0, -4);
                Vector2 b = new Vector2(3, 0);

                Double expected = 5;
                Double result;

                Vector2.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector2 a = new Vector2(0, -4);
                Vector2 b = new Vector2(-3, 0);

                Double expected = 5;
                Double result;

                Vector2.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector2 a = Vector2.Zero;

                Double expected = 0;
                Double result;

                Vector2.Distance(ref a, ref a, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Distance method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Distance_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector2 a = GetNextRandomVector2();

                Double expected =
                    RealMaths.Sqrt((a.X * a.X) + (a.Y * a.Y));

                Assert.That(a.Length(), Is.EqualTo(expected));
            }
        }

        // Test Static Fn: DistanceSquared //---------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the DistanceSquared
        /// method yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_DistanceSquared_i ()
        {
            {
                Vector2 a = new Vector2(0, 4);
                Vector2 b = new Vector2(3, 0);

                Double expected = 25;
                Double result;

                Vector2.DistanceSquared(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector2 a = Vector2.Zero;

                Double expected = 0;
                Double result;

                Vector2.DistanceSquared(ref a, ref a, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }


        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// DistanceSquared method yeilds the same results as those obtained
        /// from performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_DistanceSquared_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector2 a = GetNextRandomVector2();
                Vector2 b = GetNextRandomVector2();

                Vector2 c = b - a;

                Double expected = (c.X * c.X) + (c.Y * c.Y);
                Double result;

                Vector2.DistanceSquared(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        // Test Static Fn: Dot //---------------------------------------------//

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Dot method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector2 a = GetNextRandomVector2();
                Vector2 b = GetNextRandomVector2();

                Double expected = (a.X * b.X) + (a.Y * b.Y);
                Double result; Vector2.Dot(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        /// <summary>
        /// Assert that two unit vectors pointing in opposing directions yeild a
        /// dot product of negative one.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_ii ()
        {
            Vector2 a = new Vector2(1, 0);
            Vector2 b = new Vector2(-1, 0);

            Double expected = -1;
            Double result; Vector2.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that two unit vectors pointing in the same direction yeild a
        /// dot product of one.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_iii ()
        {
            Vector2 a = new Vector2(1, 0);
            Vector2 b = new Vector2(1, 0);

            Double expected = 1;
            Double result; Vector2.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that two perpendicular unit vectors yeild a dot product of
        /// zero.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_iv ()
        {
            Vector2 a = new Vector2(1, 0);
            Vector2 b = new Vector2(0, 1);

            Double expected = 0;
            Double result; Vector2.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Static Fn: Normalise //---------------------------------------//

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_i()
        {
            {
                Vector2 a = Vector2.Zero;

                Vector2 b;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException),
                    () =>
                    Vector2.Normalise(ref a, out b)
                );
            }

            {
                Vector2 a = new Vector2(
                    Double.MaxValue,
                    Double.MaxValue);

                Vector2 b;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException),
                    () =>
                    Vector2.Normalise(ref a, out b)
                );
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Normalise method yeilds a unit vector (with length equal to one);
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_ii ()
        {
            Double epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector2 a = GetNextRandomVector2();

                Vector2 b; Vector2.Normalise(ref a, out b);
                Double expected = 1;
                Double result1 = b.Length();
                Assert.That(result1, Is.EqualTo(expected).Within(epsilon));

                // The normalise function takes both a ref and out parameter,
                // need to check that if we pass in the same value as both
                // parameters we get the same results.
                Vector2 c = a;
                Vector2.Normalise(ref c, out c);
                Double result2 = c.Length();
                Assert.That(result2, Is.EqualTo(expected).Within(epsilon));
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Normalise method yeilds a vector, which when multipled by the
        /// length of the original vector results in the same vector as the
        /// original vector;
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_iii ()
        {
            Double epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector2 a = GetNextRandomVector2();
                Double l = a.Length();
                Vector2 expected = a;

                Vector2 b; Vector2.Normalise(ref a, out b);
                Vector2 result1 = b * l;
                AssertEqualWithinReason(result1, expected);

                Vector2 c = a;

                // The normalise function takes both a ref and out parameter,
                // need to check that if we pass in the same value as both
                // parameters we get the same results.
                Vector2.Normalise(ref c, out c);
                Vector2 result2 = c * l;
                AssertEqualWithinReason(result2, expected);
            }
        }

        // Test Static Fn: Reflect //-----------------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the Reflect method
        /// yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_Reflect_i ()
        {
            {
                Vector2 incident = new Vector2(20, -5);

                Vector2 normal = new Vector2(1, -1);
                Vector2.Normalise(ref normal, out normal);

                Vector2 expected = new Vector2(-5, 20);
                Vector2 result;
                Vector2.Reflect(ref incident, ref normal, out result);

                AssertEqualWithinReason(result, expected);
            }

            {
                Vector2 incident = new Vector2(20, -5);

                Vector2 normal = new Vector2(2, -1);
                Vector2.Normalise(ref normal, out normal);

                Vector2 expected = new Vector2(-16, 13);
                Vector2 result;
                Vector2.Reflect(ref incident, ref normal, out result);

                AssertEqualWithinReason(result, expected);
            }

            {
                Vector2 incident = Vector2.Zero;

                Vector2 normal = new Vector2(1, 0);

                Vector2 result;
                Vector2.Reflect(ref incident, ref normal, out result);

                AssertEqualWithinReason(result, Vector2.Zero);
            }
        }


        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Reflect method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Reflect_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector2 a = GetNextRandomVector2();

                Vector2 b = GetNextRandomVector2();

                Vector2.Normalise(ref b, out b);

                Vector2 result;
                Vector2.Reflect(ref a, ref b, out result);

                Double dot;
                Vector2.Dot(ref a, ref b, out dot);

                Vector2 expected = a - (2 * dot * b);

                AssertEqualWithinReason(result, expected);
            }
        }

        /// <summary>
        /// Assert that an argument exception is thrown if the value passed in
        /// to the normal parameter is not normalised.
        /// </summary>
        [Test]
        public void TestStaticFn_Reflect_iii ()
        {
            Vector2 incident = GetNextRandomVector2();
            Vector2 normal = new Vector2(12, -241);

            Vector2 result;

            Assert.Throws(
                typeof(ArgumentOutOfRangeException),
                () =>
                Vector2.Reflect(ref incident, ref normal, out result)
            );
        }

        // Test Static Fn: TransformMatrix44 //-------------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformMatix44_i ()
        {
            Vector2 position = new Vector2 (8, 70);

            Single pi; RealMaths.Pi (out pi);

            Matrix44 rotmati = Matrix44.Identity;
            Matrix44 rotmatx; Matrix44.CreateRotationX(pi, out rotmatx);
            Matrix44 rotmaty; Matrix44.CreateRotationY(pi, out rotmaty);
            Matrix44 rotmatxy = rotmatx * rotmaty;

            Vector2 expected1 = new Vector2 ( 8,  70);
            Vector2 expected2 = new Vector2 ( 8, -70);
            Vector2 expected3 = new Vector2 (-8,  70);
            Vector2 expected4 = new Vector2 (-8, -70);

            Vector2 test1; Vector2.Transform (ref position, ref rotmati, out test1);
            Vector2 test2; Vector2.Transform (ref position, ref rotmatx, out test2);
            Vector2 test3; Vector2.Transform (ref position, ref rotmaty, out test3);
            Vector2 test4; Vector2.Transform (ref position, ref rotmatxy, out test4);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
        }

        // Test Static Fn: TransformNormal //---------------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformNormal_i ()
        {
            Vector2 position = new Vector2 (8, 70);
            Vector2.Normalise (ref position, out position);
            Single pi; RealMaths.Pi (out pi);

            Matrix44 rotmati = Matrix44.Identity;
            Matrix44 rotmatx; Matrix44.CreateRotationX(pi, out rotmatx);
            Matrix44 rotmaty; Matrix44.CreateRotationY(pi, out rotmaty);
            Matrix44 rotmatxy = rotmatx * rotmaty;

            Vector2 expected1 = new Vector2 ( 8,  70);
            Vector2 expected2 = new Vector2 ( 8, -70);
            Vector2 expected3 = new Vector2 (-8,  70);
            Vector2 expected4 = new Vector2 (-8, -70);

            Vector2.Normalise (ref expected1, out expected1);
            Vector2.Normalise (ref expected2, out expected2);
            Vector2.Normalise (ref expected3, out expected3);
            Vector2.Normalise (ref expected4, out expected4);

            Vector2 test1; Vector2.TransformNormal (ref position, ref rotmati, out test1);
            Vector2 test2; Vector2.TransformNormal (ref position, ref rotmatx, out test2);
            Vector2 test3; Vector2.TransformNormal (ref position, ref rotmaty, out test3);
            Vector2 test4; Vector2.TransformNormal (ref position, ref rotmatxy, out test4);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);

            // should also work with the standard transform fn
            Vector2 test1n; Vector2.Transform (ref position, ref rotmati, out test1n);
            Vector2 test2n; Vector2.Transform (ref position, ref rotmatx, out test2n);
            Vector2 test3n; Vector2.Transform (ref position, ref rotmaty, out test3n);
            Vector2 test4n; Vector2.Transform (ref position, ref rotmatxy, out test4n);

            AssertEqualWithinReason(test1n, expected1);
            AssertEqualWithinReason(test2n, expected2);
            AssertEqualWithinReason(test3n, expected3);
            AssertEqualWithinReason(test4n, expected4);
        }

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformNormal_ii ()
        {
            Matrix44 rotmat = Matrix44.Identity;
            Vector2 normal = new Vector2 (21, -532);
            Vector2 result;
            Assert.Throws(
                typeof(ArgumentOutOfRangeException),
                () =>
                Vector2.TransformNormal(ref normal, ref rotmat, out result)
            );
        }

        // Test Static Fn: TransformQuaternion //-----------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformQuaternion_i ()
        {
            Vector2 position = new Vector2 (8, 70);
            Single pi; RealMaths.Pi (out pi);

            Quaternion quatmati = new Quaternion (0, 0, 0, 1);
            Quaternion quatmatx = new Quaternion (1, 0, 0, 0);
            Quaternion quatmaty = new Quaternion (0, 1, 0, 0);
            Quaternion quatmatxy = new Quaternion (0, 0, 1, 0);

            Vector2 expected1 = new Vector2 ( 8,  70);
            Vector2 expected2 = new Vector2 ( 8, -70);
            Vector2 expected3 = new Vector2 (-8,  70);
            Vector2 expected4 = new Vector2 (-8, -70);

            Vector2 test1; Vector2.Transform (ref position, ref quatmati, out test1);
            Vector2 test2; Vector2.Transform (ref position, ref quatmatx, out test2);
            Vector2 test3; Vector2.Transform (ref position, ref quatmaty, out test3);
            Vector2 test4; Vector2.Transform (ref position, ref quatmatxy, out test4);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
        }

        // Test Operator: Equality //-----------------------------------------//

        /// <summary>
        /// Helper method for testing equality.
        /// </summary>
        void TestEquality (Vector2 a, Vector2 b, Boolean expected )
        {
            // This test asserts the following:
            //   (a == b) == expected
            //   (b == a) == expected
            //   (a != b) == !expected
            //   (b != a) == !expected

            Boolean result_1a = (a == b);
            Boolean result_1b = (a.Equals(b));
            Boolean result_1c = (a.Equals((Object)b));
            
            Boolean result_2a = (b == a);
            Boolean result_2b = (b.Equals(a));
            Boolean result_2c = (b.Equals((Object)a));

            Boolean result_3a = (a != b);
            Boolean result_4a = (b != a);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_1c, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
            Assert.That(result_2c, Is.EqualTo(expected));
            Assert.That(result_3a, Is.EqualTo(!expected));
            Assert.That(result_4a, Is.EqualTo(!expected));
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of TRUE when two equal  
        /// Vector2 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_i ()
        {
            var a = new Vector2(44, -54);
            var b = new Vector2(44, -54);

            Boolean expected = true;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of FALSE when two unequal  
        /// Vector2 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_ii ()
        {
            var a = new Vector2(44, 54);
            var b = new Vector2(44, -54);

            Boolean expected = false;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Tests to make sure that all the equality opperators and functions 
        /// yield the expected result of TRUE when used on a number of randomly 
        /// generated pairs of equal Vector2 objects.
        /// </summary>
        [Test]
        public void TestOperator_Equality_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();

                Vector2 b = a;

                this.TestEquality(a, b, true);
            }
        }


        // Test Operator: Addition //-----------------------------------------//

        /// <summary>
        /// Helper method for testing addition.
        /// </summary>
        void TestAddition (Vector2 a, Vector2 b, Vector2 expected )
        {
            // This test asserts the following:
            //   a + b == expected
            //   b + a == expected

            var result_1a = a + b;
            var result_2a = b + a;

            Vector2 result_1b; Vector2.Add(ref a, ref b, out result_1b);
            Vector2 result_2b; Vector2.Add(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the addition opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_i ()
        {
            var a = new Vector2(3, -6);
            var b = new Vector2(-6, 12);

            var expected = new Vector2(-3, 6);

            this.TestAddition(a, b, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving the zero vector, all the 
        /// addition opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_ii ()
        {
            var a = new Vector2(-2313, 88);

            var expected = a;

            this.TestAddition(a, Vector2.Zero, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving two zero vectors, all the 
        /// addition opperators and functions yield the correct result of zero.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iii ()
        {
            this.TestAddition(Vector2.Zero, Vector2.Zero, Vector2.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// addition opperators and functions yield the same results as a
        /// manual addition calculation.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();
                var b = GetNextRandomVector2();

                var expected = new Vector2(a.X + b.X, a.Y + b.Y);

                this.TestAddition(a, b, expected);
            }
        }

        // Test Operator: Subtraction //--------------------------------------//
        
        /// <summary>
        /// Helper method for testing subtraction.
        /// </summary>
        void TestSubtraction (Vector2 a, Vector2 b, Vector2 expected )
        {
            // This test asserts the following:
            //   a - b == expected
            //   b - a == -expected

            var result_1a = a - b;
            var result_2a = b - a;

            Vector2 result_1b; Vector2.Subtract(ref a, ref b, out result_1b);
            Vector2 result_2b; Vector2.Subtract(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(-expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(-expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the subtraction opperators
        /// and functions yield the correct result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_i ()
        {
            var a = new Vector2(12, -4);
            var b = new Vector2(15, 11);
            var expected = new Vector2(-3, -15);
            this.TestSubtraction(a, b, expected);

            var c = new Vector2(-423, 342);
            this.TestSubtraction(c, Vector2.Zero, c);
        }

        /// <summary>
        /// Assert that when subtracting the zero vector fromt the zero vector, 
        /// all the subtraction opperators and functions yield the correct 
        /// result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_ii ()
        {
            this.TestSubtraction(Vector2.Zero, Vector2.Zero, Vector2.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// subtraction opperators and functions yield the same results as a
        /// manual subtraction calculation.
        /// </summary>
        [Test]
        public void TestOperator_Subtraction_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();
                var b = GetNextRandomVector2();

                var expected = new Vector2(a.X - b.X, a.Y - b.Y);

                this.TestSubtraction(a, b, expected);
            }
        }

        // Test Operator: Negation //-----------------------------------------//
        
        /// <summary>
        /// Helper method for testing negation.
        /// </summary>
        void TestNegation (Vector2 a, Vector2 expected )
        {
            // This test asserts the following:
            //   -a == expected

            var result_1a = -a;

            Vector2 result_1b; Vector2.Negate(ref a, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the negation opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_i ()
        {
            Double r = 3432;
            Double s = -6218;
            Double t = -3432;
            Double u = 6218;

            var a = new Vector2(r, s);
            var b = new Vector2(u, t);
            var c = new Vector2(t, u);
            var d = new Vector2(s, r);

            this.TestNegation(a, c);
            this.TestNegation(b, d);
        }

        /// <summary>
        /// Assert that, for known examples involving the zero vector, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_ii ()
        {
            Double t = -3432;
            Double u = 6218;
            Double r = 3432;
            Double s = -6218;

            var c = new Vector2(t, u);
            var d = new Vector2(s, r);

            this.TestNegation(c, Vector2.Zero - c);
            this.TestNegation(d, Vector2.Zero - d);
        }

        /// <summary>
        /// Assert that when negating the zero vector, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iii ()
        {
            this.TestNegation(Vector2.Zero, Vector2.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// negation opperators and functions yield the same results as a
        /// manual negation calculation.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();
                this.TestNegation(a, Vector2.Zero - a);
            }
        }

        // Test Operator: Multiplication //-----------------------------------//

        /// <summary>
        /// Helper method for testing multiplication.
        /// </summary>
        void TestMultiplication (Vector2 a, Vector2 b, Vector2 expected )
        {
            // This test asserts the following:
            //   a * b == expected
            //   b * a == expected

            var result_1a = a * b;
            var result_2a = b * a;

            Vector2 result_1b; Vector2.Multiply(ref a, ref b, out result_1b);
            Vector2 result_2b; Vector2.Multiply(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the multiplication opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_i ()
        {
            Double r = 18;
            Double s = -54;

            Double x = 3;
            Double y = 6;
            Double z = -9;

            var a = new Vector2(x, y);
            var b = new Vector2(y, z);
            var c = new Vector2(r, s);

            this.TestMultiplication(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// multiplication opperators and functions yield the same results as a
        /// manual multiplication calculation.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();
                var b = GetNextRandomVector2();

                var c = new Vector2(a.X * b.X, a.Y * b.Y);

                this.TestMultiplication(a, b, c);
            }
        }


        // Test Operator: Division //-----------------------------------------//

        /// <summary>
        /// Helper method for testing division.
        /// </summary>
        void TestDivision (Vector2 a, Vector2 b, Vector2 expected )
        {
            // This test asserts the following:
            //   a / b == expected

            var result_1a = a / b;

            Vector2 result_1b; Vector2.Divide(ref a, ref b, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example using whole numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_i ()
        {
            Double r = 10;
            Double s = -40;

            Double x = 2000;
            Double y = 200;
            Double z = -5;

            var a = new Vector2(x, y);
            var b = new Vector2(y, z);
            var c = new Vector2(r, s);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a known example using fractional numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_ii ()
        {
            Double t = ((Double) 1 ) / ((Double) 10);
            Double u = ((Double) (-1) ) / ((Double) 40 );
            Double x = 2000;
            Double y = 200;
            Double z = -5;

            var a = new Vector2(y, z);
            var b = new Vector2(x, y);
            var c = new Vector2(t, u);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// division opperators and functions yield the same results as a
        /// manual addition division.
        /// </summary>
        [Test]
        public void TestOperator_Division_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();
                var b = GetNextRandomVector2();

                var c = new Vector2(a.X / b.X, a.Y / b.Y);

                this.TestDivision(a, b, c);
            }
        }

        // Test Static Fn: SmoothStep //--------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();
                var b = GetNextRandomVector2();

                Double amount1 = 0;
                Vector2 result1;

                Vector2.SmoothStep (
                    ref a, ref b, amount1, out result1);

                AssertEqualWithinReason(result1, a);

                Double amount2 = 1;
                Vector2 result2;

                Vector2.SmoothStep (
                    ref a, ref b, amount2, out result2);

                AssertEqualWithinReason(result2, b);
            }
        }

        /// <summary>
        /// Assert that, for known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_ii ()
        {
            var a = GetNextRandomVector2();
            var b = GetNextRandomVector2();

            Double half; RealMaths.Half(out half);

            var tests = new Double[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector2 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector2.SmoothStep (
                            ref a, ref b, amount, out result)
                    );
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_iii ()
        {
            var a = new Vector2( -30, -30 );
            var b = new Vector2( +30, +30 );

            Double one = 1;

            Double i;
            RealMaths.FromFraction(1755, 64, out i); // 27.421875
            
            Double j;
            RealMaths.FromFraction( 165,  8, out j); // 20.625
            
            Double k;
            RealMaths.FromFraction( 705, 64, out k); // 11.015625

            Double a0 = 0;
            Double a1 = (one * 1) / 8;
            Double a2 = (one * 2) / 8;
            Double a3 = (one * 3) / 8;
            Double a4 = (one * 4) / 8;
            Double a5 = (one * 5) / 8;
            Double a6 = (one * 6) / 8;
            Double a7 = (one * 7) / 8;
            Double a8 = 1;

            Vector2 r0 = a;
            Vector2 r1 = new Vector2( -i, -i );
            Vector2 r2 = new Vector2( -j, -j );
            Vector2 r3 = new Vector2( -k, -k );
            Vector2 r4 = Vector2.Zero;
            Vector2 r5 = new Vector2(  k,  k );
            Vector2 r6 = new Vector2(  j,  j );
            Vector2 r7 = new Vector2(  i,  i );
            Vector2 r8 = b;

            var knownResults = new List<Tuple<Double, Vector2>>
            {
                new Tuple<Double, Vector2>( a0, r0 ),
                new Tuple<Double, Vector2>( a1, r1 ),
                new Tuple<Double, Vector2>( a2, r2 ),
                new Tuple<Double, Vector2>( a3, r3 ),
                new Tuple<Double, Vector2>( a4, r4 ),
                new Tuple<Double, Vector2>( a5, r5 ),
                new Tuple<Double, Vector2>( a6, r6 ),
                new Tuple<Double, Vector2>( a7, r7 ),
                new Tuple<Double, Vector2>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector2 result;

                Vector2.SmoothStep (
                    ref a, ref b, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        // Test Static Fn: CatmullRom //--------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();
                var b = GetNextRandomVector2();
                var c = GetNextRandomVector2();
                var d = GetNextRandomVector2();

                Double amount1 = 0;
                Vector2 result1;

                Vector2.CatmullRom (
                    ref a, ref b, ref c, ref d, amount1, out result1);

                AssertEqualWithinReason(result1, b);

                Double amount2 = 1;
                Vector2 result2;

                Vector2.CatmullRom (
                    ref a, ref b, ref c, ref d, amount2, out result2);

                AssertEqualWithinReason(result2, c);
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_ii ()
        {
            var a = new Vector2( -90, +30 );
            var b = new Vector2( -30, -30 );
            var c = new Vector2( +30, +30 );
            var d = new Vector2( +90, -30 );

            Double one = 1;

            Double u = 15;
            Double v = (Double) 165  / (Double)  8; // 20.5
            Double w = (Double) 45   / (Double)  2; // 20.625
            Double x = (Double) 1755 / (Double) 64; // 27.421875
            Double y = (Double) 15   / (Double)  2; // 14.5
            Double z = (Double) 705  / (Double) 64; // 11.015625

            Double a0 = 0;
            Double a1 = (one * 1) / 8;
            Double a2 = (one * 2) / 8;
            Double a3 = (one * 3) / 8;
            Double a4 = (one * 4) / 8;
            Double a5 = (one * 5) / 8;
            Double a6 = (one * 6) / 8;
            Double a7 = (one * 7) / 8;
            Double a8 = 1;

            Vector2 r0 = b;
            Vector2 r1 = new Vector2( -w, -x );
            Vector2 r2 = new Vector2( -u, -v );
            Vector2 r3 = new Vector2( -y, -z );
            Vector2 r4 = Vector2.Zero;
            Vector2 r5 = new Vector2(  y,  z );
            Vector2 r6 = new Vector2(  u,  v );
            Vector2 r7 = new Vector2(  w,  x );
            Vector2 r8 = c;

            var knownResults = new List<Tuple<Double, Vector2>>
            {
                new Tuple<Double, Vector2>( a0, r0 ),
                new Tuple<Double, Vector2>( a1, r1 ),
                new Tuple<Double, Vector2>( a2, r2 ),
                new Tuple<Double, Vector2>( a3, r3 ),
                new Tuple<Double, Vector2>( a4, r4 ),
                new Tuple<Double, Vector2>( a5, r5 ),
                new Tuple<Double, Vector2>( a6, r6 ),
                new Tuple<Double, Vector2>( a7, r7 ),
                new Tuple<Double, Vector2>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector2 result;

                Vector2.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        /// <summary>
        /// Assert that, for known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_iii ()
        {
            var a = GetNextRandomVector2();
            var b = GetNextRandomVector2();
            var c = GetNextRandomVector2();
            var d = GetNextRandomVector2();
            
            Double half; RealMaths.Half(out half);

            var tests = new Double[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector2 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector2.CatmullRom (
                            ref a, ref b, ref c, ref d, amount, out result)
                );
            }
        }

        /// <summary>
        /// This tests compares results against an example where all the control
        /// points are in a straight line.  In this case the resulting spline
        /// should be a straight line.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_iv ()
        {
            var a = new Vector2( -90, -90 );
            var b = new Vector2( -30, -30 );
            var c = new Vector2( +30, +30 );
            var d = new Vector2( +90, +90 );

            Double one = 1;

            Double a0 = 0;
            Double a1 = (one * 1) / 4;
            Double a2 = (one * 2) / 4;
            Double a3 = (one * 3) / 4;
            Double a4 = 1;

            Vector2 r0 = b;
            Vector2 r1 = new Vector2( -15, -15 );
            Vector2 r2 = Vector2.Zero;
            Vector2 r3 = new Vector2( 15, 15 );
            Vector2 r4 = c;

            var knownResults = new List<Tuple<Double, Vector2>>
            {
                new Tuple<Double, Vector2>( a0, r0 ),
                new Tuple<Double, Vector2>( a1, r1 ),
                new Tuple<Double, Vector2>( a2, r2 ),
                new Tuple<Double, Vector2>( a3, r3 ),
                new Tuple<Double, Vector2>( a4, r4 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector2 result;

                Vector2.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        // Test Static Fn: Hermite //-----------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a  = GetNextRandomVector2();
                var b  = GetNextRandomVector2();

                var c = GetNextRandomVector2();
                var d = GetNextRandomVector2();

                Vector2 an; Vector2.Normalise(ref c, out an);
                Vector2 bn; Vector2.Normalise(ref d, out bn);

                Double amount1 = 0;
                Vector2 result1;

                Vector2.Hermite (
                    ref a, ref an, ref b, ref bn, amount1, out result1);

                AssertEqualWithinReason(result1, a);

                Double amount2 = 1;
                Vector2 result2;

                Vector2.Hermite (
                    ref a, ref an, ref b, ref bn, amount2, out result2);

                AssertEqualWithinReason(result2, b);
            }
        }

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_ii ()
        {
            var a = GetNextRandomVector2();
            var b = GetNextRandomVector2();
            var c = GetNextRandomVector2();
            var d = GetNextRandomVector2();

            Vector2 an; Vector2.Normalise(ref c, out an);
            Vector2 bn; Vector2.Normalise(ref d, out bn);

            Double half; RealMaths.Half(out half);

            var tests = new Double[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector2 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector2.Hermite (
                            ref a, ref an, ref b, ref bn, amount, out result)
                    );
                
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_iii ()
        {
            var a = new Vector2( -100, +50 );
            var b = new Vector2( +100, -50 );

            var c = new Vector2( -10, +5 );
            var d = new Vector2( +10, -5 );

            Vector2 an; Vector2.Normalise(ref c, out an);
            Vector2 bn; Vector2.Normalise(ref d, out bn);

            Double one = 1;
            
            // 100.1953125
            Double e = (Double) 51300 / (Double) 512;

            // 50.09765625
            Double f = (Double) 12825 / (Double) 256;

            // 91.25
            Double g = (Double) 365 / (Double) 4;

            // 45.625
            Double h = (Double) 365 / (Double) 8;

            // 75.7421875
            Double i = (Double) 9695 / (Double) 128;

            // 37.87109375
            Double j = (Double) 9695 / (Double) 256;

            // 56.25
            Double k = (Double) 225 / (Double) 4;

            // 28.125
            Double l = (Double) 225 / (Double) 8;

            // 35.3515625
            Double m = (Double) 4525 / (Double) 128;

            // 17.67578125
            Double n = (Double) 4525 / (Double) 256;

            // 15.625
            Double o = (Double) 125 / (Double) 8;

            // 7.8125
            Double p = (Double) 125 / (Double) 16;

            // 0.3515625
            Double q = (Double) 45 / (Double) 128;

            // 0.17578125
            Double r = (Double) 45 / (Double) 256;

            Double a0 = 0;
            Double a1 = (one * 1) / 8;
            Double a2 = (one * 2) / 8;
            Double a3 = (one * 3) / 8;
            Double a4 = (one * 4) / 8;
            Double a5 = (one * 5) / 8;
            Double a6 = (one * 6) / 8;
            Double a7 = (one * 7) / 8;
            Double a8 = 1;

            Vector2 r0 = b;
            Vector2 r1 = new Vector2(  e, -f );
            Vector2 r2 = new Vector2(  g, -h );
            Vector2 r3 = new Vector2(  i, -j );
            Vector2 r4 = new Vector2(  k, -l );
            Vector2 r5 = new Vector2(  m, -n );
            Vector2 r6 = new Vector2(  o, -p );
            Vector2 r7 = new Vector2( -q,  r );
            Vector2 r8 = c;

            var knownResults = new List<Tuple<Double, Vector2>>
            {
                new Tuple<Double, Vector2>( a0, r0 ),
                new Tuple<Double, Vector2>( a1, r1 ),
                new Tuple<Double, Vector2>( a2, r2 ),
                new Tuple<Double, Vector2>( a3, r3 ),
                new Tuple<Double, Vector2>( a4, r4 ),
                new Tuple<Double, Vector2>( a5, r5 ),
                new Tuple<Double, Vector2>( a6, r6 ),
                new Tuple<Double, Vector2>( a7, r7 ),
                new Tuple<Double, Vector2>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector2 result;

                Vector2.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

                /// <summary>
        /// Assert that, running the Min function on a number of randomly
        /// generated pairs of Vector2 objects, yields the same results as those
        /// obtained from performing a manual Min calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Min ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector2 a = GetNextRandomVector2();
                Vector2 b = a * 2;

                Vector2 result;
                Vector2.Min (ref a, ref b, out result);

                Assert.That(result.X, Is.EqualTo(a.X < b.X ? a.X : b.X ));
                Assert.That(result.Y, Is.EqualTo(a.Y < b.Y ? a.Y : b.Y ));
            }
        }

        /// <summary>
        /// Assert that, running the Max function on a number of randomly
        /// generated pairs of Vector2 objects, yields the same results as those
        /// obtained from performing a manual Max calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Max ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector2 a = GetNextRandomVector2();
                Vector2 b = GetNextRandomVector2();

                Vector2 result;
                Vector2.Max (ref a, ref b, out result);

                Assert.That(result.X, Is.EqualTo(a.X > b.X ? a.X : b.X ));
                Assert.That(result.Y, Is.EqualTo(a.Y > b.Y ? a.Y : b.Y ));
            }
        }

        /// <summary>
        /// Assert that, running the Clamp function on a number of randomly
        /// generated Vector2 objects for a given min-max range, yields
        /// results that fall within that range.
        /// </summary>
        [Test]
        public void TestStaticFn_Clamp_i ()
        {
            Vector2 min = new Vector2(-30, 1);
            Vector2 max = new Vector2(32, 130);

            for(Int32 i = 0; i < 100; ++i)
            {
                Vector2 a = GetNextRandomVector2();

                Vector2 result;
                Vector2.Clamp (ref a, ref min, ref max, out result);

                Assert.That(result.X, Is.LessThanOrEqualTo(max.X));
                Assert.That(result.Y, Is.LessThanOrEqualTo(max.Y));
                Assert.That(result.X, Is.GreaterThanOrEqualTo(min.X));
                Assert.That(result.Y, Is.GreaterThanOrEqualTo(min.Y));
            }
        }

        /// <summary>
        /// Assert that, running the Clamp function on an a Vector2 object known
        /// to fall outside of a given min-max range, yields a result that fall 
        /// within that range.
        /// </summary>
        [Test]
        public void TestStaticFn_Clamp_ii ()
        {
            Vector2 min = new Vector2(-30, 1);
            Vector2 max = new Vector2(32, 130);

            Vector2 a = new Vector2(-100, 1113);

            Vector2 expected = new Vector2(-30, 130);

            Vector2 result;
            Vector2.Clamp (ref a, ref min, ref max, out result);

            Assert.That(result.X, Is.LessThanOrEqualTo(max.X));
            Assert.That(result.Y, Is.LessThanOrEqualTo(max.Y));
            Assert.That(result.X, Is.GreaterThanOrEqualTo(min.X));
            Assert.That(result.Y, Is.GreaterThanOrEqualTo(min.Y));

            AssertEqualWithinReason(result, expected);

        }

        /// <summary>
        /// Assert that, running the Lerp function on a number of randomly
        /// generated pairs of Vector2 objects for a range of weighting amounts, 
        /// yields the same results as those obtained from performing a manual 
        /// Lerp calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_i ()
        {
            for(Int32 j = 0; j < 100; ++j)
            {
                Double delta = j;

                delta = delta / 100;

                for(Int32 i = 0; i < 100; ++i)
                {
                    Vector2 a = GetNextRandomVector2();
                    Vector2 b = GetNextRandomVector2();

                    Vector2 result;
                    Vector2.Lerp (ref a, ref b, delta, out result);

                    Vector2 expected = a + ( ( b - a ) * delta );

                    AssertEqualWithinReason(result, expected);
                }
            }
        }

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_ii ()
        {
            Vector2 a = GetNextRandomVector2();
            Vector2 b = GetNextRandomVector2();

            Double half; RealMaths.Half(out half);

            var tests = new Double[] { 2, half + 1, -half, -1 };

            foreach( var weighting in tests )
            {
                Vector2 result; 
                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector2.Lerp (
                            ref a, ref b, weighting, out result)
                    );
            }
        }


    }    /// <summary>
    /// 
    /// </summary>
    [TestFixture]
    public class Vector3Tests
    {
        /// <summary>
        /// The random number generator used for testing.
        /// </summary>
        static readonly System.Random rand;

        /// <summary>
        /// Static constructor used to ensure that the random number generator
        /// always gets initilised with the same seed, making the tests
        /// behave in a deterministic manner.
        /// </summary>
        static Vector3Tests ()
        {
            rand = new System.Random(0);
        }

        /// <summary>
        /// Helper function for getting the next random Double value.
        /// </summary>
        static Double GetNextRandomDouble ()
        {
            Double randomValue = rand.NextDouble();

            Double zero = 0;
            Double multiplier = 1000;

            randomValue *= multiplier;

            Boolean randomBoolean = (rand.Next(0, 1) == 0) ? true : false;

            if( randomBoolean )
                randomValue = zero - randomValue;

            return randomValue;
        }

        /// <summary>
        /// Helper function for getting the next random Vector3.
        /// </summary>
        static Vector3 GetNextRandomVector3 ()
        {
            Double a = GetNextRandomDouble();
            Double b = GetNextRandomDouble();
            Double c = GetNextRandomDouble();

            return new Vector3(a, b, c);
        }

        /// <summary>
        /// Helper to encapsulate asserting that two Vector3s are equal.
        /// </summary>
        static void AssertEqualWithinReason (Vector3 a, Vector3 b)
        {
            Double tolerance; RealMaths.TestTolerance(out tolerance);

            Assert.That(a.X, Is.EqualTo(b.X).Within(tolerance));
            Assert.That(a.Y, Is.EqualTo(b.Y).Within(tolerance));
            Assert.That(a.Z, Is.EqualTo(b.Z).Within(tolerance));
        }
        

        // Test: StructLayout //----------------------------------------------//

        /// <summary>
        /// This test makes sure that the struct layout has been defined
        /// correctly.
        /// </summary>
        [Test]
        public void Test_StructLayout_i ()
        {
            Type t = typeof(Vector3);

            Assert.That(
                t.StructLayoutAttribute.Value, 
                Is.EqualTo(LayoutKind.Sequential));
        }

        /// <summary>
        /// This test makes sure that when examining the memory addresses of the 
        /// X, Y and Z member variables of a number of randomly generated 
        /// Vector3 objects the results are as expected. 
        /// </summary>
        [Test]
        public unsafe void Test_StructLayout_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector3 vec = GetNextRandomVector3();

                GCHandle h_vec = GCHandle.Alloc(vec, GCHandleType.Pinned);

                IntPtr vecAddress = h_vec.AddrOfPinnedObject();

                Double[] data = new Double[3];

                // nb: when Fixed32 and Half are moved back into the main
                //     dev branch there will be need for an extension method for
                //     Marshal that will perform the copy for those types. 
                MarshalHelper.Copy(vecAddress, data, 0, 3);
                Assert.That(data[0], Is.EqualTo(vec.X));
                Assert.That(data[1], Is.EqualTo(vec.Y));
                Assert.That(data[2], Is.EqualTo(vec.Z));
                
                h_vec.Free();
            }
        }

        // Test: Constructors //----------------------------------------------//

        /// <summary>
        /// This test goes though each public constuctor and ensures that the 
        /// data members of the structure have been properly set.
        /// </summary>
        [Test]
        public void Test_Constructors_i ()
        {
            {
                // Test default values
                Vector3 a = new Vector3();
                Assert.That(a, Is.EqualTo(Vector3.Zero));
            }
            {
                // Test Vector3( Double, Double, Double )
                Double a = -189;
                Double b = 429;
                Double c = 4298;
                Vector3 d = new Vector3(a, b, c);
                Assert.That(d.X, Is.EqualTo(a));
                Assert.That(d.Y, Is.EqualTo(b));
                Assert.That(d.Z, Is.EqualTo(c));
            }
            {
                // Test Vector3( Vector2, Double )
                Vector2 a = new Vector2(-189, 429);
                Double b = 4298;
                Vector3 c = new Vector3(a, b);
                Assert.That(c.X, Is.EqualTo(a.X));
                Assert.That(c.Y, Is.EqualTo(a.Y));
                Assert.That(c.Z, Is.EqualTo(b));
            }
            {
                // Test no constructor
                Vector3 a;
                a.X = 0;
                a.Y = 0;
                a.Z = 0;
                Assert.That(a, Is.EqualTo(Vector3.Zero));
            }
        }

        // Test Member Fn: ToString //----------------------------------------//

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i ()
        {
            Vector3 a = new Vector3(42, -17, 13);

            String result = a.ToString();

            String expected = "{X:42 Y:-17 Z:13}";

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: GetHashCode //-------------------------------------//

        /// <summary>
        /// Makes sure that the hashing function is good by testing 10,000
        /// random scenarios and ensuring that there are no more than 10
        /// collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            var hs1 = new System.Collections.Generic.HashSet<Vector3>();
            var hs2 = new System.Collections.Generic.HashSet<Int32>();

            for(Int32 i = 0; i < 10000; ++i)
            {
                var a = GetNextRandomVector3();

                hs1.Add(a);
                hs2.Add(a.GetHashCode());
            }

            Assert.That(hs1.Count, Is.EqualTo(hs2.Count).Within(10));
        }

        // Test Member Fn: Length //------------------------------------------//

        /// <summary>
        /// Tests that for a known example the Length member function yields
        /// the correct result.
        /// </summary>
        [Test]
        public void TestMemberFn_Length_i ()
        {
            Vector3 a = new Vector3(3, -4, 12);

            Double expected = 13;

            Double result = a.Length();

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: LengthSquared //-----------------------------------//

        /// <summary>
        /// Tests that for a known example the LengthSquared member function 
        /// yields the correct result.
        /// </summary>
        [Test]
        public void TestMemberFn_LengthSquared_i ()
        {
            Vector3 a = new Vector3(3, -4, 12);

            Double expected = 169;

            Double result = a.LengthSquared();

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: IsUnit //------------------------------------------//

        /// <summary>
        /// Tests that for the simple vectors the IsUnit member function
        /// returns the correct result of TRUE.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_i ()
        {
            Vector3 a = new Vector3( 1,  0,  0);
            Vector3 b = new Vector3(-1,  0,  0);
            Vector3 c = new Vector3( 0,  1,  0);
            Vector3 d = new Vector3( 0, -1,  0);
            Vector3 e = new Vector3( 0,  0,  1);
            Vector3 f = new Vector3( 0,  0, -1);
            Vector3 g = new Vector3( 1,  1,  1);
            Vector3 h = new Vector3( 0,  0,  0);

            Assert.That(a.IsUnit(), Is.EqualTo(true));
            Assert.That(b.IsUnit(), Is.EqualTo(true));
            Assert.That(c.IsUnit(), Is.EqualTo(true));
            Assert.That(d.IsUnit(), Is.EqualTo(true));
            Assert.That(e.IsUnit(), Is.EqualTo(true));
            Assert.That(f.IsUnit(), Is.EqualTo(true));

            Assert.That(g.IsUnit(), Is.EqualTo(false));
            Assert.That(h.IsUnit(), Is.EqualTo(false));
        }

        /// <summary>
        /// This test makes sure that the IsUnit member function returns the 
        /// correct result of TRUE for a number of scenarios where the test 
        /// vector is both random and normalised.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector3 a = GetNextRandomVector3();

                Vector3 b; Vector3.Normalise(ref a, out b);

                Assert.That(b.IsUnit(), Is.EqualTo(true));
            }
        }

        /// <summary>
        /// This test ensures that the IsUnit member function correctly
        /// returns TRUE for a collection of vectors, all known to be of unit 
        /// length.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_iii ()
        {
            Double radius = 1;

            Double pi; RealMaths.Pi(out pi);

            for( Int32 i = 0; i <= 31; ++ i)
            {
                for( Int32 j = 0; j <= 31; ++ j)
                {
                    Double theta = 2 * pi * i / 100;
                    Double phi = 2 * pi * j / 100;

                    Double x = 
                        RealMaths.Cos(theta) * 
                        RealMaths.Sin(phi) * radius;

                    Double y = 
                        RealMaths.Sin(theta) * 
                        RealMaths.Sin(phi) * radius;

                    Double z = 
                        RealMaths.Cos(phi) * radius;                

                    Assert.That(
                        new Vector3( x,  y,  z).IsUnit(), 
                        Is.EqualTo(true));
                }
            }
        }

        /// <summary>
        /// This test makes sure that the IsUnit member function returns the 
        /// correct result of FALSE for a number of scenarios where the test 
        /// vector is randomly generated and not normalised.  It's highly
        /// unlikely that the random generator will create a unit vector!
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_iv ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector3 a = GetNextRandomVector3();

                Assert.That(a.IsUnit(), Is.EqualTo(false));
            }
        }
            
        // Test Constant: Zero //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the Zero constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Zero_i ()
        {
            Vector3 result = Vector3.Zero;
            Vector3 expected = new Vector3(0, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: One //----------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the One constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_One_i ()
        {
            Vector3 result = Vector3.One;
            Vector3 expected = new Vector3(1, 1, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitX //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the UnitX 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitX_i ()
        {
            Vector3 result = Vector3.UnitX;
            Vector3 expected = new Vector3(1, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitY //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the UnitY
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitY_i ()
        {
            Vector3 result = Vector3.UnitY;
            Vector3 expected = new Vector3(0, 1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitZ //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the UnitZ
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitZ_i ()
        {
            Vector3 result = Vector3.UnitZ;
            Vector3 expected = new Vector3(0, 0, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Up //-----------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the Up
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Up_i ()
        {
            Vector3 result = Vector3.Up;
            Vector3 expected = new Vector3(0, 1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Down //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the Down
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Down_i ()
        {
            Vector3 result = Vector3.Down;
            Vector3 expected = new Vector3(0, -1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Right //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the Right
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Right_i ()
        {
            Vector3 result = Vector3.Right;
            Vector3 expected = new Vector3(1, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Left //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the Left
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Left_i ()
        {
            Vector3 result = Vector3.Left;
            Vector3 expected = new Vector3(-1, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Forward //------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the Forward
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Forward_i ()
        {
            Vector3 result = Vector3.Forward;
            Vector3 expected = new Vector3(0, 0, -1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Backward //-----------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the Backward
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Backward_i ()
        {
            Vector3 result = Vector3.Backward;
            Vector3 expected = new Vector3(0, 0, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Static Fn: Distance //----------------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the Distance method
        /// yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_Distance_i ()
        {
            {
                Vector3 a = new Vector3(0, 4, 12);
                Vector3 b = new Vector3(3, 0, 0);

                Double expected = 13;
                Double result;

                Vector3.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector3 a = new Vector3(0, -4, 12);
                Vector3 b = new Vector3(3, 0, 0);

                Double expected = 13;
                Double result;

                Vector3.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector3 a = new Vector3(0, -4, -12);
                Vector3 b = new Vector3(-3, 0, 0);

                Double expected = 13;
                Double result;

                Vector3.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector3 a = Vector3.Zero;

                Double expected = 0;
                Double result;

                Vector3.Distance(ref a, ref a, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Distance method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Distance_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector3 a = GetNextRandomVector3();

                Double expected =
                    RealMaths.Sqrt((a.X * a.X) + (a.Y * a.Y) + (a.Z * a.Z));

                Assert.That(a.Length(), Is.EqualTo(expected));
            }
        }

        // Test Static Fn: DistanceSquared //---------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the DistanceSquared
        /// method yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_DistanceSquared_i ()
        {
            {
                Vector3 a = new Vector3(0, 4, 12);
                Vector3 b = new Vector3(3, 0, 0);

                Double expected = 161;
                Double result;

                Vector3.DistanceSquared(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector3 a = Vector3.Zero;

                Double expected = 0;
                Double result;

                Vector3.DistanceSquared(ref a, ref a, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }


        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// DistanceSquared method yeilds the same results as those obtained
        /// from performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_DistanceSquared_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector3 a = GetNextRandomVector3();
                Vector3 b = GetNextRandomVector3();

                Vector3 c = b - a;

                Double expected = (c.X * c.X) + (c.Y * c.Y) + (c.Z * c.Z);
                Double result;

                Vector3.DistanceSquared(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        // Test Static Fn: Dot //---------------------------------------------//

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Dot method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector3 a = GetNextRandomVector3();
                Vector3 b = GetNextRandomVector3();

                Double expected = (a.X * b.X) + (a.Y * b.Y) + (a.Z * b.Z);
                Double result; Vector3.Dot(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        /// <summary>
        /// Assert that two unit vectors pointing in opposing directions yeild a
        /// dot product of negative one.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_ii ()
        {
            Vector3 a = new Vector3(0, 0, 1);
            Vector3 b = new Vector3(0, 0, -1);

            Double expected = -1;
            Double result; Vector3.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that two unit vectors pointing in the same direction yeild a
        /// dot product of one.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_iii ()
        {
            Vector3 a = new Vector3(0, 0, 1);
            Vector3 b = new Vector3(0, 0, 1);

            Double expected = 1;
            Double result; Vector3.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that two perpendicular unit vectors yeild a dot product of
        /// zero.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_iv ()
        {
            Vector3 a = new Vector3(0, 1, 0);
            Vector3 b = new Vector3(0, 0, 1);

            Double expected = 0;
            Double result; Vector3.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Static Fn: Normalise //---------------------------------------//

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_i()
        {
            {
                Vector3 a = Vector3.Zero;

                Vector3 b;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException),
                    () =>
                    Vector3.Normalise(ref a, out b)
                );
            }

            {
                Vector3 a = new Vector3(
                    Double.MaxValue,
                    Double.MaxValue,
                    Double.MaxValue);

                Vector3 b;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException),
                    () =>
                    Vector3.Normalise(ref a, out b)
                );
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Normalise method yeilds a unit vector (with length equal to one);
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_ii ()
        {
            Double epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector3 a = GetNextRandomVector3();

                Vector3 b; Vector3.Normalise(ref a, out b);
                Double expected = 1;
                Double result1 = b.Length();
                Assert.That(result1, Is.EqualTo(expected).Within(epsilon));

                // The normalise function takes both a ref and out parameter,
                // need to check that if we pass in the same value as both
                // parameters we get the same results.
                Vector3 c = a;
                Vector3.Normalise(ref c, out c);
                Double result2 = c.Length();
                Assert.That(result2, Is.EqualTo(expected).Within(epsilon));
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Normalise method yeilds a vector, which when multipled by the
        /// length of the original vector results in the same vector as the
        /// original vector;
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_iii ()
        {
            Double epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector3 a = GetNextRandomVector3();
                Double l = a.Length();
                Vector3 expected = a;

                Vector3 b; Vector3.Normalise(ref a, out b);
                Vector3 result1 = b * l;
                AssertEqualWithinReason(result1, expected);

                Vector3 c = a;

                // The normalise function takes both a ref and out parameter,
                // need to check that if we pass in the same value as both
                // parameters we get the same results.
                Vector3.Normalise(ref c, out c);
                Vector3 result2 = c * l;
                AssertEqualWithinReason(result2, expected);
            }
        }

        // Test Static Fn: Cross //-------------------------------------------//
        [Test]
        public void TestStaticFn_Cross_i ()
        {
            Assert.That(true, Is.EqualTo(false));
        }

        // Test Static Fn: Reflect //-----------------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the Reflect method
        /// yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_Reflect_i ()
        {
            {
                Vector3 incident = new Vector3(20, -5, 10);

                Vector3 normal = new Vector3(1, -1, 2);
                Vector3.Normalise(ref normal, out normal);

                Vector3 expected = new Vector3(-5, 20, 2);
                Vector3 result;
                Vector3.Reflect(ref incident, ref normal, out result);

                AssertEqualWithinReason(result, expected);
            }

            {
                Vector3 incident = new Vector3(20, -5, 10);

                Vector3 normal = new Vector3(2, -1, 2);
                Vector3.Normalise(ref normal, out normal);

                Vector3 expected = new Vector3(-16, 13, 2);
                Vector3 result;
                Vector3.Reflect(ref incident, ref normal, out result);

                AssertEqualWithinReason(result, expected);
            }

            {
                Vector3 incident = Vector3.Zero;

                Vector3 normal = new Vector3(0, 0, 1);

                Vector3 result;
                Vector3.Reflect(ref incident, ref normal, out result);

                AssertEqualWithinReason(result, Vector3.Zero);
            }
        }


        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Reflect method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Reflect_ii ()
        {
            Double epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector3 a = GetNextRandomVector3();

                Vector3 b = GetNextRandomVector3();

                Vector3.Normalise(ref b, out b);

                Vector3 result;
                Vector3.Reflect(ref a, ref b, out result);

                Double dot;
                Vector3.Dot(ref a, ref b, out dot);

                Vector3 expected = a - (2 * dot * b);

                AssertEqualWithinReason(result, expected);
            }
        }

        /// <summary>
        /// Assert that an argument exception is thrown if the value passed in
        /// to the normal parameter is not normalised.
        /// </summary>
        [Test]
        public void TestStaticFn_Reflect_iii ()
        {
            Vector3 incident = GetNextRandomVector3();
            Vector3 normal = new Vector3(12, -241, 123);

            Vector3 result;

            Assert.Throws(
                typeof(ArgumentOutOfRangeException),
                () =>
                Vector3.Reflect(ref incident, ref normal, out result)
            );
        }

        // Test Static Fn: TransformMatrix44 //-------------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformMatix44_i ()
        {
            Vector3 position = new Vector3 (10, 50, -20);

            Single pi; RealMaths.Pi (out pi);
            Single tau; RealMaths.Tau (out tau);

            Matrix44 rotmati = Matrix44.Identity;
            Matrix44 rotmatx; Matrix44.CreateRotationX(pi, out rotmatx);
            Matrix44 rotmaty; Matrix44.CreateRotationY(tau, out rotmaty);
            Matrix44 rotmatz; Matrix44.CreateRotationZ(-pi, out rotmatz);
            Matrix44 rotmatxyz = rotmatx * rotmaty * rotmatz;

            Vector3 expected1 = new Vector3 ( 10,  50, -20);
            Vector3 expected2 = new Vector3 ( 10, -50,  20);
            Vector3 expected3 = new Vector3 ( 10,  50, -20);
            Vector3 expected4 = new Vector3 (-10, -50, -20);
            Vector3 expected5 = new Vector3 (-10,  50,  20);

            Vector3 test1; Vector3.Transform (ref position, ref rotmati, out test1);
            Vector3 test2; Vector3.Transform (ref position, ref rotmatx, out test2);
            Vector3 test3; Vector3.Transform (ref position, ref rotmaty, out test3);
            Vector3 test4; Vector3.Transform (ref position, ref rotmatz, out test4);
            Vector3 test5; Vector3.Transform (ref position, ref rotmatxyz, out test5);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
            AssertEqualWithinReason(test5, expected5);
        }

        // Test Static Fn: TransformNormal //---------------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformNormal_i ()
        {
            Vector3 position = new Vector3 (10, 50, -20);
            Vector3.Normalise (ref position, out position);

            Single pi; RealMaths.Pi (out pi);
            Single tau; RealMaths.Tau (out tau);

            Matrix44 rotmati = Matrix44.Identity;
            Matrix44 rotmatx; Matrix44.CreateRotationX(pi, out rotmatx);
            Matrix44 rotmaty; Matrix44.CreateRotationY(tau, out rotmaty);
            Matrix44 rotmatz; Matrix44.CreateRotationZ(-pi, out rotmatz);
            Matrix44 rotmatxyz = rotmatx * rotmaty * rotmatz;

            Vector3 expected1 = new Vector3 ( 10,  50, -20);
            Vector3 expected2 = new Vector3 ( 10, -50,  20);
            Vector3 expected3 = new Vector3 ( 10,  50, -20);
            Vector3 expected4 = new Vector3 (-10, -50, -20);
            Vector3 expected5 = new Vector3 (-10,  50,  20);

            Vector3.Normalise (ref expected1, out expected1);
            Vector3.Normalise (ref expected2, out expected2);
            Vector3.Normalise (ref expected3, out expected3);
            Vector3.Normalise (ref expected4, out expected4);
            Vector3.Normalise (ref expected5, out expected5);

            Vector3 test1; Vector3.TransformNormal (ref position, ref rotmati, out test1);
            Vector3 test2; Vector3.TransformNormal (ref position, ref rotmatx, out test2);
            Vector3 test3; Vector3.TransformNormal (ref position, ref rotmaty, out test3);
            Vector3 test4; Vector3.TransformNormal (ref position, ref rotmatz, out test4);
            Vector3 test5; Vector3.TransformNormal (ref position, ref rotmatxyz, out test5);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
            AssertEqualWithinReason(test5, expected5);

            // should also work with the standard transform fn
            Vector3 test1n; Vector3.TransformNormal (ref position, ref rotmati, out test1n);
            Vector3 test2n; Vector3.TransformNormal (ref position, ref rotmatx, out test2n);
            Vector3 test3n; Vector3.TransformNormal (ref position, ref rotmaty, out test3n);
            Vector3 test4n; Vector3.TransformNormal (ref position, ref rotmatz, out test4n);
            Vector3 test5n; Vector3.TransformNormal (ref position, ref rotmatxyz, out test5n);

            AssertEqualWithinReason(test1n, expected1);
            AssertEqualWithinReason(test2n, expected2);
            AssertEqualWithinReason(test3n, expected3);
            AssertEqualWithinReason(test4n, expected4);
            AssertEqualWithinReason(test5n, expected5);
        }

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformNormal_ii ()
        {
            Matrix44 rotmat = Matrix44.Identity;
            Vector3 normal = new Vector3 (21, -532, 0);
            Vector3 result;
            Assert.Throws(
                typeof(ArgumentOutOfRangeException),
                () =>
                Vector3.TransformNormal(ref normal, ref rotmat, out result)
            );
        }

        // Test Static Fn: TransformQuaternion //-----------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformQuaternion_i ()
        {
            Vector3 position = new Vector3 (10, 50, -20);

            Single pi;
            RealMaths.Pi (out pi);

            Quaternion quatmati = new Quaternion (0, 0, 0, 1);
            Quaternion quatmatx = new Quaternion (1, 0, 0, 0);
            Quaternion quatmaty = new Quaternion (0, 0, 0, 1);
            Quaternion quatmatz = new Quaternion (0, 0, 1, 0);
            Quaternion quatmatxyz = new Quaternion (0, 1, 0, 0);

            Vector3 expected1 = new Vector3 ( 10,  50, -20);
            Vector3 expected2 = new Vector3 ( 10, -50,  20);
            Vector3 expected3 = new Vector3 ( 10,  50, -20);
            Vector3 expected4 = new Vector3 (-10, -50, -20);
            Vector3 expected5 = new Vector3 (-10,  50,  20);

            Vector3 test1; Vector3.Transform (ref position, ref quatmati, out test1);
            Vector3 test2; Vector3.Transform (ref position, ref quatmatx, out test2);
            Vector3 test3; Vector3.Transform (ref position, ref quatmaty, out test3);
            Vector3 test4; Vector3.Transform (ref position, ref quatmatz, out test4);
            Vector3 test5; Vector3.Transform (ref position, ref quatmatxyz, out test5);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
            AssertEqualWithinReason(test5, expected5);
        }

        // Test Operator: Equality //-----------------------------------------//

        /// <summary>
        /// Helper method for testing equality.
        /// </summary>
        void TestEquality (Vector3 a, Vector3 b, Boolean expected )
        {
            // This test asserts the following:
            //   (a == b) == expected
            //   (b == a) == expected
            //   (a != b) == !expected
            //   (b != a) == !expected

            Boolean result_1a = (a == b);
            Boolean result_1b = (a.Equals(b));
            Boolean result_1c = (a.Equals((Object)b));
            
            Boolean result_2a = (b == a);
            Boolean result_2b = (b.Equals(a));
            Boolean result_2c = (b.Equals((Object)a));

            Boolean result_3a = (a != b);
            Boolean result_4a = (b != a);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_1c, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
            Assert.That(result_2c, Is.EqualTo(expected));
            Assert.That(result_3a, Is.EqualTo(!expected));
            Assert.That(result_4a, Is.EqualTo(!expected));
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of TRUE when two equal  
        /// Vector3 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_i ()
        {
            var a = new Vector3(44, -54, -22);
            var b = new Vector3(44, -54, -22);

            Boolean expected = true;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of FALSE when two unequal  
        /// Vector3 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_ii ()
        {
            var a = new Vector3(44, 54, 2);
            var b = new Vector3(44, -54, 2);

            Boolean expected = false;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Tests to make sure that all the equality opperators and functions 
        /// yield the expected result of TRUE when used on a number of randomly 
        /// generated pairs of equal Vector3 objects.
        /// </summary>
        [Test]
        public void TestOperator_Equality_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();

                Vector3 b = a;

                this.TestEquality(a, b, true);
            }
        }


        // Test Operator: Addition //-----------------------------------------//

        /// <summary>
        /// Helper method for testing addition.
        /// </summary>
        void TestAddition (Vector3 a, Vector3 b, Vector3 expected )
        {
            // This test asserts the following:
            //   a + b == expected
            //   b + a == expected

            var result_1a = a + b;
            var result_2a = b + a;

            Vector3 result_1b; Vector3.Add(ref a, ref b, out result_1b);
            Vector3 result_2b; Vector3.Add(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the addition opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_i ()
        {
            var a = new Vector3(3, -6, 44);
            var b = new Vector3(-6, 12, 18);

            var expected = new Vector3(-3, 6, 62);

            this.TestAddition(a, b, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving the zero vector, all the 
        /// addition opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_ii ()
        {
            var a = new Vector3(-2313, 88, 199);

            var expected = a;

            this.TestAddition(a, Vector3.Zero, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving two zero vectors, all the 
        /// addition opperators and functions yield the correct result of zero.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iii ()
        {
            this.TestAddition(Vector3.Zero, Vector3.Zero, Vector3.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// addition opperators and functions yield the same results as a
        /// manual addition calculation.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();
                var b = GetNextRandomVector3();

                var expected = new Vector3(
                    a.X + b.X, a.Y + b.Y, a.Z + b.Z);

                this.TestAddition(a, b, expected);
            }
        }

        // Test Operator: Subtraction //--------------------------------------//
        
        /// <summary>
        /// Helper method for testing subtraction.
        /// </summary>
        void TestSubtraction (Vector3 a, Vector3 b, Vector3 expected )
        {
            // This test asserts the following:
            //   a - b == expected
            //   b - a == -expected

            var result_1a = a - b;
            var result_2a = b - a;

            Vector3 result_1b; Vector3.Subtract(ref a, ref b, out result_1b);
            Vector3 result_2b; Vector3.Subtract(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(-expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(-expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the subtraction opperators
        /// and functions yield the correct result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_i ()
        {
            var a = new Vector3(12, -4, 14);
            var b = new Vector3(15, 11, 7);
            var expected = new Vector3(-3, -15, 7);
            this.TestSubtraction(a, b, expected);

            var c = new Vector3(-423, 342, 7);
            this.TestSubtraction(c, Vector3.Zero, c);
        }

        /// <summary>
        /// Assert that when subtracting the zero vector fromt the zero vector, 
        /// all the subtraction opperators and functions yield the correct 
        /// result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_ii ()
        {
            this.TestSubtraction(Vector3.Zero, Vector3.Zero, Vector3.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// subtraction opperators and functions yield the same results as a
        /// manual subtraction calculation.
        /// </summary>
        [Test]
        public void TestOperator_Subtraction_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();
                var b = GetNextRandomVector3();

                var expected = new Vector3(a.X - b.X, a.Y - b.Y, a.Z - b.Z);

                this.TestSubtraction(a, b, expected);
            }
        }

        // Test Operator: Negation //-----------------------------------------//
        
        /// <summary>
        /// Helper method for testing negation.
        /// </summary>
        void TestNegation (Vector3 a, Vector3 expected )
        {
            // This test asserts the following:
            //   -a == expected

            var result_1a = -a;

            Vector3 result_1b; Vector3.Negate(ref a, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the negation opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_i ()
        {
            Double r = 3432;
            Double s = -6218;
            Double t = -3432;
            Double u = 6218;

            var a = new Vector3(r, s, t);
            var b = new Vector3(u, t, s);
            var c = new Vector3(t, u, r);
            var d = new Vector3(s, r, u);

            this.TestNegation(a, c);
            this.TestNegation(b, d);
        }

        /// <summary>
        /// Assert that, for known examples involving the zero vector, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_ii ()
        {
            Double t = -3432;
            Double u = 6218;
            Double r = 3432;
            Double s = -6218;

            var c = new Vector3(t, u, r);
            var d = new Vector3(s, r, u);

            this.TestNegation(c, Vector3.Zero - c);
            this.TestNegation(d, Vector3.Zero - d);
        }

        /// <summary>
        /// Assert that when negating the zero vector, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iii ()
        {
            this.TestNegation(Vector3.Zero, Vector3.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// negation opperators and functions yield the same results as a
        /// manual negation calculation.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();
                this.TestNegation(a, Vector3.Zero - a);
            }
        }

        // Test Operator: Multiplication //-----------------------------------//

        /// <summary>
        /// Helper method for testing multiplication.
        /// </summary>
        void TestMultiplication (Vector3 a, Vector3 b, Vector3 expected )
        {
            // This test asserts the following:
            //   a * b == expected
            //   b * a == expected

            var result_1a = a * b;
            var result_2a = b * a;

            Vector3 result_1b; Vector3.Multiply(ref a, ref b, out result_1b);
            Vector3 result_2b; Vector3.Multiply(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the multiplication opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_i ()
        {
            Double r = -27;
            Double s = 36;
            Double t = 9;

            Double x = 3;
            Double y = 6;
            Double z = -9;

            var a = new Vector3(x, y, x);
            var b = new Vector3(z, y, x);
            var c = new Vector3(r, s, t);

            this.TestMultiplication(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// multiplication opperators and functions yield the same results as a
        /// manual multiplication calculation.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();
                var b = GetNextRandomVector3();

                var c = new Vector3(a.X * b.X, a.Y * b.Y, a.Z * b.Z);

                this.TestMultiplication(a, b, c);
            }
        }


        // Test Operator: Division //-----------------------------------------//

        /// <summary>
        /// Helper method for testing division.
        /// </summary>
        void TestDivision (Vector3 a, Vector3 b, Vector3 expected )
        {
            // This test asserts the following:
            //   a / b == expected

            var result_1a = a / b;

            Vector3 result_1b; Vector3.Divide(ref a, ref b, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example using whole numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_i ()
        {
            Double r = 10;
            Double s = -40;
            Double t = 1;

            Double x = 2000;
            Double y = 200;
            Double z = -5;

            var a = new Vector3(x, y, x);
            var b = new Vector3(y, z, x);
            var c = new Vector3(r, s, t);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a known example using fractional numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_ii ()
        {
            Double t = ((Double) 1 ) / ((Double) 10);
            Double u = ((Double) (-1) ) / ((Double) 40 );
            Double v = -20;
            Double w = 100;
            Double x = 2000;
            Double y = 200;
            Double z = -5;

            var a = new Vector3(y, z, w);
            var b = new Vector3(x, y, z);
            var c = new Vector3(t, u, v);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// division opperators and functions yield the same results as a
        /// manual addition division.
        /// </summary>
        [Test]
        public void TestOperator_Division_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();
                var b = GetNextRandomVector3();

                var c = new Vector3(a.X / b.X, a.Y / b.Y, a.Z / b.Z);

                this.TestDivision(a, b, c);
            }
        }

        // Test Static Fn: SmoothStep //--------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();
                var b = GetNextRandomVector3();

                Double amount1 = 0;
                Vector3 result1;

                Vector3.SmoothStep (
                    ref a, ref b, amount1, out result1);

                AssertEqualWithinReason(result1, a);

                Double amount2 = 1;
                Vector3 result2;

                Vector3.SmoothStep (
                    ref a, ref b, amount2, out result2);

                AssertEqualWithinReason(result2, b);
            }
        }

        /// <summary>
        /// Assert that, for known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_ii ()
        {
            var a = GetNextRandomVector3();
            var b = GetNextRandomVector3();

            Double half; RealMaths.Half(out half);

            var tests = new Double[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector3 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector3.SmoothStep (
                            ref a, ref b, amount, out result)
                    );
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_iii ()
        {
            var a = new Vector3( -30, -30, -30 );
            var b = new Vector3( +30, +30, +30 );

            Double one = 1;

            Double i;
            RealMaths.FromFraction(1755, 64, out i); // 27.421875
            
            Double j;
            RealMaths.FromFraction( 165,  8, out j); // 20.625
            
            Double k;
            RealMaths.FromFraction( 705, 64, out k); // 11.015625

            Double a0 = 0;
            Double a1 = (one * 1) / 8;
            Double a2 = (one * 2) / 8;
            Double a3 = (one * 3) / 8;
            Double a4 = (one * 4) / 8;
            Double a5 = (one * 5) / 8;
            Double a6 = (one * 6) / 8;
            Double a7 = (one * 7) / 8;
            Double a8 = 1;

            Vector3 r0 = a;
            Vector3 r1 = new Vector3( -i, -i, -i );
            Vector3 r2 = new Vector3( -j, -j, -j );
            Vector3 r3 = new Vector3( -k, -k, -k );
            Vector3 r4 = Vector3.Zero;
            Vector3 r5 = new Vector3(  k,  k,  k );
            Vector3 r6 = new Vector3(  j,  j,  j );
            Vector3 r7 = new Vector3(  i,  i,  i );
            Vector3 r8 = b;

            var knownResults = new List<Tuple<Double, Vector3>>
            {
                new Tuple<Double, Vector3>( a0, r0 ),
                new Tuple<Double, Vector3>( a1, r1 ),
                new Tuple<Double, Vector3>( a2, r2 ),
                new Tuple<Double, Vector3>( a3, r3 ),
                new Tuple<Double, Vector3>( a4, r4 ),
                new Tuple<Double, Vector3>( a5, r5 ),
                new Tuple<Double, Vector3>( a6, r6 ),
                new Tuple<Double, Vector3>( a7, r7 ),
                new Tuple<Double, Vector3>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector3 result;

                Vector3.SmoothStep (
                    ref a, ref b, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        // Test Static Fn: CatmullRom //--------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();
                var b = GetNextRandomVector3();
                var c = GetNextRandomVector3();
                var d = GetNextRandomVector3();

                Double amount1 = 0;
                Vector3 result1;

                Vector3.CatmullRom (
                    ref a, ref b, ref c, ref d, amount1, out result1);

                AssertEqualWithinReason(result1, b);

                Double amount2 = 1;
                Vector3 result2;

                Vector3.CatmullRom (
                    ref a, ref b, ref c, ref d, amount2, out result2);

                AssertEqualWithinReason(result2, c);
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_ii ()
        {
            var a = new Vector3( -90, +30, +90 );
            var b = new Vector3( -30, -30, +30 );
            var c = new Vector3( +30, +30, -30 );
            var d = new Vector3( +90, -30, -90 );

            Double one = 1;

            Double u = 15;
            Double v = (Double) 165  / (Double)  8; // 20.5
            Double w = (Double) 45   / (Double)  2; // 20.625
            Double x = (Double) 1755 / (Double) 64; // 27.421875
            Double y = (Double) 15   / (Double)  2; // 14.5
            Double z = (Double) 705  / (Double) 64; // 11.015625

            Double a0 = 0;
            Double a1 = (one * 1) / 8;
            Double a2 = (one * 2) / 8;
            Double a3 = (one * 3) / 8;
            Double a4 = (one * 4) / 8;
            Double a5 = (one * 5) / 8;
            Double a6 = (one * 6) / 8;
            Double a7 = (one * 7) / 8;
            Double a8 = 1;

            Vector3 r0 = b;
            Vector3 r1 = new Vector3( -w, -x,  w );
            Vector3 r2 = new Vector3( -u, -v,  u );
            Vector3 r3 = new Vector3( -y, -z,  y );
            Vector3 r4 = Vector3.Zero;
            Vector3 r5 = new Vector3(  y,  z, -y );
            Vector3 r6 = new Vector3(  u,  v, -u );
            Vector3 r7 = new Vector3(  w,  x, -w );
            Vector3 r8 = c;

            var knownResults = new List<Tuple<Double, Vector3>>
            {
                new Tuple<Double, Vector3>( a0, r0 ),
                new Tuple<Double, Vector3>( a1, r1 ),
                new Tuple<Double, Vector3>( a2, r2 ),
                new Tuple<Double, Vector3>( a3, r3 ),
                new Tuple<Double, Vector3>( a4, r4 ),
                new Tuple<Double, Vector3>( a5, r5 ),
                new Tuple<Double, Vector3>( a6, r6 ),
                new Tuple<Double, Vector3>( a7, r7 ),
                new Tuple<Double, Vector3>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector3 result;

                Vector3.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_iii ()
        {
            var a = GetNextRandomVector3();
            var b = GetNextRandomVector3();
            var c = GetNextRandomVector3();
            var d = GetNextRandomVector3();
            
            Double half; RealMaths.Half(out half);

            var tests = new Double[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector3 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector3.CatmullRom (
                            ref a, ref b, ref c, ref d, amount, out result)
                );
            }
        }

        /// <summary>
        /// This tests compares results against an example where all the control
        /// points are in a straight line.  In this case the resulting spline
        /// should be a straight line.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_iv ()
        {
            var a = new Vector3( -90, -90, +90 );
            var b = new Vector3( -30, -30, +30 );
            var c = new Vector3( +30, +30, -30 );
            var d = new Vector3( +90, +90, -90 );

            Double one = 1;

            Double a0 = 0;
            Double a1 = (one * 1) / 4;
            Double a2 = (one * 2) / 4;
            Double a3 = (one * 3) / 4;
            Double a4 = 1;

            Vector3 r0 = b;
            Vector3 r1 = new Vector3( -15, -15,  15 );
            Vector3 r2 = Vector3.Zero;
            Vector3 r3 = new Vector3(  15,  15, -15 );
            Vector3 r4 = c;

            var knownResults = new List<Tuple<Double, Vector3>>
            {
                new Tuple<Double, Vector3>( a0, r0 ),
                new Tuple<Double, Vector3>( a1, r1 ),
                new Tuple<Double, Vector3>( a2, r2 ),
                new Tuple<Double, Vector3>( a3, r3 ),
                new Tuple<Double, Vector3>( a4, r4 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector3 result;

                Vector3.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        // Test Static Fn: Hermite //-----------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a  = GetNextRandomVector3();
                var b  = GetNextRandomVector3();

                var c = GetNextRandomVector3();
                var d = GetNextRandomVector3();

                Vector3 an; Vector3.Normalise(ref c, out an);
                Vector3 bn; Vector3.Normalise(ref d, out bn);

                Double amount1 = 0;
                Vector3 result1;

                Vector3.Hermite (
                    ref a, ref an, ref b, ref bn, amount1, out result1);

                AssertEqualWithinReason(result1, a);

                Double amount2 = 1;
                Vector3 result2;

                Vector3.Hermite (
                    ref a, ref an, ref b, ref bn, amount2, out result2);

                AssertEqualWithinReason(result2, b);
            }
        }

        /// <summary>
        /// Assert that, for known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_ii ()
        {
            var a = GetNextRandomVector3();
            var b = GetNextRandomVector3();
            var c = GetNextRandomVector3();
            var d = GetNextRandomVector3();

            Vector3 an; Vector3.Normalise(ref c, out an);
            Vector3 bn; Vector3.Normalise(ref d, out bn);

            Double half; RealMaths.Half(out half);

            var tests = new Double[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector3 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector3.Hermite (
                            ref a, ref an, ref b, ref bn, amount, out result)
                    );
                
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_iii ()
        {
            var a = new Vector3( -100, +50, +100 );
            var b = new Vector3( +100, -50, -100 );

            var c = new Vector3( -10, +5, +10 );
            var d = new Vector3( +10, -5, -10 );

            Vector3 an; Vector3.Normalise(ref c, out an);
            Vector3 bn; Vector3.Normalise(ref d, out bn);

            Double one = 1;
            
            // 100.1953125
            Double e = (Double) 51300 / (Double) 512;

            // 50.09765625
            Double f = (Double) 12825 / (Double) 256;

            // 91.25
            Double g = (Double) 365 / (Double) 4;

            // 45.625
            Double h = (Double) 365 / (Double) 8;

            // 75.7421875
            Double i = (Double) 9695 / (Double) 128;

            // 37.87109375
            Double j = (Double) 9695 / (Double) 256;

            // 56.25
            Double k = (Double) 225 / (Double) 4;

            // 28.125
            Double l = (Double) 225 / (Double) 8;

            // 35.3515625
            Double m = (Double) 4525 / (Double) 128;

            // 17.67578125
            Double n = (Double) 4525 / (Double) 256;

            // 15.625
            Double o = (Double) 125 / (Double) 8;

            // 7.8125
            Double p = (Double) 125 / (Double) 16;

            // 0.3515625
            Double q = (Double) 45 / (Double) 128;

            // 0.17578125
            Double r = (Double) 45 / (Double) 256;

            Double a0 = 0;
            Double a1 = (one * 1) / 8;
            Double a2 = (one * 2) / 8;
            Double a3 = (one * 3) / 8;
            Double a4 = (one * 4) / 8;
            Double a5 = (one * 5) / 8;
            Double a6 = (one * 6) / 8;
            Double a7 = (one * 7) / 8;
            Double a8 = 1;

            Vector3 r0 = b;
            Vector3 r1 = new Vector3(  e, -f, -e );
            Vector3 r2 = new Vector3(  g, -h, -g );
            Vector3 r3 = new Vector3(  i, -j, -i );
            Vector3 r4 = new Vector3(  k, -l, -k );
            Vector3 r5 = new Vector3(  m, -n, -m );
            Vector3 r6 = new Vector3(  o, -p, -o );
            Vector3 r7 = new Vector3( -q,  r,  q );
            Vector3 r8 = c;

            var knownResults = new List<Tuple<Double, Vector3>>
            {
                new Tuple<Double, Vector3>( a0, r0 ),
                new Tuple<Double, Vector3>( a1, r1 ),
                new Tuple<Double, Vector3>( a2, r2 ),
                new Tuple<Double, Vector3>( a3, r3 ),
                new Tuple<Double, Vector3>( a4, r4 ),
                new Tuple<Double, Vector3>( a5, r5 ),
                new Tuple<Double, Vector3>( a6, r6 ),
                new Tuple<Double, Vector3>( a7, r7 ),
                new Tuple<Double, Vector3>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector3 result;

                Vector3.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

                /// <summary>
        /// Assert that, running the Min function on a number of randomly
        /// generated pairs of Vector3 objects, yields the same results as those
        /// obtained from performing a manual Min calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Min ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector3 a = GetNextRandomVector3();
                Vector3 b = a * 2;

                Vector3 result;
                Vector3.Min (ref a, ref b, out result);

                Assert.That(result.X, Is.EqualTo(a.X < b.X ? a.X : b.X ));
                Assert.That(result.Y, Is.EqualTo(a.Y < b.Y ? a.Y : b.Y ));
                Assert.That(result.Z, Is.EqualTo(a.Z < b.Z ? a.Z : b.Z ));
            }
        }

        /// <summary>
        /// Assert that, running the Max function on a number of randomly
        /// generated pairs of Vector3 objects, yields the same results as those
        /// obtained from performing a manual Max calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Max ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector3 a = GetNextRandomVector3();
                Vector3 b = GetNextRandomVector3();

                Vector3 result;
                Vector3.Max (ref a, ref b, out result);

                Assert.That(result.X, Is.EqualTo(a.X > b.X ? a.X : b.X ));
                Assert.That(result.Y, Is.EqualTo(a.Y > b.Y ? a.Y : b.Y ));
                Assert.That(result.Z, Is.EqualTo(a.Z > b.Z ? a.Z : b.Z ));
            }
        }

        /// <summary>
        /// Assert that, running the Clamp function on a number of randomly
        /// generated Vector3 objects for a given min-max range, yields
        /// results that fall within that range.
        /// </summary>
        [Test]
        public void TestStaticFn_Clamp_i ()
        {
            Vector3 min = new Vector3(-30, 1, 18);
            Vector3 max = new Vector3(32, 130, 47);

            for(Int32 i = 0; i < 100; ++i)
            {
                Vector3 a = GetNextRandomVector3();

                Vector3 result;
                Vector3.Clamp (ref a, ref min, ref max, out result);

                Assert.That(result.X, Is.LessThanOrEqualTo(max.X));
                Assert.That(result.Y, Is.LessThanOrEqualTo(max.Y));
                Assert.That(result.X, Is.GreaterThanOrEqualTo(min.X));
                Assert.That(result.Y, Is.GreaterThanOrEqualTo(min.Y));
            }
        }

        /// <summary>
        /// Assert that, running the Clamp function on an a Vector3 object known
        /// to fall outside of a given min-max range, yields a result that fall 
        /// within that range.
        /// </summary>
        [Test]
        public void TestStaticFn_Clamp_ii ()
        {
            Vector3 min = new Vector3(-30, 1, 18);
            Vector3 max = new Vector3(32, 130, 47);

            Vector3 a = new Vector3(-100, 1113, 50);

            Vector3 expected = new Vector3(-30, 130, 47);

            Vector3 result;
            Vector3.Clamp (ref a, ref min, ref max, out result);

            Assert.That(result.X, Is.LessThanOrEqualTo(max.X));
            Assert.That(result.Y, Is.LessThanOrEqualTo(max.Y));
            Assert.That(result.Z, Is.LessThanOrEqualTo(max.Z));
            Assert.That(result.X, Is.GreaterThanOrEqualTo(min.X));
            Assert.That(result.Y, Is.GreaterThanOrEqualTo(min.Y));
            Assert.That(result.Z, Is.GreaterThanOrEqualTo(min.Z));

            AssertEqualWithinReason(result, expected);

        }

        /// <summary>
        /// Assert that, running the Lerp function on a number of randomly
        /// generated pairs of Vector3 objects for a range of weighting amounts, 
        /// yields the same results as those obtained from performing a manual 
        /// Lerp calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_i ()
        {
            for(Int32 j = 0; j < 100; ++j)
            {
                Double delta = j;

                delta = delta / 100;

                for(Int32 i = 0; i < 100; ++i)
                {
                    Vector3 a = GetNextRandomVector3();
                    Vector3 b = GetNextRandomVector3();

                    Vector3 result;
                    Vector3.Lerp (ref a, ref b, delta, out result);

                    Vector3 expected = a + ( ( b - a ) * delta );

                    AssertEqualWithinReason(result, expected);
                }
            }
        }

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_ii ()
        {
            Vector3 a = GetNextRandomVector3();
            Vector3 b = GetNextRandomVector3();

            Double half; RealMaths.Half(out half);

            var tests = new Double[] { 2, half + 1, -half, -1 };

            foreach( var weighting in tests )
            {
                Vector3 result; 
                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector3.Lerp (
                            ref a, ref b, weighting, out result)
                    );
            }
        }


    }    /// <summary>
    /// 
    /// </summary>
    [TestFixture]
    public class Vector4Tests
    {
        /// <summary>
        /// The random number generator used for testing.
        /// </summary>
        static readonly System.Random rand;

        /// <summary>
        /// Static constructor used to ensure that the random number generator
        /// always gets initilised with the same seed, making the tests
        /// behave in a deterministic manner.
        /// </summary>
        static Vector4Tests ()
        {
            rand = new System.Random(0);
        }

        /// <summary>
        /// Helper function for getting the next random Double value.
        /// </summary>
        static Double GetNextRandomDouble ()
        {
            Double randomValue = rand.NextDouble();

            Double zero = 0;
            Double multiplier = 1000;

            randomValue *= multiplier;

            Boolean randomBoolean = (rand.Next(0, 1) == 0) ? true : false;

            if( randomBoolean )
                randomValue = zero - randomValue;

            return randomValue;
        }

        /// <summary>
        /// Helper function for getting the next random Vector4.
        /// </summary>
        static Vector4 GetNextRandomVector4 ()
        {
            Double a = GetNextRandomDouble();
            Double b = GetNextRandomDouble();
            Double c = GetNextRandomDouble();
            Double d = GetNextRandomDouble();

            return new Vector4(a, b, c, d);
        }

        /// <summary>
        /// Helper to encapsulate asserting that two Vector4s are equal.
        /// </summary>
        static void AssertEqualWithinReason (Vector4 a, Vector4 b)
        {
            Double tolerance; RealMaths.TestTolerance(out tolerance);

            Assert.That(a.X, Is.EqualTo(b.X).Within(tolerance));
            Assert.That(a.Y, Is.EqualTo(b.Y).Within(tolerance));
            Assert.That(a.Z, Is.EqualTo(b.Z).Within(tolerance));
            Assert.That(a.W, Is.EqualTo(b.W).Within(tolerance));
        }
        

        // Test: StructLayout //----------------------------------------------//

        /// <summary>
        /// This test makes sure that the struct layout has been defined
        /// correctly.
        /// </summary>
        [Test]
        public void Test_StructLayout_i ()
        {
            Type t = typeof(Vector4);

            Assert.That(
                t.StructLayoutAttribute.Value, 
                Is.EqualTo(LayoutKind.Sequential));
        }

        /// <summary>
        /// This test makes sure that when examining the memory addresses of the 
        /// X, Y, Z and W member variables of a number of randomly generated 
        /// Vector4 objects the results are as expected. 
        /// </summary>
        [Test]
        public unsafe void Test_StructLayout_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector4 vec = GetNextRandomVector4();

                GCHandle h_vec = GCHandle.Alloc(vec, GCHandleType.Pinned);

                IntPtr vecAddress = h_vec.AddrOfPinnedObject();

                Double[] data = new Double[4];

                // nb: when Fixed32 and Half are moved back into the main
                //     dev branch there will be need for an extension method for
                //     Marshal that will perform the copy for those types. 
                MarshalHelper.Copy(vecAddress, data, 0, 4);
                Assert.That(data[0], Is.EqualTo(vec.X));
                Assert.That(data[1], Is.EqualTo(vec.Y));
                Assert.That(data[2], Is.EqualTo(vec.Z));
                Assert.That(data[3], Is.EqualTo(vec.W));
                
                h_vec.Free();
            }
        }

        // Test: Constructors //----------------------------------------------//

        /// <summary>
        /// This test goes though each public constuctor and ensures that the 
        /// data members of the structure have been properly set.
        /// </summary>
        [Test]
        public void Test_Constructors_i ()
        {
            {
                // Test default values
                Vector4 a = new Vector4();
                Assert.That(a, Is.EqualTo(Vector4.Zero));
            }
            {
                // Test Vector4( Double, Double, Double )
                Double a = -189;
                Double b = 429;
                Double c = 4298;
                Double d = 341;
                Vector4 e = new Vector4(a, b, c, d);
                Assert.That(e.X, Is.EqualTo(a));
                Assert.That(e.Y, Is.EqualTo(b));
                Assert.That(e.Z, Is.EqualTo(c));
                Assert.That(e.W, Is.EqualTo(d));
            }
            {
                // Test Vector4( Vector2, Double, Double )
                Vector2 a = new Vector2(-189, 429);
                Double b = 4298;
                Double c = 341;
                Vector4 d = new Vector4(a, b, c);
                Assert.That(d.X, Is.EqualTo(a.X));
                Assert.That(d.Y, Is.EqualTo(a.Y));
                Assert.That(d.Z, Is.EqualTo(b));
                Assert.That(d.W, Is.EqualTo(c));
            }
            {
                // Test Vector4( Vector3, Double )
                Vector3 a = new Vector3(-189, 429, 4298);
                Double b = 341;
                Vector4 c = new Vector4(a, b);
                Assert.That(c.X, Is.EqualTo(a.X));
                Assert.That(c.Y, Is.EqualTo(a.Y));
                Assert.That(c.Z, Is.EqualTo(a.Z));
                Assert.That(c.W, Is.EqualTo(b));
            }
            {
                // Test no constructor
                Vector4 a;
                a.X = 0;
                a.Y = 0;
                a.Z = 0;
                a.W = 0;
                Assert.That(a, Is.EqualTo(Vector4.Zero));
            }
        }

        // Test Member Fn: ToString //----------------------------------------//

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i ()
        {
            Vector4 a = new Vector4(42, -17, 13, 44);

            String result = a.ToString();

            String expected = "{X:42 Y:-17 Z:13 W:44}";

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: GetHashCode //-------------------------------------//

        /// <summary>
        /// Makes sure that the hashing function is good by testing 10,000
        /// random scenarios and ensuring that there are no more than 10
        /// collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            var hs1 = new System.Collections.Generic.HashSet<Vector4>();
            var hs2 = new System.Collections.Generic.HashSet<Int32>();

            for(Int32 i = 0; i < 10000; ++i)
            {
                var a = GetNextRandomVector4();

                hs1.Add(a);
                hs2.Add(a.GetHashCode());
            }

            Assert.That(hs1.Count, Is.EqualTo(hs2.Count).Within(10));
        }

        // Test Member Fn: Length //------------------------------------------//

        /// <summary>
        /// Tests that for a known example the Length member function yields
        /// the correct result.
        /// </summary>
        [Test]
        public void TestMemberFn_Length_i ()
        {
            Vector4 a = new Vector4(3, -4, 12, 84);

            Double expected = 85;

            Double result = a.Length();

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: LengthSquared //-----------------------------------//

        /// <summary>
        /// Tests that for a known example the LengthSquared member function 
        /// yields the correct result.
        /// </summary>
        [Test]
        public void TestMemberFn_LengthSquared_i ()
        {
            Vector4 a = new Vector4(3, -4, 12, 84);

            Double expected = 7225;

            Double result = a.LengthSquared();

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: IsUnit //------------------------------------------//

        /// <summary>
        /// Tests that for the simple vectors the IsUnit member function
        /// returns the correct result of TRUE.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_i ()
        {
            Vector4 a = new Vector4( 1,  0,  0,  0);
            Vector4 b = new Vector4(-1,  0,  0,  0);
            Vector4 c = new Vector4( 0,  1,  0,  0);
            Vector4 d = new Vector4( 0, -1,  0,  0);
            Vector4 e = new Vector4( 0,  0,  1,  0);
            Vector4 f = new Vector4( 0,  0, -1,  0);
            Vector4 g = new Vector4( 0,  0,  0,  1);
            Vector4 h = new Vector4( 0,  0,  0, -1);
            Vector4 i = new Vector4( 1,  1,  1,  1);
            Vector4 j = new Vector4( 0,  0,  0,  0);

            Assert.That(a.IsUnit(), Is.EqualTo(true));
            Assert.That(b.IsUnit(), Is.EqualTo(true));
            Assert.That(c.IsUnit(), Is.EqualTo(true));
            Assert.That(d.IsUnit(), Is.EqualTo(true));
            Assert.That(e.IsUnit(), Is.EqualTo(true));
            Assert.That(f.IsUnit(), Is.EqualTo(true));
            Assert.That(g.IsUnit(), Is.EqualTo(true));
            Assert.That(h.IsUnit(), Is.EqualTo(true));

            Assert.That(i.IsUnit(), Is.EqualTo(false));
            Assert.That(j.IsUnit(), Is.EqualTo(false));
        }

        /// <summary>
        /// This test makes sure that the IsUnit member function returns the 
        /// correct result of TRUE for a number of scenarios where the test 
        /// vector is both random and normalised.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector4 a = GetNextRandomVector4();

                Vector4 b; Vector4.Normalise(ref a, out b);

                Assert.That(b.IsUnit(), Is.EqualTo(true));
            }
        }

        /// <summary>
        /// This test ensures that the IsUnit member function correctly
        /// returns TRUE for a collection of vectors, all known to be of unit 
        /// length.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_iii ()
        {
            Double radius = 1;

            Double pi; RealMaths.Pi(out pi);

            for( Int32 i = 0; i <= 10; ++ i)
            {
                for( Int32 j = 0; j <= 10; ++ j)
                {
                    for( Int32 k = 0; k <= 10; ++ k)
                    {
                        Double theta = 2 * pi * i / 100;
                        Double phi = 2 * pi * j / 100;
                        Double gamma = 2 * pi * k / 100;

                        Double x = 
                            RealMaths.Cos(theta) * 
                            RealMaths.Sin(phi) * 
                            RealMaths.Sin(gamma) * radius;
                        
                        Double y = 
                            RealMaths.Sin(theta) * 
                            RealMaths.Sin(phi) * 
                            RealMaths.Sin(gamma) * radius;
                        
                        Double z = 
                            RealMaths.Cos(phi) * 
                            RealMaths.Sin(gamma) * radius;
                        
                        Double w = 
                            RealMaths.Cos(gamma) * radius;          

                        Assert.That(
                            new Vector4(x, y,  z, w).IsUnit(), 
                            Is.EqualTo(true));
                    }
                }
            }
        }

        /// <summary>
        /// This test makes sure that the IsUnit member function returns the 
        /// correct result of FALSE for a number of scenarios where the test 
        /// vector is randomly generated and not normalised.  It's highly
        /// unlikely that the random generator will create a unit vector!
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_iv ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector4 a = GetNextRandomVector4();

                Assert.That(a.IsUnit(), Is.EqualTo(false));
            }
        }
            
        // Test Constant: Zero //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector4 initilised using the Zero constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Zero_i ()
        {
            Vector4 result = Vector4.Zero;
            Vector4 expected = new Vector4(0, 0, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: One //----------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector4 initilised using the One constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_One_i ()
        {
            Vector4 result = Vector4.One;
            Vector4 expected = new Vector4(1, 1, 1, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitX //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector4 initilised using the UnitX 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitX_i ()
        {
            Vector4 result = Vector4.UnitX;
            Vector4 expected = new Vector4(1, 0, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitY //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector4 initilised using the UnitY
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitY_i ()
        {
            Vector4 result = Vector4.UnitY;
            Vector4 expected = new Vector4(0, 1, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitZ //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector4 initilised using the UnitZ 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitZ_i ()
        {
            Vector4 result = Vector4.UnitZ;
            Vector4 expected = new Vector4(0, 0, 1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitW //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector4 initilised using the UnitW
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitW_i ()
        {
            Vector4 result = Vector4.UnitW;
            Vector4 expected = new Vector4(0, 0, 0, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Static Fn: Distance //----------------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the Distance method
        /// yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_Distance_i ()
        {
            {
                Vector4 a = new Vector4(0, 4, 12, 0);
                Vector4 b = new Vector4(3, 0, 0, 84);

                Double expected = 85;
                Double result;

                Vector4.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector4 a = new Vector4(0, -4, 12, 0);
                Vector4 b = new Vector4(3, 0, 0, 84);

                Double expected = 85;
                Double result;

                Vector4.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector4 a = new Vector4(0, -4, -12, 0);
                Vector4 b = new Vector4(-3, 0, 0, -84);

                Double expected = 85;
                Double result;

                Vector4.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector4 a = Vector4.Zero;

                Double expected = 0;
                Double result;

                Vector4.Distance(ref a, ref a, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Distance method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Distance_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector4 a = GetNextRandomVector4();

                Double expected =
                    RealMaths.Sqrt((a.X * a.X) + (a.Y * a.Y) + (a.Z * a.Z) + (a.W * a.W));

                Assert.That(a.Length(), Is.EqualTo(expected));
            }
        }

        // Test Static Fn: DistanceSquared //---------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the DistanceSquared
        /// method yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_DistanceSquared_i ()
        {
            {
                Vector4 a = new Vector4(0, 4, 12, 0);
                Vector4 b = new Vector4(3, 0, 0, 84);

                Double expected = 7225;
                Double result;

                Vector4.DistanceSquared(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector4 a = Vector4.Zero;

                Double expected = 0;
                Double result;

                Vector4.DistanceSquared(ref a, ref a, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }


        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// DistanceSquared method yeilds the same results as those obtained
        /// from performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_DistanceSquared_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector4 a = GetNextRandomVector4();
                Vector4 b = GetNextRandomVector4();

                Vector4 c = b - a;

                Double expected = (c.X * c.X) + (c.Y * c.Y) + (c.Z * c.Z) + (c.W * c.W);
                Double result;

                Vector4.DistanceSquared(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        // Test Static Fn: Dot //---------------------------------------------//

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Dot method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector4 a = GetNextRandomVector4();
                Vector4 b = GetNextRandomVector4();

                Double expected = (a.X * b.X) + (a.Y * b.Y) + (a.Z * b.Z) + (a.W * b.W);
                Double result; Vector4.Dot(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        /// <summary>
        /// Assert that two unit vectors pointing in opposing directions yeild a
        /// dot product of negative one.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_ii ()
        {
            Vector4 a = new Vector4(0, 0, 0, 1);
            Vector4 b = new Vector4(0, 0, 0, -1);

            Double expected = -1;
            Double result; Vector4.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that two unit vectors pointing in the same direction yeild a
        /// dot product of one.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_iii ()
        {
            Vector4 a = new Vector4(0, 0, 0, 1);
            Vector4 b = new Vector4(0, 0, 0, 1);

            Double expected = 1;
            Double result; Vector4.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that two perpendicular unit vectors yeild a dot product of
        /// zero.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_iv ()
        {
            Vector4 a = new Vector4(0, 0, 1, 0);
            Vector4 b = new Vector4(0, 0, 0, 1);

            Double expected = 0;
            Double result; Vector4.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Static Fn: Normalise //---------------------------------------//

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_i()
        {
            {
                Vector4 a = Vector4.Zero;

                Vector4 b;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException),
                    () =>
                    Vector4.Normalise(ref a, out b)
                );
            }

            {
                Vector4 a = new Vector4(
                    Double.MaxValue,
                    Double.MaxValue,
                    Double.MaxValue,
                    Double.MaxValue);

                Vector4 b;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException),
                    () =>
                    Vector4.Normalise(ref a, out b)
                );
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Normalise method yeilds a unit vector (with length equal to one);
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_ii ()
        {
            Double epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector4 a = GetNextRandomVector4();

                Vector4 b; Vector4.Normalise(ref a, out b);
                Double expected = 1;
                Double result1 = b.Length();
                Assert.That(result1, Is.EqualTo(expected).Within(epsilon));

                // The normalise function takes both a ref and out parameter,
                // need to check that if we pass in the same value as both
                // parameters we get the same results.
                Vector4 c = a;
                Vector4.Normalise(ref c, out c);
                Double result2 = c.Length();
                Assert.That(result2, Is.EqualTo(expected).Within(epsilon));
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Normalise method yeilds a vector, which when multipled by the
        /// length of the original vector results in the same vector as the
        /// original vector;
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_iii ()
        {
            Double epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector4 a = GetNextRandomVector4();
                Double l = a.Length();
                Vector4 expected = a;

                Vector4 b; Vector4.Normalise(ref a, out b);
                Vector4 result1 = b * l;
                AssertEqualWithinReason(result1, expected);

                Vector4 c = a;

                // The normalise function takes both a ref and out parameter,
                // need to check that if we pass in the same value as both
                // parameters we get the same results.
                Vector4.Normalise(ref c, out c);
                Vector4 result2 = c * l;
                AssertEqualWithinReason(result2, expected);
            }
        }

        // Test Static Fn: TransformMatrix44 //-------------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformMatix44_i ()
        {
            Vector4 position = new Vector4 (-40, -20, 10, 20);

            Single pi; RealMaths.Pi (out pi);
            Single tau; RealMaths.Tau (out tau);

            Matrix44 rotmati = Matrix44.Identity;
            Matrix44 rotmatx; Matrix44.CreateRotationX(tau, out rotmatx);
            Matrix44 rotmaty; Matrix44.CreateRotationY(pi, out rotmaty);
            Matrix44 rotmatz; Matrix44.CreateRotationZ(-tau, out rotmatz);
            Matrix44 rotmatxyz = rotmatx * rotmaty * rotmatz;

            Vector4 expected1 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected2 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected3 = new Vector4 ( 40, -20, -10, 20);
            Vector4 expected4 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected5 = new Vector4 ( 40, -20, -10, 20);

            Vector4 test1; Vector4.Transform (ref position, ref rotmati, out test1);
            Vector4 test2; Vector4.Transform (ref position, ref rotmatx, out test2);
            Vector4 test3; Vector4.Transform (ref position, ref rotmaty, out test3);
            Vector4 test4; Vector4.Transform (ref position, ref rotmatz, out test4);
            Vector4 test5; Vector4.Transform (ref position, ref rotmatxyz, out test5);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
            AssertEqualWithinReason(test5, expected5);
        }

        // Test Static Fn: TransformNormal //---------------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformNormal_i ()
        {
            Vector4 position = new Vector4 (-40, -20, 10, 20);
            Vector4.Normalise (ref position, out position);

            Single pi; RealMaths.Pi (out pi);
            Single tau; RealMaths.Tau (out tau);

            Matrix44 rotmati = Matrix44.Identity;
            Matrix44 rotmatx; Matrix44.CreateRotationX(pi, out rotmatx);
            Matrix44 rotmaty; Matrix44.CreateRotationY(tau, out rotmaty);
            Matrix44 rotmatz; Matrix44.CreateRotationZ(-pi, out rotmatz);
            Matrix44 rotmatxyz = rotmatx * rotmaty * rotmatz;

            Vector4 expected1 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected2 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected3 = new Vector4 ( 40, -20, -10, 20);
            Vector4 expected4 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected5 = new Vector4 ( 40, -20, -10, 20);

            Vector4.Normalise (ref expected1, out expected1);
            Vector4.Normalise (ref expected2, out expected2);
            Vector4.Normalise (ref expected3, out expected3);
            Vector4.Normalise (ref expected4, out expected4);
            Vector4.Normalise (ref expected5, out expected5);

            Vector4 test1; Vector4.TransformNormal (ref position, ref rotmati, out test1);
            Vector4 test2; Vector4.TransformNormal (ref position, ref rotmatx, out test2);
            Vector4 test3; Vector4.TransformNormal (ref position, ref rotmaty, out test3);
            Vector4 test4; Vector4.TransformNormal (ref position, ref rotmatz, out test4);
            Vector4 test5; Vector4.TransformNormal (ref position, ref rotmatxyz, out test5);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
            AssertEqualWithinReason(test5, expected5);

            // should also work with the standard transform fn
            Vector4 test1n; Vector4.Transform (ref position, ref rotmati, out test1n);
            Vector4 test2n; Vector4.Transform (ref position, ref rotmatx, out test2n);
            Vector4 test3n; Vector4.Transform (ref position, ref rotmaty, out test3n);
            Vector4 test4n; Vector4.Transform (ref position, ref rotmatz, out test4n);
            Vector4 test5n; Vector4.Transform (ref position, ref rotmatxyz, out test5n);

            AssertEqualWithinReason(test1n, expected1);
            AssertEqualWithinReason(test2n, expected2);
            AssertEqualWithinReason(test3n, expected3);
            AssertEqualWithinReason(test4n, expected4);
            AssertEqualWithinReason(test5n, expected5);
        }

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformNormal_ii ()
        {
            Matrix44 rotmat = Matrix44.Identity;
            Vector4 normal = new Vector4 (21, -532, 0, 91);
            Vector4 result;
            Assert.Throws(
                typeof(ArgumentOutOfRangeException),
                () =>
                Vector4.TransformNormal(ref normal, ref rotmat, out result)
            );
        }

        // Test Static Fn: TransformQuaternion //-----------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformQuaternion_i ()
        {
            Vector4 position = new Vector4 (-40, -20, 10, 20);

            Single pi;
            RealMaths.Pi (out pi);

            Quaternion quatmati = new Quaternion (0, 0, 0, 1);
            Quaternion quatmatx = new Quaternion (0, 0, 0, 1);
            Quaternion quatmaty = new Quaternion (0, 1, 0, 0);
            Quaternion quatmatz = new Quaternion (0, 0, 0, 1);
            Quaternion quatmatxyz = new Quaternion (0, 1, 0, 0);

            Vector4 expected1 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected2 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected3 = new Vector4 ( 40, -20, -10, 20);
            Vector4 expected4 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected5 = new Vector4 ( 40, -20, -10, 20);

            Vector4 test1; Vector4.Transform (ref position, ref quatmati, out test1);
            Vector4 test2; Vector4.Transform (ref position, ref quatmatx, out test2);
            Vector4 test3; Vector4.Transform (ref position, ref quatmaty, out test3);
            Vector4 test4; Vector4.Transform (ref position, ref quatmatz, out test4);
            Vector4 test5; Vector4.Transform (ref position, ref quatmatxyz, out test5);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
            AssertEqualWithinReason(test5, expected5);
        }

        // Test Operator: Equality //-----------------------------------------//

        /// <summary>
        /// Helper method for testing equality.
        /// </summary>
        void TestEquality (Vector4 a, Vector4 b, Boolean expected )
        {
            // This test asserts the following:
            //   (a == b) == expected
            //   (b == a) == expected
            //   (a != b) == !expected
            //   (b != a) == !expected

            Boolean result_1a = (a == b);
            Boolean result_1b = (a.Equals(b));
            Boolean result_1c = (a.Equals((Object)b));
            
            Boolean result_2a = (b == a);
            Boolean result_2b = (b.Equals(a));
            Boolean result_2c = (b.Equals((Object)a));

            Boolean result_3a = (a != b);
            Boolean result_4a = (b != a);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_1c, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
            Assert.That(result_2c, Is.EqualTo(expected));
            Assert.That(result_3a, Is.EqualTo(!expected));
            Assert.That(result_4a, Is.EqualTo(!expected));
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of TRUE when two equal  
        /// Vector4 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_i ()
        {
            var a = new Vector4(44, -54, -22, 11);
            var b = new Vector4(44, -54, -22, 11);

            Boolean expected = true;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of FALSE when two unequal  
        /// Vector4 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_ii ()
        {
            var a = new Vector4(44, 54, 2, 11);
            var b = new Vector4(44, -54, 2, -1);

            Boolean expected = false;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Tests to make sure that all the equality opperators and functions 
        /// yield the expected result of TRUE when used on a number of randomly 
        /// generated pairs of equal Vector4 objects.
        /// </summary>
        [Test]
        public void TestOperator_Equality_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();

                Vector4 b = a;

                this.TestEquality(a, b, true);
            }
        }


        // Test Operator: Addition //-----------------------------------------//

        /// <summary>
        /// Helper method for testing addition.
        /// </summary>
        void TestAddition (Vector4 a, Vector4 b, Vector4 expected )
        {
            // This test asserts the following:
            //   a + b == expected
            //   b + a == expected

            var result_1a = a + b;
            var result_2a = b + a;

            Vector4 result_1b; Vector4.Add(ref a, ref b, out result_1b);
            Vector4 result_2b; Vector4.Add(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the addition opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_i ()
        {
            var a = new Vector4(3, -6, 44, 11);
            var b = new Vector4(-6, 12, 18, -3);

            var expected = new Vector4(-3, 6, 62, 8);

            this.TestAddition(a, b, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving the zero vector, all the 
        /// addition opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_ii ()
        {
            var a = new Vector4(-2313, 88, 199, 42);

            var expected = a;

            this.TestAddition(a, Vector4.Zero, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving two zero vectors, all the 
        /// addition opperators and functions yield the correct result of zero.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iii ()
        {
            this.TestAddition(Vector4.Zero, Vector4.Zero, Vector4.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// addition opperators and functions yield the same results as a
        /// manual addition calculation.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();
                var b = GetNextRandomVector4();

                var expected = new Vector4(
                    a.X + b.X, a.Y + b.Y, a.Z + b.Z, a.W + b.W);

                this.TestAddition(a, b, expected);
            }
        }

        // Test Operator: Subtraction //--------------------------------------//
        
        /// <summary>
        /// Helper method for testing subtraction.
        /// </summary>
        void TestSubtraction (Vector4 a, Vector4 b, Vector4 expected )
        {
            // This test asserts the following:
            //   a - b == expected
            //   b - a == -expected

            var result_1a = a - b;
            var result_2a = b - a;

            Vector4 result_1b; Vector4.Subtract(ref a, ref b, out result_1b);
            Vector4 result_2b; Vector4.Subtract(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(-expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(-expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the subtraction opperators
        /// and functions yield the correct result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_i ()
        {
            var a = new Vector4(12, -4, 14, 18);
            var b = new Vector4(15, 11, 7, 27);
            var expected = new Vector4(-3, -15, 7, -9);
            this.TestSubtraction(a, b, expected);

            var c = new Vector4(-423, 342, 7, -800);
            this.TestSubtraction(c, Vector4.Zero, c);
        }

        /// <summary>
        /// Assert that when subtracting the zero vector fromt the zero vector, 
        /// all the subtraction opperators and functions yield the correct 
        /// result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_ii ()
        {
            this.TestSubtraction(Vector4.Zero, Vector4.Zero, Vector4.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// subtraction opperators and functions yield the same results as a
        /// manual subtraction calculation.
        /// </summary>
        [Test]
        public void TestOperator_Subtraction_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();
                var b = GetNextRandomVector4();

                var expected = new Vector4(
                    a.X - b.X, a.Y - b.Y, a.Z - b.Z, a.W - b.W);

                this.TestSubtraction(a, b, expected);
            }
        }

        // Test Operator: Negation //-----------------------------------------//
        
        /// <summary>
        /// Helper method for testing negation.
        /// </summary>
        void TestNegation (Vector4 a, Vector4 expected )
        {
            // This test asserts the following:
            //   -a == expected

            var result_1a = -a;

            Vector4 result_1b; Vector4.Negate(ref a, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the negation opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_i ()
        {
            Double r = 3432;
            Double s = -6218;
            Double t = -3432;
            Double u = 6218;

            var a = new Vector4(r, s, t, u);
            var b = new Vector4(u, t, s, r);
            var c = new Vector4(t, u, r, s);
            var d = new Vector4(s, r, u, t);

            this.TestNegation(a, c);
            this.TestNegation(b, d);
        }

        /// <summary>
        /// Assert that, for known examples involving the zero vector, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_ii ()
        {
            Double t = -3432;
            Double u = 6218;
            Double r = 3432;
            Double s = -6218;

            var c = new Vector4(t, u, r, s);
            var d = new Vector4(s, r, u, t);

            this.TestNegation(c, Vector4.Zero - c);
            this.TestNegation(d, Vector4.Zero - d);
        }

        /// <summary>
        /// Assert that when negating the zero vector, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iii ()
        {
            this.TestNegation(Vector4.Zero, Vector4.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// negation opperators and functions yield the same results as a
        /// manual negation calculation.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();
                this.TestNegation(a, Vector4.Zero - a);
            }
        }

        // Test Operator: Multiplication //-----------------------------------//

        /// <summary>
        /// Helper method for testing multiplication.
        /// </summary>
        void TestMultiplication (Vector4 a, Vector4 b, Vector4 expected )
        {
            // This test asserts the following:
            //   a * b == expected
            //   b * a == expected

            var result_1a = a * b;
            var result_2a = b * a;

            Vector4 result_1b; Vector4.Multiply(ref a, ref b, out result_1b);
            Vector4 result_2b; Vector4.Multiply(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the multiplication opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_i ()
        {
            Double r = -27;
            Double s = 36;
            Double t = 9;
            Double u = -54;

            Double x = 3;
            Double y = 6;
            Double z = -9;

            var a = new Vector4(x, y, x, y);
            var b = new Vector4(z, y, x, z);
            var c = new Vector4(r, s, t, u);

            this.TestMultiplication(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// multiplication opperators and functions yield the same results as a
        /// manual multiplication calculation.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();
                var b = GetNextRandomVector4();

                var c = new Vector4(
                    a.X * b.X, a.Y * b.Y, a.Z * b.Z, a.W * b.W);

                this.TestMultiplication(a, b, c);
            }
        }


        // Test Operator: Division //-----------------------------------------//

        /// <summary>
        /// Helper method for testing division.
        /// </summary>
        void TestDivision (Vector4 a, Vector4 b, Vector4 expected )
        {
            // This test asserts the following:
            //   a / b == expected

            var result_1a = a / b;

            Vector4 result_1b; Vector4.Divide(ref a, ref b, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example using whole numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_i ()
        {
            Double r = 10;
            Double s = -40;
            Double t = 1;
            Double u = -400;

            Double x = 2000;
            Double y = 200;
            Double z = -5;

            var a = new Vector4(x, y, x, x);
            var b = new Vector4(y, z, x, z);
            var c = new Vector4(r, s, t, u);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a known example using fractional numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_ii ()
        {
            Double s = 4;
            Double t = ((Double) 1 ) / ((Double) 10);
            Double u = ((Double) (-1) ) / ((Double) 40 );
            Double v = -20;
            Double w = 100;
            Double x = 2000;
            Double y = 200;
            Double z = -5;

            var a = new Vector4(y, z, w, v);
            var b = new Vector4(x, y, z, z);
            var c = new Vector4(t, u, v, s);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// division opperators and functions yield the same results as a
        /// manual addition division.
        /// </summary>
        [Test]
        public void TestOperator_Division_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();
                var b = GetNextRandomVector4();

                var c = new Vector4(
                    a.X / b.X, a.Y / b.Y, a.Z / b.Z, a.W / b.W);

                this.TestDivision(a, b, c);
            }
        }

        // Test Static Fn: SmoothStep //--------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();
                var b = GetNextRandomVector4();

                Double amount1 = 0;
                Vector4 result1;

                Vector4.SmoothStep (
                    ref a, ref b, amount1, out result1);

                AssertEqualWithinReason(result1, a);

                Double amount2 = 1;
                Vector4 result2;

                Vector4.SmoothStep (
                    ref a, ref b, amount2, out result2);

                AssertEqualWithinReason(result2, b);
            }
        }

        /// <summary>
        /// Assert that, for known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_ii ()
        {
            var a = GetNextRandomVector4();
            var b = GetNextRandomVector4();

            Double half; RealMaths.Half(out half);

            var tests = new Double[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector4 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector4.SmoothStep (
                            ref a, ref b, amount, out result)
                    );
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_iii ()
        {
            var a = new Vector4( -30, -30, -30, -30 );
            var b = new Vector4( +30, +30, +30, +30 );

            Double one = 1;

            Double i;
            RealMaths.FromFraction(1755, 64, out i); // 27.421875
            
            Double j;
            RealMaths.FromFraction( 165,  8, out j); // 20.625
            
            Double k;
            RealMaths.FromFraction( 705, 64, out k); // 11.015625

            Double a0 = 0;
            Double a1 = (one * 1) / 8;
            Double a2 = (one * 2) / 8;
            Double a3 = (one * 3) / 8;
            Double a4 = (one * 4) / 8;
            Double a5 = (one * 5) / 8;
            Double a6 = (one * 6) / 8;
            Double a7 = (one * 7) / 8;
            Double a8 = 1;

            Vector4 r0 = a;
            Vector4 r1 = new Vector4( -i, -i, -i, -i );
            Vector4 r2 = new Vector4( -j, -j, -j, -j );
            Vector4 r3 = new Vector4( -k, -k, -k, -k );
            Vector4 r4 = Vector4.Zero;
            Vector4 r5 = new Vector4(  k,  k,  k,  k );
            Vector4 r6 = new Vector4(  j,  j,  j,  j );
            Vector4 r7 = new Vector4(  i,  i,  i,  i );
            Vector4 r8 = b;

            var knownResults = new List<Tuple<Double, Vector4>>
            {
                new Tuple<Double, Vector4>( a0, r0 ),
                new Tuple<Double, Vector4>( a1, r1 ),
                new Tuple<Double, Vector4>( a2, r2 ),
                new Tuple<Double, Vector4>( a3, r3 ),
                new Tuple<Double, Vector4>( a4, r4 ),
                new Tuple<Double, Vector4>( a5, r5 ),
                new Tuple<Double, Vector4>( a6, r6 ),
                new Tuple<Double, Vector4>( a7, r7 ),
                new Tuple<Double, Vector4>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector4 result;

                Vector4.SmoothStep (
                    ref a, ref b, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        // Test Static Fn: CatmullRom //--------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();
                var b = GetNextRandomVector4();
                var c = GetNextRandomVector4();
                var d = GetNextRandomVector4();

                Double amount1 = 0;
                Vector4 result1;

                Vector4.CatmullRom (
                    ref a, ref b, ref c, ref d, amount1, out result1);

                AssertEqualWithinReason(result1, b);

                Double amount2 = 1;
                Vector4 result2;

                Vector4.CatmullRom (
                    ref a, ref b, ref c, ref d, amount2, out result2);

                AssertEqualWithinReason(result2, c);
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_ii ()
        {
            var a = new Vector4( -90, +30, +90, -30 );
            var b = new Vector4( -30, -30, +30, +30 );
            var c = new Vector4( +30, +30, -30, -30 );
            var d = new Vector4( +90, -30, -90, -30 );

            Double one = 1;

            Double u = 15;
            Double v = (Double) 165  / (Double)  8; // 20.5
            Double w = (Double) 45   / (Double)  2; // 20.625
            Double x = (Double) 1755 / (Double) 64; // 27.421875
            Double y = (Double) 15   / (Double)  2; // 14.5
            Double z = (Double) 705  / (Double) 64; // 11.015625

            Double a0 = 0;
            Double a1 = (one * 1) / 8;
            Double a2 = (one * 2) / 8;
            Double a3 = (one * 3) / 8;
            Double a4 = (one * 4) / 8;
            Double a5 = (one * 5) / 8;
            Double a6 = (one * 6) / 8;
            Double a7 = (one * 7) / 8;
            Double a8 = 1;

            Vector4 r0 = b;
            Vector4 r1 = new Vector4( -w, -x,  w,  x );
            Vector4 r2 = new Vector4( -u, -v,  u,  v );
            Vector4 r3 = new Vector4( -y, -z,  y,  z );
            Vector4 r4 = Vector4.Zero;
            Vector4 r5 = new Vector4(  y,  z, -y, -z );
            Vector4 r6 = new Vector4(  u,  v, -u, -v );
            Vector4 r7 = new Vector4(  w,  x, -w, -x );
            Vector4 r8 = c;

            var knownResults = new List<Tuple<Double, Vector4>>
            {
                new Tuple<Double, Vector4>( a0, r0 ),
                new Tuple<Double, Vector4>( a1, r1 ),
                new Tuple<Double, Vector4>( a2, r2 ),
                new Tuple<Double, Vector4>( a3, r3 ),
                new Tuple<Double, Vector4>( a4, r4 ),
                new Tuple<Double, Vector4>( a5, r5 ),
                new Tuple<Double, Vector4>( a6, r6 ),
                new Tuple<Double, Vector4>( a7, r7 ),
                new Tuple<Double, Vector4>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector4 result;

                Vector4.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        /// <summary>
        /// Assert that, for known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_iii ()
        {
            var a = GetNextRandomVector4();
            var b = GetNextRandomVector4();
            var c = GetNextRandomVector4();
            var d = GetNextRandomVector4();
            
            Double half; RealMaths.Half(out half);

            var tests = new Double[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector4 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector4.CatmullRom (
                            ref a, ref b, ref c, ref d, amount, out result)
                );
            }
        }

        /// <summary>
        /// This tests compares results against an example where all the control
        /// points are in a straight line.  In this case the resulting spline
        /// should be a straight line.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_iv ()
        {
            var a = new Vector4( -90, +30, +90, -30 );
            var b = new Vector4( -30, -30, +30, +30 );
            var c = new Vector4( +30, +30, -30, -30 );
            var d = new Vector4( +90, -30, -90, -30 );

            Double one = 1;

            Double a0 = 0;
            Double a1 = (one * 1) / 4;
            Double a2 = (one * 2) / 4;
            Double a3 = (one * 3) / 4;
            Double a4 = 1;

            Vector4 r0 = b;
            Vector4 r1 = new Vector4( -15, -15,  15,  15 );
            Vector4 r2 = Vector4.Zero;
            Vector4 r3 = new Vector4(  15,  15, -15, -15 );
            Vector4 r4 = c;

            var knownResults = new List<Tuple<Double, Vector4>>
            {
                new Tuple<Double, Vector4>( a0, r0 ),
                new Tuple<Double, Vector4>( a1, r1 ),
                new Tuple<Double, Vector4>( a2, r2 ),
                new Tuple<Double, Vector4>( a3, r3 ),
                new Tuple<Double, Vector4>( a4, r4 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector4 result;

                Vector4.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        // Test Static Fn: Hermite //-----------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a  = GetNextRandomVector4();
                var b  = GetNextRandomVector4();

                var c = GetNextRandomVector4();
                var d = GetNextRandomVector4();

                Vector4 an; Vector4.Normalise(ref c, out an);
                Vector4 bn; Vector4.Normalise(ref d, out bn);

                Double amount1 = 0;
                Vector4 result1;

                Vector4.Hermite (
                    ref a, ref an, ref b, ref bn, amount1, out result1);

                AssertEqualWithinReason(result1, a);

                Double amount2 = 1;
                Vector4 result2;

                Vector4.Hermite (
                    ref a, ref an, ref b, ref bn, amount2, out result2);

                AssertEqualWithinReason(result2, b);
            }
        }

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_ii ()
        {
            var a = GetNextRandomVector4();
            var b = GetNextRandomVector4();
            var c = GetNextRandomVector4();
            var d = GetNextRandomVector4();

            Vector4 an; Vector4.Normalise(ref c, out an);
            Vector4 bn; Vector4.Normalise(ref d, out bn);

            Double half; RealMaths.Half(out half);

            var tests = new Double[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector4 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector4.Hermite (
                            ref a, ref an, ref b, ref bn, amount, out result)
                    );
                
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_iii ()
        {
            var a = new Vector4( -100, +50, +100, -50 );
            var b = new Vector4( +100, -50, -100, +50 );

            var c = new Vector4( -10, +5, +10, -5 );
            var d = new Vector4( +10, -5, -10, +5 );

            Vector4 an; Vector4.Normalise(ref c, out an);
            Vector4 bn; Vector4.Normalise(ref d, out bn);

            Double one = 1;
            
            // 100.1953125
            Double e = (Double) 51300 / (Double) 512;

            // 50.09765625
            Double f = (Double) 12825 / (Double) 256;

            // 91.25
            Double g = (Double) 365 / (Double) 4;

            // 45.625
            Double h = (Double) 365 / (Double) 8;

            // 75.7421875
            Double i = (Double) 9695 / (Double) 128;

            // 37.87109375
            Double j = (Double) 9695 / (Double) 256;

            // 56.25
            Double k = (Double) 225 / (Double) 4;

            // 28.125
            Double l = (Double) 225 / (Double) 8;

            // 35.3515625
            Double m = (Double) 4525 / (Double) 128;

            // 17.67578125
            Double n = (Double) 4525 / (Double) 256;

            // 15.625
            Double o = (Double) 125 / (Double) 8;

            // 7.8125
            Double p = (Double) 125 / (Double) 16;

            // 0.3515625
            Double q = (Double) 45 / (Double) 128;

            // 0.17578125
            Double r = (Double) 45 / (Double) 256;

            Double a0 = 0;
            Double a1 = (one * 1) / 8;
            Double a2 = (one * 2) / 8;
            Double a3 = (one * 3) / 8;
            Double a4 = (one * 4) / 8;
            Double a5 = (one * 5) / 8;
            Double a6 = (one * 6) / 8;
            Double a7 = (one * 7) / 8;
            Double a8 = 1;

            Vector4 r0 = b;
            Vector4 r1 = new Vector4(  e, -f, -e,  f );
            Vector4 r2 = new Vector4(  g, -h, -g,  h );
            Vector4 r3 = new Vector4(  i, -j, -i,  j );
            Vector4 r4 = new Vector4(  k, -l, -k,  l );
            Vector4 r5 = new Vector4(  m, -n, -m,  n );
            Vector4 r6 = new Vector4(  o, -p, -o,  p );
            Vector4 r7 = new Vector4( -q,  r,  q, -r );
            Vector4 r8 = c;

            var knownResults = new List<Tuple<Double, Vector4>>
            {
                new Tuple<Double, Vector4>( a0, r0 ),
                new Tuple<Double, Vector4>( a1, r1 ),
                new Tuple<Double, Vector4>( a2, r2 ),
                new Tuple<Double, Vector4>( a3, r3 ),
                new Tuple<Double, Vector4>( a4, r4 ),
                new Tuple<Double, Vector4>( a5, r5 ),
                new Tuple<Double, Vector4>( a6, r6 ),
                new Tuple<Double, Vector4>( a7, r7 ),
                new Tuple<Double, Vector4>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector4 result;

                Vector4.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

                /// <summary>
        /// Assert that, running the Min function on a number of randomly
        /// generated pairs of Vector4 objects, yields the same results as those
        /// obtained from performing a manual Min calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Min ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector4 a = GetNextRandomVector4();
                Vector4 b = a * 2;

                Vector4 result;
                Vector4.Min (ref a, ref b, out result);

                Assert.That(result.X, Is.EqualTo(a.X < b.X ? a.X : b.X ));
                Assert.That(result.Y, Is.EqualTo(a.Y < b.Y ? a.Y : b.Y ));
                Assert.That(result.Z, Is.EqualTo(a.Z < b.Z ? a.Z : b.Z ));
                Assert.That(result.W, Is.EqualTo(a.W < b.W ? a.W : b.W ));
            }
        }

        /// <summary>
        /// Assert that, running the Max function on a number of randomly
        /// generated pairs of Vector4 objects, yields the same results as those
        /// obtained from performing a manual Max calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Max ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector4 a = GetNextRandomVector4();
                Vector4 b = GetNextRandomVector4();

                Vector4 result;
                Vector4.Max (ref a, ref b, out result);

                Assert.That(result.X, Is.EqualTo(a.X > b.X ? a.X : b.X ));
                Assert.That(result.Y, Is.EqualTo(a.Y > b.Y ? a.Y : b.Y ));
                Assert.That(result.Z, Is.EqualTo(a.Z > b.Z ? a.Z : b.Z ));
                Assert.That(result.W, Is.EqualTo(a.W > b.W ? a.W : b.W ));
            }
        }

        /// <summary>
        /// Assert that, running the Clamp function on a number of randomly
        /// generated Vector4 objects for a given min-max range, yields
        /// results that fall within that range.
        /// </summary>
        [Test]
        public void TestStaticFn_Clamp_i ()
        {
            Vector4 min = new Vector4(-30, 1, 18, -22);
            Vector4 max = new Vector4(32, 130, 47, -2);

            for(Int32 i = 0; i < 100; ++i)
            {
                Vector4 a = GetNextRandomVector4();

                Vector4 result;
                Vector4.Clamp (ref a, ref min, ref max, out result);

                Assert.That(result.X, Is.LessThanOrEqualTo(max.X));
                Assert.That(result.Y, Is.LessThanOrEqualTo(max.Y));
                Assert.That(result.X, Is.GreaterThanOrEqualTo(min.X));
                Assert.That(result.Y, Is.GreaterThanOrEqualTo(min.Y));
            }
        }

        /// <summary>
        /// Assert that, running the Clamp function on an a Vector4 object known
        /// to fall outside of a given min-max range, yields a result that fall 
        /// within that range.
        /// </summary>
        [Test]
        public void TestStaticFn_Clamp_ii ()
        {
            Vector4 min = new Vector4(-30, 1, 18, -22);
            Vector4 max = new Vector4(32, 130, 47, -2);

            Vector4 a = new Vector4(-100, 1113, 50, 14);

            Vector4 expected = new Vector4(-30, 130, 47, -2);

            Vector4 result;
            Vector4.Clamp (ref a, ref min, ref max, out result);

            Assert.That(result.X, Is.LessThanOrEqualTo(max.X));
            Assert.That(result.Y, Is.LessThanOrEqualTo(max.Y));
            Assert.That(result.Z, Is.LessThanOrEqualTo(max.Z));
            Assert.That(result.W, Is.LessThanOrEqualTo(max.W));
            Assert.That(result.X, Is.GreaterThanOrEqualTo(min.X));
            Assert.That(result.Y, Is.GreaterThanOrEqualTo(min.Y));
            Assert.That(result.Z, Is.GreaterThanOrEqualTo(min.Z));
            Assert.That(result.W, Is.GreaterThanOrEqualTo(min.W));

            AssertEqualWithinReason(result, expected);

        }

        /// <summary>
        /// Assert that, running the Lerp function on a number of randomly
        /// generated pairs of Vector4 objects for a range of weighting amounts, 
        /// yields the same results as those obtained from performing a manual 
        /// Lerp calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_i ()
        {
            for(Int32 j = 0; j < 100; ++j)
            {
                Double delta = j;

                delta = delta / 100;

                for(Int32 i = 0; i < 100; ++i)
                {
                    Vector4 a = GetNextRandomVector4();
                    Vector4 b = GetNextRandomVector4();

                    Vector4 result;
                    Vector4.Lerp (ref a, ref b, delta, out result);

                    Vector4 expected = a + ( ( b - a ) * delta );

                    AssertEqualWithinReason(result, expected);
                }
            }
        }

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_ii ()
        {
            Vector4 a = GetNextRandomVector4();
            Vector4 b = GetNextRandomVector4();

            Double half; RealMaths.Half(out half);

            var tests = new Double[] { 2, half + 1, -half, -1 };

            foreach( var weighting in tests )
            {
                Vector4 result; 
                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector4.Lerp (
                            ref a, ref b, weighting, out result)
                    );
            }
        }


    }}

namespace Abacus.Fixed32Precision.Tests
{
    /// <summary>
    ///
    /// </summary>
    [TestFixture]
    public class Matrix44Tests
    {
        /// <summary>
        /// The random number generator used for testing.
        /// </summary>
        static readonly System.Random rand;

        /// <summary>
        /// Static constructor used to ensure that the random number generator
        /// always gets initilised with the same seed, making the tests
        /// behave in a deterministic manner.
        /// </summary>
        static Matrix44Tests ()
        {
            rand = new System.Random(0);
        }

        /// <summary>
        /// Helper function for getting the next random Fixed32 value.
        /// </summary>
        static Fixed32 GetNextRandomFixed32 ()
        {
            Fixed32 randomValue = rand.NextFixed32();

            Fixed32 zero = 0;
            Fixed32 multiplier = 1000;

            randomValue *= multiplier;

            Boolean randomBoolean = (rand.Next(0, 1) == 0) ? true : false;

            if( randomBoolean )
                randomValue = zero - randomValue;

            return randomValue;
        }

        /// <summary>
        /// Helper function for getting the next random Matrix44.
        /// </summary>
        internal static Matrix44 GetNextRandomMatrix44 ()
        {
            Fixed32 a = GetNextRandomFixed32();
            Fixed32 b = GetNextRandomFixed32();
            Fixed32 c = GetNextRandomFixed32();
            Fixed32 d = GetNextRandomFixed32();
            Fixed32 e = GetNextRandomFixed32();
            Fixed32 f = GetNextRandomFixed32();
            Fixed32 g = GetNextRandomFixed32();
            Fixed32 h = GetNextRandomFixed32();
            Fixed32 i = GetNextRandomFixed32();
            Fixed32 j = GetNextRandomFixed32();
            Fixed32 k = GetNextRandomFixed32();
            Fixed32 l = GetNextRandomFixed32();
            Fixed32 m = GetNextRandomFixed32();
            Fixed32 n = GetNextRandomFixed32();
            Fixed32 o = GetNextRandomFixed32();
            Fixed32 p = GetNextRandomFixed32();

            return new Matrix44(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);
        }

        /// <summary>
        /// Helper to encapsulate asserting that two Matrix44s are equal.
        /// </summary>
        internal static void AssertEqualWithinReason (Matrix44 a, Matrix44 b)
        {
            Fixed32 tolerance; RealMaths.TestTolerance(out tolerance);

            Assert.That(a.M11, Is.EqualTo(b.M11).Within(tolerance));
            Assert.That(a.M12, Is.EqualTo(b.M12).Within(tolerance));
            Assert.That(a.M13, Is.EqualTo(b.M13).Within(tolerance));
            Assert.That(a.M14, Is.EqualTo(b.M14).Within(tolerance));
            Assert.That(a.M21, Is.EqualTo(b.M21).Within(tolerance));
            Assert.That(a.M22, Is.EqualTo(b.M22).Within(tolerance));
            Assert.That(a.M23, Is.EqualTo(b.M23).Within(tolerance));
            Assert.That(a.M24, Is.EqualTo(b.M24).Within(tolerance));
            Assert.That(a.M31, Is.EqualTo(b.M31).Within(tolerance));
            Assert.That(a.M32, Is.EqualTo(b.M32).Within(tolerance));
            Assert.That(a.M33, Is.EqualTo(b.M33).Within(tolerance));
            Assert.That(a.M34, Is.EqualTo(b.M34).Within(tolerance));
            Assert.That(a.M41, Is.EqualTo(b.M41).Within(tolerance));
            Assert.That(a.M42, Is.EqualTo(b.M42).Within(tolerance));
            Assert.That(a.M43, Is.EqualTo(b.M43).Within(tolerance));
            Assert.That(a.M44, Is.EqualTo(b.M44).Within(tolerance));
        }
        

        /// <summary>
        /// This test makes sure that the struct layout has been defined
        /// correctly.
        /// </summary>
        [Test]
        public void Test_StructLayout_i ()
        {
            Type t = typeof(Matrix44);

            Assert.That(
                t.StructLayoutAttribute.Value,
                Is.EqualTo(LayoutKind.Sequential));
        }

        /// <summary>
        /// This test makes sure that when examining the memory addresses of the
        /// member variables of a number of randomly generated Matrix44
        /// objects the results are as expected.
        /// </summary>
        [Test]
        public unsafe void Test_StructLayout_ii ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        [Test]
        public void Test_Constructors ()
        {
            Assert.That(true, Is.EqualTo(false));
        }

        [Test]
        public void TestMemberFn_ToString ()
        {
            Assert.That(true, Is.EqualTo(false));
        }

        [Test]
        public void TestMemberFn_GetHashCode ()
        {
            Assert.That(true, Is.EqualTo(false));
        }

        // Test Constant: Identity //-----------------------------------------//

        /// <summary>
        /// Tests to make sure that a Matrix44 initilised using the Identity 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Identity_i ()
        {
            Matrix44 result = Matrix44.Identity;
            Matrix44 expected = new Matrix44 (
                1, 0, 0, 0, 
                0, 1, 0, 0, 
                0, 0, 1, 0, 
                0, 0, 0, 1);

            AssertEqualWithinReason(result, expected);
        }        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateTranslation_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateTranslation_ii ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateScale_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        //// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateScale_ii ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateScale_iii ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateRotationX_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateRotationY_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateRotationZ_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromAxisAngle_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromAllAxis_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateWorldNew_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateWorld_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromQuaternion_i ()
        {
            Fixed32 yaw; RealMaths.Pi(out yaw); yaw /= (Fixed32) 4;
            Fixed32 pitch; RealMaths.Pi(out pitch); pitch /= (Fixed32) (-8);
            Fixed32 roll; RealMaths.Pi(out roll); roll /= (Fixed32) 2;

            Quaternion q; Quaternion.CreateFromYawPitchRoll(yaw, pitch, roll, out q);
            q.Normalise();

            Matrix44 m; Matrix44.CreateFromQuaternion(ref q, out m);

            Matrix44 expected = new Matrix44 ();
            expected.M11 = Fixed32.Parse("-0.270598"); // this is a grim way to do it, make it so we can cast double to fixed
            expected.M12 = Fixed32.Parse("0.9238795");
            expected.M13 = Fixed32.Parse("-0.270598");
            expected.M14 = 0;
            expected.M21 = Fixed32.Parse("-0.7071067");
            expected.M22 = Fixed32.Parse("6.705523E-08");
            expected.M23 = Fixed32.Parse("0.7071067");
            expected.M24 = 0;
            expected.M31 = Fixed32.Parse("0.6532815");
            expected.M32 = Fixed32.Parse("0.3826834");
            expected.M33 = Fixed32.Parse("0.6532815");
            expected.M34 = 0;
            expected.M41 = 0;
            expected.M42 = 0;
            expected.M43 = 0;
            expected.M44 = 1;


            AssertEqualWithinReason(m, expected);

        }

        /// <summary>
        /// Assert that, for a number of examples, a random quaternion can be
        /// selected, converted to a Matrix44 then converted back to the same
        /// quaternion (assuming that the conversion back is correct).
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromQuaternion_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Quaternion q = QuaternionTests.GetNextRandomQuaternion();
                Quaternion.Normalise(ref q, out q);

                Matrix44 m;
                Matrix44.CreateFromQuaternion(ref q, out m);

                Quaternion q2;
                Quaternion.CreateFromRotationMatrix(ref m, out q2);

                QuaternionTests.AssertEqualWithinReason(q, q2);
            }
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromYawPitchRoll_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateBillboard_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateConstrainedBillboard_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreatePerspectiveFieldOfView_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreatePerspective_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreatePerspectiveOffCenter_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateOrthographic_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void CreateOrthographicOffCenter_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateLookAt_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Transpose //---------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Transpose_i ()
        {
            Matrix44 startMatrix = new Matrix44(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);

            Matrix44 testMatrix = startMatrix;

            Matrix44 testMatrixExpectedTranspose = new Matrix44(0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15);

            // RUN THE STATIC VERSION OF THE FUNCTION
            Matrix44 resultMatrix = Matrix44.Identity;

            Matrix44.Transpose(ref testMatrix, out resultMatrix);

            Assert.That(resultMatrix, Is.EqualTo(testMatrixExpectedTranspose));
        }

        // Test Static Fn: Decompose //---------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Decompose_i ()
        {
            Matrix44 scale;
            Matrix44.CreateScale(4, 2, 3, out scale);

            Matrix44 rotation;
            Fixed32 pi; RealMaths.Pi(out pi);
            Matrix44.CreateRotationY(pi, out rotation);

            Matrix44 translation;
            Matrix44.CreateTranslation(100, 5, 3, out translation);

            Matrix44 m = rotation * scale;
            //m = translation * m;
            m.Translation = new Vector3(100, 5, 3);

            Vector3 outScale;
            Quaternion outRotation;
            Vector3 outTranslation;

            m.Decompose(out outScale, out outRotation, out outTranslation);

            Matrix44 mat;
            Matrix44.CreateFromQuaternion(ref outRotation, out mat);

            Assert.That(outScale, Is.EqualTo(new Vector3(4, 2, 3)));
            Assert.That(mat, Is.EqualTo(rotation));
            Assert.That(outTranslation, Is.EqualTo(new Vector3(100, 5, 3)));
        }

        // Test Static Fn: Determinant //-------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Determinant_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Invert //------------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Invert_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Transform //---------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Transform_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }
        // Test Operator: Equality //-----------------------------------------//

        /// <summary>
        /// Helper method for testing equality.
        /// </summary>
        void TestEquality (Matrix44 a, Matrix44 b, Boolean expected )
        {
            // This test asserts the following:
            //   (a == b) == expected
            //   (b == a) == expected
            //   (a != b) == !expected
            //   (b != a) == !expected

            Boolean result_1a = (a == b);
            Boolean result_1b = (a.Equals(b));
            Boolean result_1c = (a.Equals((Object)b));
            
            Boolean result_2a = (b == a);
            Boolean result_2b = (b.Equals(a));
            Boolean result_2c = (b.Equals((Object)a));

            Boolean result_3a = (a != b);
            Boolean result_4a = (b != a);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_1c, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
            Assert.That(result_2c, Is.EqualTo(expected));
            Assert.That(result_3a, Is.EqualTo(!expected));
            Assert.That(result_4a, Is.EqualTo(!expected));
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of TRUE when two equal  
        /// Matrix44 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_i ()
        {
            var a = new Matrix44(44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);
            var b = new Matrix44(44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);

            Boolean expected = true;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of FALSE when two unequal  
        /// Matrix44 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_ii ()
        {
            var a = new Matrix44(44, 54, 2, 11, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);
            var b = new Matrix44(44, -54, 2, -1, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);

            Boolean expected = false;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Tests to make sure that all the equality opperators and functions 
        /// yield the expected result of TRUE when used on a number of randomly 
        /// generated pairs of equal Matrix44 objects.
        /// </summary>
        [Test]
        public void TestOperator_Equality_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomMatrix44();

                Matrix44 b = a;

                this.TestEquality(a, b, true);
            }
        }


        // Test Operator: Addition //-----------------------------------------//

        /// <summary>
        /// Helper method for testing addition.
        /// </summary>
        void TestAddition (Matrix44 a, Matrix44 b, Matrix44 expected )
        {
            // This test asserts the following:
            //   a + b == expected
            //   b + a == expected

            var result_1a = a + b;
            var result_2a = b + a;

            Matrix44 result_1b; Matrix44.Add(ref a, ref b, out result_1b);
            Matrix44 result_2b; Matrix44.Add(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the addition opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_i ()
        {
            var a = new Matrix44(3, -6, 44, 11, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);
            var b = new Matrix44(-6, 12, 18, -3, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);

            var expected = new Matrix44(-3, 6, 62, 8, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);

            this.TestAddition(a, b, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving the zero matrix, all the 
        /// addition opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_ii ()
        {
            var a = new Matrix44(-2313, 88, 199, 42, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);

            var expected = a;

            this.TestAddition(a, Matrix44.Identity, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving two zero matrixs, all the 
        /// addition opperators and functions yield the correct result of zero.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iii ()
        {
            this.TestAddition(Matrix44.Identity, Matrix44.Identity, Matrix44.Identity);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// addition opperators and functions yield the same results as a
        /// manual addition calculation.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomMatrix44();
                var b = GetNextRandomMatrix44();

                var expected = new Matrix44(
                    a.M11 / b.M11, 
                    a.M12 / b.M12, 
                    a.M13 / b.M13, 
                    a.M14 / b.M14,
                    a.M21 / b.M21, 
                    a.M22 / b.M22, 
                    a.M23 / b.M23, 
                    a.M24 / b.M24,
                    a.M31 / b.M31, 
                    a.M32 / b.M32, 
                    a.M33 / b.M33, 
                    a.M34 / b.M34,
                    a.M41 / b.M41, 
                    a.M42 / b.M42, 
                    a.M43 / b.M43, 
                    a.M44 / b.M44
                    );

                this.TestAddition(a, b, expected);
            }
        }

        // Test Operator: Subtraction //--------------------------------------//
        
        /// <summary>
        /// Helper method for testing subtraction.
        /// </summary>
        void TestSubtraction (Matrix44 a, Matrix44 b, Matrix44 expected )
        {
            // This test asserts the following:
            //   a - b == expected
            //   b - a == -expected

            var result_1a = a - b;
            var result_2a = b - a;

            Matrix44 result_1b; Matrix44.Subtract(ref a, ref b, out result_1b);
            Matrix44 result_2b; Matrix44.Subtract(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(-expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(-expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the subtraction opperators
        /// and functions yield the correct result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_i ()
        {
            var a = new Matrix44(12, -4, 14, 18, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);
            var b = new Matrix44(15, 11, 7, 27, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);
            var expected = new Matrix44(-3, -15, 7, -9, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);
            this.TestSubtraction(a, b, expected);

            var c = new Matrix44(-423, 342, 7, -800, 44, -54, -22, 11, 44, -54, -22, 11, 44, -54, -22, 11);
            this.TestSubtraction(c, Matrix44.Identity, c);
        }

        /// <summary>
        /// Assert that when subtracting the zero matrix fromt the zero matrix, 
        /// all the subtraction opperators and functions yield the correct 
        /// result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_ii ()
        {
            this.TestSubtraction(Matrix44.Identity, Matrix44.Identity, Matrix44.Identity);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// subtraction opperators and functions yield the same results as a
        /// manual subtraction calculation.
        /// </summary>
        [Test]
        public void TestOperator_Subtraction_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomMatrix44();
                var b = GetNextRandomMatrix44();

                var expected = new Matrix44(
                    a.M11 / b.M11, 
                    a.M12 / b.M12, 
                    a.M13 / b.M13, 
                    a.M14 / b.M14,
                    a.M21 / b.M21, 
                    a.M22 / b.M22, 
                    a.M23 / b.M23, 
                    a.M24 / b.M24,
                    a.M31 / b.M31, 
                    a.M32 / b.M32, 
                    a.M33 / b.M33, 
                    a.M34 / b.M34,
                    a.M41 / b.M41, 
                    a.M42 / b.M42, 
                    a.M43 / b.M43, 
                    a.M44 / b.M44
                    );

                this.TestSubtraction(a, b, expected);
            }
        }

        // Test Operator: Negation //-----------------------------------------//
        
        /// <summary>
        /// Helper method for testing negation.
        /// </summary>
        void TestNegation (Matrix44 a, Matrix44 expected )
        {
            // This test asserts the following:
            //   -a == expected

            var result_1a = -a;

            Matrix44 result_1b;
            Matrix44.Negate(ref a, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the negation opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_i ()
        {
            Fixed32 r = 3432;
            Fixed32 s = -6218;
            Fixed32 t = -3432;
            Fixed32 u = 6218;

            var a = new Matrix44(r, s, t, u, r, s, t, u, r, s, t, u, r, s, t, u);
            var b = new Matrix44(u, t, s, r, r, s, t, u, r, s, t, u, r, s, t, u);
            var c = new Matrix44(t, u, r, s, r, s, t, u, r, s, t, u, r, s, t, u);
            var d = new Matrix44(s, r, u, t, r, s, t, u, r, s, t, u, r, s, t, u);

            this.TestNegation(a, c);
            this.TestNegation(b, d);
        }

        /// <summary>
        /// Assert that, for known examples involving the zero matrix, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_ii ()
        {
            Fixed32 t = -3432;
            Fixed32 u = 6218;
            Fixed32 r = 3432;
            Fixed32 s = -6218;

            var c = new Matrix44(t, u, r, s, r, s, t, u, r, s, t, u, r, s, t, u);
            var d = new Matrix44(s, r, u, t, r, s, t, u, r, s, t, u, r, s, t, u);

            this.TestNegation(c, Matrix44.Identity - c);
            this.TestNegation(d, Matrix44.Identity - d);
        }

        /// <summary>
        /// Assert that when negating the zero matrix, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iii ()
        {
            this.TestNegation(Matrix44.Identity, Matrix44.Identity);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// negation opperators and functions yield the same results as a
        /// manual negation calculation.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomMatrix44();
                this.TestNegation(a, Matrix44.Identity - a);
            }
        }

        // Test Operator: Multiplication //-----------------------------------//

        /// <summary>
        /// Helper method for testing multiplication.
        /// </summary>
        void TestMultiplication (Matrix44 a, Matrix44 b, Matrix44 expected )
        {
            // This test asserts the following:
            //   a * b == expected
            //   b * a == expected

            var result_1a = a * b;
            var result_2a = b * a;

            Matrix44 result_1b; Matrix44.Multiply(ref a, ref b, out result_1b);
            Matrix44 result_2b; Matrix44.Multiply(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the multiplication opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_i ()
        {
            var a = new Matrix44();
            a.M11 = -27;
            a.M12 = 36;
            a.M13 = 9;
            a.M14 = -54;
            
            a.M21 = 36;
            a.M22 = 3;
            a.M23 = 9;
            a.M24 = 9;
            
            a.M31 = 9;
            a.M32 = 9;
            a.M33 = -36;
            a.M34 = 6;
            
            a.M41 = -24;
            a.M42 = 9;
            a.M43 = 36;
            a.M44 = -12;

            var b = new Matrix44();
            b.M11 = 3402;
            b.M12 = -1269;
            b.M13 = -2187;
            b.M14 = 2484;
            
            b.M21 = -999;
            b.M22 = 1467;
            b.M23 = 351;
            b.M24 = -1971;
            
            b.M31 = -387;
            b.M32 = 81;
            b.M33 = 1674;
            b.M34 = -693;
            
            b.M41 = 1584;
            b.M42 = -621;
            b.M43 = -1863;
            b.M44 = 1737;

            this.TestMultiplication(a, a, b);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// multiplication opperators and functions yield the same results as a
        /// manual multiplication calculation.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomMatrix44();
                var b = GetNextRandomMatrix44();

                var c = new Matrix44(
                    a.M11 / b.M11, 
                    a.M12 / b.M12, 
                    a.M13 / b.M13, 
                    a.M14 / b.M14,
                    a.M21 / b.M21, 
                    a.M22 / b.M22, 
                    a.M23 / b.M23, 
                    a.M24 / b.M24,
                    a.M31 / b.M31, 
                    a.M32 / b.M32, 
                    a.M33 / b.M33, 
                    a.M34 / b.M34,
                    a.M41 / b.M41, 
                    a.M42 / b.M42, 
                    a.M43 / b.M43, 
                    a.M44 / b.M44
                    );

                this.TestMultiplication(a, b, c);
            }
        }


        // Test Operator: Division //-----------------------------------------//

        /// <summary>
        /// Helper method for testing division.
        /// </summary>
        void TestDivision (Matrix44 a, Matrix44 b, Matrix44 expected )
        {
            // This test asserts the following:
            //   a / b == expected

            var result_1a = a / b;

            Matrix44 result_1b; Matrix44.Divide(ref a, ref b, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example using whole numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_i ()
        {
            Fixed32 r = 10;
            Fixed32 s = -40;
            Fixed32 t = 1;
            Fixed32 u = -400;

            Fixed32 x = 2000;
            Fixed32 y = 200;
            Fixed32 z = -5;

            var a = new Matrix44(x, y, x, x, r, s, t, u, r, s, t, u, r, s, t, u);
            var b = new Matrix44(y, z, x, z, r, s, t, u, r, s, t, u, r, s, t, u);
            var c = new Matrix44(r, s, t, u, r, s, t, u, r, s, t, u, r, s, t, u);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a known example using fractional numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_ii ()
        {
            Fixed32 r = 5;
            Fixed32 s = 4;
            Fixed32 t = ((Fixed32) 1 ) / ((Fixed32) 10);
            Fixed32 u = ((Fixed32) (-1) ) / ((Fixed32) 40 );
            Fixed32 v = -20;
            Fixed32 w = 100;
            Fixed32 x = 2000;
            Fixed32 y = 200;
            Fixed32 z = -5;

            var a = new Matrix44(y, z, w, v, r, s, t, u, r, s, t, u, r, s, t, u);
            var b = new Matrix44(x, y, z, z, r, s, t, u, r, s, t, u, r, s, t, u);
            var c = new Matrix44(t, u, v, s, r, s, t, u, r, s, t, u, r, s, t, u);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// division opperators and functions yield the same results as a
        /// manual addition division.
        /// </summary>
        [Test]
        public void TestOperator_Division_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomMatrix44();
                var b = GetNextRandomMatrix44();

                var c = new Matrix44(
                    a.M11 / b.M11, 
                    a.M12 / b.M12, 
                    a.M13 / b.M13, 
                    a.M14 / b.M14,
                    a.M21 / b.M21, 
                    a.M22 / b.M22, 
                    a.M23 / b.M23, 
                    a.M24 / b.M24,
                    a.M31 / b.M31, 
                    a.M32 / b.M32, 
                    a.M33 / b.M33, 
                    a.M34 / b.M34,
                    a.M41 / b.M41, 
                    a.M42 / b.M42, 
                    a.M43 / b.M43, 
                    a.M44 / b.M44
                    );

                this.TestDivision(a, b, c);
            }
        }

        /// <summary>
        /// Assert that, running the Lerp function on a number of randomly
        /// generated pairs of Matrix44 objects for a range of weighting amounts, 
        /// yields the same results as those obtained from performing a manual 
        /// Lerp calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_i ()
        {
            for(Int32 j = 0; j < 100; ++j)
            {
                Fixed32 delta = j;

                delta = delta / 100;

                for(Int32 i = 0; i < 100; ++i)
                {
                    Matrix44 a = GetNextRandomMatrix44();
                    Matrix44 b = GetNextRandomMatrix44();

                    Matrix44 result;
                    Matrix44.Lerp (ref a, ref b, delta, out result);

                    Matrix44 expected = a + ( ( b - a ) * delta );

                    AssertEqualWithinReason(result, expected);
                }
            }
        }

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_ii ()
        {
            Matrix44 a = GetNextRandomMatrix44();
            Matrix44 b = GetNextRandomMatrix44();

            Fixed32 half; RealMaths.Half(out half);

            var tests = new Fixed32[] { 2, half + 1, -half, -1 };

            foreach( var weighting in tests )
            {
                Matrix44 result; 
                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Matrix44.Lerp (
                            ref a, ref b, weighting, out result)
                    );
            }
        }    }
    /// <summary>
    /// 
    /// </summary>
    [TestFixture]
    public class QuaternionTests
    {
        /// <summary>
        /// The random number generator used for testing.
        /// </summary>
        static readonly System.Random rand;

        /// <summary>
        /// Static constructor used to ensure that the random number generator
        /// always gets initilised with the same seed, making the tests
        /// behave in a deterministic manner.
        /// </summary>
        static QuaternionTests ()
        {
            rand = new System.Random(0);
        }

        /// <summary>
        /// Helper function for getting the next random Fixed32 value.
        /// </summary>
        static Fixed32 GetNextRandomFixed32 ()
        {
            Fixed32 randomValue = rand.NextFixed32();

            Fixed32 zero = 0;
            Fixed32 multiplier = 1000;

            randomValue *= multiplier;

            Boolean randomBoolean = (rand.Next(0, 1) == 0) ? true : false;

            if( randomBoolean )
                randomValue = zero - randomValue;

            return randomValue;
        }

        /// <summary>
        /// Helper function for getting the next random Quaternion.
        /// </summary>
        internal static Quaternion GetNextRandomQuaternion ()
        {
            Fixed32 a = GetNextRandomFixed32();
            Fixed32 b = GetNextRandomFixed32();
            Fixed32 c = GetNextRandomFixed32();
            Fixed32 d = GetNextRandomFixed32();

            return new Quaternion(a, b, c, d);
        }

        /// <summary>
        /// Helper to encapsulate asserting that two Quaternions are equal.
        /// </summary>
        internal static void AssertEqualWithinReason (Quaternion a, Quaternion b)
        {
            Fixed32 tolerance; RealMaths.TestTolerance(out tolerance);

            Assert.That(a.X, Is.EqualTo(b.X).Within(tolerance));
            Assert.That(a.Y, Is.EqualTo(b.Y).Within(tolerance));
            Assert.That(a.Z, Is.EqualTo(b.Z).Within(tolerance));
            Assert.That(a.W, Is.EqualTo(b.W).Within(tolerance));
        }
        

        // Test: StructLayout //----------------------------------------------//

        /// <summary>
        /// This test makes sure that the struct layout has been defined
        /// correctly.
        /// </summary>
        [Test]
        public void Test_StructLayout_i ()
        {
            Type t = typeof(Quaternion);

            Assert.That(
                t.StructLayoutAttribute.Value, 
                Is.EqualTo(LayoutKind.Sequential));
        }

        /// <summary>
        /// This test makes sure that when examining the memory addresses of the 
        /// X, Y, Z and W member variables of a number of randomly generated 
        /// Quaterion objects the results are as expected. 
        /// </summary>
        [Test]
        public unsafe void Test_StructLayout_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Quaternion quat = GetNextRandomQuaternion();

                GCHandle h_quat = GCHandle.Alloc(quat, GCHandleType.Pinned);

                IntPtr quatAddress = h_quat.AddrOfPinnedObject();

                Fixed32[] data = new Fixed32[4];

                // nb: when Fixed32 and Half are moved back into the main
                //     dev branch there will be need for an extension method for
                //     Marshal that will perform the copy for those types. 
                MarshalHelper.Copy(quatAddress, data, 0, 4);
                Assert.That(data[0], Is.EqualTo(quat.X));
                Assert.That(data[1], Is.EqualTo(quat.Y));
                Assert.That(data[2], Is.EqualTo(quat.Z));
                Assert.That(data[3], Is.EqualTo(quat.W));
                
                h_quat.Free();
            }
        }

        [Test]
        public void Test_Constructors ()
        {
            Assert.That(true, Is.EqualTo(false));
        }

        [Test]
        public void TestMemberFn_ToString ()
        {
            Assert.That(true, Is.EqualTo(false));
        }

        [Test]
        public void TestMemberFn_GetHashCode ()
        {
            Assert.That(true, Is.EqualTo(false));
        }

        // Test Constant: Identity //-----------------------------------------//

        /// <summary>
        /// Tests to make sure that a Quaternion initilised using the Identity 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Identity_i ()
        {
            Quaternion result = Quaternion.Identity;
            Quaternion expected = new Quaternion (
                0, 0, 0, 1);

            AssertEqualWithinReason(result, expected);
        }        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateTranslation_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromAxisAngle_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromYawPitchRoll_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_CreateFromRotationMatrix_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Conjugate //---------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Conjugate_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Inverse //-----------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Inverse_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Distance //----------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Concatenate //-------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Concatenate_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Static Fn: Normalise //---------------------------------------//

        /// <summary>
        /// todo
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_i ()
        {
            throw new InconclusiveException("Not Implemented");
        }

        // Test Operator: Equality //-----------------------------------------//

        /// <summary>
        /// Helper method for testing equality.
        /// </summary>
        void TestEquality (Quaternion a, Quaternion b, Boolean expected )
        {
            // This test asserts the following:
            //   (a == b) == expected
            //   (b == a) == expected
            //   (a != b) == !expected
            //   (b != a) == !expected

            Boolean result_1a = (a == b);
            Boolean result_1b = (a.Equals(b));
            Boolean result_1c = (a.Equals((Object)b));
            
            Boolean result_2a = (b == a);
            Boolean result_2b = (b.Equals(a));
            Boolean result_2c = (b.Equals((Object)a));

            Boolean result_3a = (a != b);
            Boolean result_4a = (b != a);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_1c, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
            Assert.That(result_2c, Is.EqualTo(expected));
            Assert.That(result_3a, Is.EqualTo(!expected));
            Assert.That(result_4a, Is.EqualTo(!expected));
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of TRUE when two equal  
        /// Quaternion objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_i ()
        {
            var a = new Quaternion(44, -54, -22, 11);
            var b = new Quaternion(44, -54, -22, 11);

            Boolean expected = true;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of FALSE when two unequal  
        /// Quaternion objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_ii ()
        {
            var a = new Quaternion(44, 54, 2, 11);
            var b = new Quaternion(44, -54, 2, -1);

            Boolean expected = false;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Tests to make sure that all the equality opperators and functions 
        /// yield the expected result of TRUE when used on a number of randomly 
        /// generated pairs of equal Quaternion objects.
        /// </summary>
        [Test]
        public void TestOperator_Equality_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomQuaternion();

                Quaternion b = a;

                this.TestEquality(a, b, true);
            }
        }


        // Test Operator: Addition //-----------------------------------------//

        /// <summary>
        /// Helper method for testing addition.
        /// </summary>
        void TestAddition (Quaternion a, Quaternion b, Quaternion expected )
        {
            // This test asserts the following:
            //   a + b == expected
            //   b + a == expected

            var result_1a = a + b;
            var result_2a = b + a;

            Quaternion result_1b; Quaternion.Add(ref a, ref b, out result_1b);
            Quaternion result_2b; Quaternion.Add(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the addition opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_i ()
        {
            var a = new Quaternion(3, -6, 44, 11);
            var b = new Quaternion(-6, 12, 18, -3);

            var expected = new Quaternion(-3, 6, 62, 8);

            this.TestAddition(a, b, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving the zero quaternion, all the 
        /// addition opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_ii ()
        {
            var a = new Quaternion(-2313, 88, 199, 42);

            var expected = a;

            this.TestAddition(a, Quaternion.Identity, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving two zero quaternions, all the 
        /// addition opperators and functions yield the correct result of zero.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iii ()
        {
            this.TestAddition(Quaternion.Identity, Quaternion.Identity, Quaternion.Identity);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// addition opperators and functions yield the same results as a
        /// manual addition calculation.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomQuaternion();
                var b = GetNextRandomQuaternion();

                var expected = new Quaternion(
                    a.X + b.X, a.Y + b.Y, a.Z + b.Z, a.W + b.W);

                this.TestAddition(a, b, expected);
            }
        }

        // Test Operator: Subtraction //--------------------------------------//
        
        /// <summary>
        /// Helper method for testing subtraction.
        /// </summary>
        void TestSubtraction (Quaternion a, Quaternion b, Quaternion expected )
        {
            // This test asserts the following:
            //   a - b == expected
            //   b - a == -expected

            var result_1a = a - b;
            var result_2a = b - a;

            Quaternion result_1b; Quaternion.Subtract(ref a, ref b, out result_1b);
            Quaternion result_2b; Quaternion.Subtract(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(-expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(-expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the subtraction opperators
        /// and functions yield the correct result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_i ()
        {
            var a = new Quaternion(12, -4, 14, 18);
            var b = new Quaternion(15, 11, 7, 27);
            var expected = new Quaternion(-3, -15, 7, -9);
            this.TestSubtraction(a, b, expected);

            var c = new Quaternion(-423, 342, 7, -800);
            this.TestSubtraction(c, Quaternion.Identity, c);
        }

        /// <summary>
        /// Assert that when subtracting the zero quaternion fromt the zero quaternion, 
        /// all the subtraction opperators and functions yield the correct 
        /// result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_ii ()
        {
            this.TestSubtraction(Quaternion.Identity, Quaternion.Identity, Quaternion.Identity);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// subtraction opperators and functions yield the same results as a
        /// manual subtraction calculation.
        /// </summary>
        [Test]
        public void TestOperator_Subtraction_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomQuaternion();
                var b = GetNextRandomQuaternion();

                var expected = new Quaternion(
                    a.X - b.X, a.Y - b.Y, a.Z - b.Z, a.W - b.W);

                this.TestSubtraction(a, b, expected);
            }
        }

        // Test Operator: Negation //-----------------------------------------//
        
        /// <summary>
        /// Helper method for testing negation.
        /// </summary>
        void TestNegation (Quaternion a, Quaternion expected )
        {
            // This test asserts the following:
            //   -a == expected

            var result_1a = -a;

            Quaternion result_1b; Quaternion.Negate(ref a, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the negation opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_i ()
        {
            Fixed32 r = 3432;
            Fixed32 s = -6218;
            Fixed32 t = -3432;
            Fixed32 u = 6218;

            var a = new Quaternion(r, s, t, u);
            var b = new Quaternion(u, t, s, r);
            var c = new Quaternion(t, u, r, s);
            var d = new Quaternion(s, r, u, t);

            this.TestNegation(a, c);
            this.TestNegation(b, d);
        }

        /// <summary>
        /// Assert that, for known examples involving the zero quaternion, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_ii ()
        {
            Fixed32 t = -3432;
            Fixed32 u = 6218;
            Fixed32 r = 3432;
            Fixed32 s = -6218;

            var c = new Quaternion(t, u, r, s);
            var d = new Quaternion(s, r, u, t);

            this.TestNegation(c, Quaternion.Identity - c);
            this.TestNegation(d, Quaternion.Identity - d);
        }

        /// <summary>
        /// Assert that when negating the zero quaternion, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iii ()
        {
            this.TestNegation(Quaternion.Identity, Quaternion.Identity);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// negation opperators and functions yield the same results as a
        /// manual negation calculation.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomQuaternion();
                this.TestNegation(a, Quaternion.Identity - a);
            }
        }

        // Test Operator: Multiplication //-----------------------------------//

        /// <summary>
        /// Helper method for testing multiplication.
        /// </summary>
        void TestMultiplication (Quaternion a, Quaternion b, Quaternion expected )
        {
            // This test asserts the following:
            //   a * b == expected
            //   b * a == expected

            var result_1a = a * b;
            var result_2a = b * a;

            Quaternion result_1b; Quaternion.Multiply(ref a, ref b, out result_1b);
            Quaternion result_2b; Quaternion.Multiply(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the multiplication opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_i ()
        {
            Fixed32 r = -27;
            Fixed32 s = 36;
            Fixed32 t = 9;
            Fixed32 u = -54;

            Fixed32 x = 3;
            Fixed32 y = 6;
            Fixed32 z = -9;

            var a = new Quaternion(x, y, x, y);
            var b = new Quaternion(z, y, x, z);
            var c = new Quaternion(r, s, t, u);

            this.TestMultiplication(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// multiplication opperators and functions yield the same results as a
        /// manual multiplication calculation.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomQuaternion();
                var b = GetNextRandomQuaternion();

                var c = new Quaternion(
                    a.X * b.X, a.Y * b.Y, a.Z * b.Z, a.W * b.W);

                this.TestMultiplication(a, b, c);
            }
        }


        // Test Operator: Division //-----------------------------------------//

        /// <summary>
        /// Helper method for testing division.
        /// </summary>
        void TestDivision (Quaternion a, Quaternion b, Quaternion expected )
        {
            // This test asserts the following:
            //   a / b == expected

            var result_1a = a / b;

            Quaternion result_1b; Quaternion.Divide(ref a, ref b, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example using whole numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_i ()
        {
            Fixed32 r = 10;
            Fixed32 s = -40;
            Fixed32 t = 1;
            Fixed32 u = -400;

            Fixed32 x = 2000;
            Fixed32 y = 200;
            Fixed32 z = -5;

            var a = new Quaternion(x, y, x, x);
            var b = new Quaternion(y, z, x, z);
            var c = new Quaternion(r, s, t, u);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a known example using fractional numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_ii ()
        {
            Fixed32 s = 4;
            Fixed32 t = ((Fixed32) 1 ) / ((Fixed32) 10);
            Fixed32 u = ((Fixed32) (-1) ) / ((Fixed32) 40 );
            Fixed32 v = -20;
            Fixed32 w = 100;
            Fixed32 x = 2000;
            Fixed32 y = 200;
            Fixed32 z = -5;

            var a = new Quaternion(y, z, w, v);
            var b = new Quaternion(x, y, z, z);
            var c = new Quaternion(t, u, v, s);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// division opperators and functions yield the same results as a
        /// manual addition division.
        /// </summary>
        [Test]
        public void TestOperator_Division_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomQuaternion();
                var b = GetNextRandomQuaternion();

                var c = new Quaternion(
                    a.X / b.X, a.Y / b.Y, a.Z / b.Z, a.W / b.W);

                this.TestDivision(a, b, c);
            }
        }

        /// <summary>
        /// todo
        /// </summary>
        public static void Slerp (ref Quaternion quaternion1, ref Quaternion quaternion2, Fixed32 amount, out Quaternion result)
        {
            Fixed32 zero = 0;
            Fixed32 one = 1;

            Fixed32 nineninenine;
            RealMaths.FromString("0.999999", out nineninenine);

            Fixed32 a;
            Fixed32 b;
            Fixed32 c = amount;
            
            Fixed32 d = 
                (quaternion1.X * quaternion2.X) + 
                (quaternion1.Y * quaternion2.Y) + 
                (quaternion1.Z * quaternion2.Z) + 
                (quaternion1.W * quaternion2.W);
            
            Boolean flag = false;

            if (d < zero)
            {
                flag = true;
                d = -d;
            }


            if (d >nineninenine)
            {
                b = one - c;
                a = flag ? -c : c;
            }
            else
            {
                Fixed32 e = RealMaths.ArcCos (d);
                Fixed32 f = one / RealMaths.Sin (e);

                b = RealMaths.Sin ((one - c) * e) * f;

                a = flag ? -RealMaths.Sin (c * e) * f : RealMaths.Sin (c * e) * f;
            }

            result.X = (b * quaternion1.X) + (a * quaternion2.X);
            result.Y = (b * quaternion1.Y) + (a * quaternion2.Y);
            result.Z = (b * quaternion1.Z) + (a * quaternion2.Z);
            result.W = (b * quaternion1.W) + (a * quaternion2.W);
        }

        /// <summary>
        /// todo
        /// </summary>
        public static void Lerp (ref Quaternion quaternion1, ref Quaternion quaternion2, Fixed32 amount, out Quaternion result)
        {
            Fixed32 zero = 0;
            Fixed32 one = 1;

            Fixed32 a = amount;
            Fixed32 b = one - a;
            Fixed32 c = 
                (quaternion1.X * quaternion2.X) + 
                (quaternion1.Y * quaternion2.Y) + 
                (quaternion1.Z * quaternion2.Z) + 
                (quaternion1.W * quaternion2.W);
            
            if (c >= zero)
            {
                result.X = (b * quaternion1.X) + (a * quaternion2.X);
                result.Y = (b * quaternion1.Y) + (a * quaternion2.Y);
                result.Z = (b * quaternion1.Z) + (a * quaternion2.Z);
                result.W = (b * quaternion1.W) + (a * quaternion2.W);
            }
            else
            {
                result.X = (b * quaternion1.X) - (a * quaternion2.X);
                result.Y = (b * quaternion1.Y) - (a * quaternion2.Y);
                result.Z = (b * quaternion1.Z) - (a * quaternion2.Z);
                result.W = (b * quaternion1.W) - (a * quaternion2.W);
            }

            Fixed32 d = 
                (result.X * result.X) + 
                (result.Y * result.Y) + 
                (result.Z * result.Z) + 
                (result.W * result.W);

            Fixed32 e = one / RealMaths.Sqrt (d);

            result.X *= e;
            result.Y *= e;
            result.Z *= e;
            result.W *= e;
        }

    }
        /// <summary>
    /// todo
    /// </summary>
    [TestFixture]
    public class Vector2Tests
    {
        /// <summary>
        /// The random number generator used for testing.
        /// </summary>
        static readonly System.Random rand;

        /// <summary>
        /// Static constructor used to ensure that the random number generator
        /// always gets initilised with the same seed, making the tests
        /// behave in a deterministic manner.
        /// </summary>
        static Vector2Tests ()
        {
            rand = new System.Random(0);
        }

        /// <summary>
        /// Helper function for getting the next random Fixed32 value.
        /// </summary>
        static Fixed32 GetNextRandomFixed32 ()
        {
            Fixed32 randomValue = rand.NextFixed32();

            Fixed32 zero = 0;
            Fixed32 multiplier = 1000;

            randomValue *= multiplier;

            Boolean randomBoolean = (rand.Next(0, 1) == 0) ? true : false;

            if( randomBoolean )
                randomValue = zero - randomValue;

            return randomValue;
        }

        /// <summary>
        /// Helper function for getting the next random Vector2.
        /// </summary>
        static Vector2 GetNextRandomVector2 ()
        {
            Fixed32 a = GetNextRandomFixed32();
            Fixed32 b = GetNextRandomFixed32();

            return new Vector2(a, b);
        }

        /// <summary>
        /// Helper to encapsulate asserting that two Vector2s are equal.
        /// </summary>
        static void AssertEqualWithinReason (Vector2 a, Vector2 b)
        {
            Fixed32 tolerance; RealMaths.TestTolerance(out tolerance);

            Assert.That(a.X, Is.EqualTo(b.X).Within(tolerance));
            Assert.That(a.Y, Is.EqualTo(b.Y).Within(tolerance));
        }
        

        // Test: StructLayout //----------------------------------------------//

        /// <summary>
        /// This test makes sure that the struct layout has been defined
        /// correctly.
        /// </summary>
        [Test]
        public void Test_StructLayout_i ()
        {
            Type t = typeof(Vector2);

            Assert.That(
                t.StructLayoutAttribute.Value, 
                Is.EqualTo(LayoutKind.Sequential));
        }

        /// <summary>
        /// This test makes sure that when examining the memory addresses of the 
        /// X and Y member variables of a number of randomly generated Vector2
        /// objects the results are as expected. 
        /// </summary>
        [Test]
        public unsafe void Test_StructLayout_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector2 vec = GetNextRandomVector2();

                GCHandle h_vec = GCHandle.Alloc(vec, GCHandleType.Pinned);

                IntPtr vecAddress = h_vec.AddrOfPinnedObject();

                Fixed32[] data = new Fixed32[2];

                // nb: when Fixed32 and Half are moved back into the main
                //     dev branch there will be need for an extension method for
                //     Marshal that will perform the copy for those types. 
                MarshalHelper.Copy(vecAddress, data, 0, 2);
                Assert.That(data[0], Is.EqualTo(vec.X));
                Assert.That(data[1], Is.EqualTo(vec.Y));
                
                h_vec.Free();
            }
        }

        // Test: Constructors //----------------------------------------------//

        /// <summary>
        /// This test goes though each public constuctor and ensures that the 
        /// data members of the structure have been properly set.
        /// </summary>
        [Test]
        public void Test_Constructors_i ()
        {
            {
                // Test default values
                Vector2 a = new Vector2();
                Assert.That(a, Is.EqualTo(Vector2.Zero));
            }
            {
                // Test Vector2( Fixed32, Fixed32 )
                Fixed32 u = -189;
                Fixed32 v = 429;
                Vector2 c = new Vector2(u, v);
                Assert.That(c.X, Is.EqualTo(u));
                Assert.That(c.Y, Is.EqualTo(v));
            }
            {
                // Test no constructor
                Vector2 e;
                e.X = 0;
                e.Y = 0;
                Assert.That(e, Is.EqualTo(Vector2.Zero));
            }
        }

        // Test Member Fn: ToString //----------------------------------------//

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i ()
        {
            Vector2 a = new Vector2(42, -17);

            String result = a.ToString();

            String expected = "{X:42 Y:-17}";

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: GetHashCode //-------------------------------------//

        /// <summary>
        /// Makes sure that the hashing function is good by testing 10,000
        /// random scenarios and ensuring that there are no more than 10
        /// collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            var hs1 = new System.Collections.Generic.HashSet<Vector2>();
            var hs2 = new System.Collections.Generic.HashSet<Int32>();

            for(Int32 i = 0; i < 10000; ++i)
            {
                var a = GetNextRandomVector2();

                hs1.Add(a);
                hs2.Add(a.GetHashCode());
            }

            Assert.That(hs1.Count, Is.EqualTo(hs2.Count).Within(10));
        }

        // Test Member Fn: Length //------------------------------------------//

        /// <summary>
        /// Tests that for a known example the Length member function yields
        /// the correct result.
        /// </summary>
        [Test]
        public void TestMemberFn_Length_i ()
        {
            Vector2 a = new Vector2(3, -4);

            Fixed32 expected = 5;

            Fixed32 result = a.Length();

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: LengthSquared //-----------------------------------//

        /// <summary>
        /// Tests that for a known example the LengthSquared member function 
        /// yields the correct result.
        /// </summary>
        [Test]
        public void TestMemberFn_LengthSquared_i ()
        {
            Vector2 a = new Vector2(3, -4);

            Fixed32 expected = 25;

            Fixed32 result = a.LengthSquared();

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: IsUnit //------------------------------------------//

        /// <summary>
        /// Tests that for the simple vectors the IsUnit member function
        /// returns the correct result of TRUE.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_i ()
        {
            Vector2 a = new Vector2( 1,  0);
            Vector2 b = new Vector2(-1,  0);
            Vector2 c = new Vector2( 0,  1);
            Vector2 d = new Vector2( 0, -1);
            Vector2 e = new Vector2( 1,  1);
            Vector2 f = new Vector2( 0,  0);

            Assert.That(a.IsUnit(), Is.EqualTo(true));
            Assert.That(b.IsUnit(), Is.EqualTo(true));
            Assert.That(c.IsUnit(), Is.EqualTo(true));
            Assert.That(d.IsUnit(), Is.EqualTo(true));

            Assert.That(e.IsUnit(), Is.EqualTo(false));
            Assert.That(f.IsUnit(), Is.EqualTo(false));
        }

        /// <summary>
        /// This test makes sure that the IsUnit member function returns the 
        /// correct result of TRUE for a number of scenarios where the test 
        /// vector is both random and normalised.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector2 a = GetNextRandomVector2();

                Vector2 b; Vector2.Normalise(ref a, out b);

                Assert.That(b.IsUnit(), Is.EqualTo(true));
            }
        }

        /// <summary>
        /// This test ensures that the IsUnit member function correctly
        /// returns TRUE for a collection of vectors, all known to be of unit 
        /// length.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_iii ()
        {
            Fixed32 radius = 1;

            Fixed32 pi; RealMaths.Pi(out pi);

            for( Int32 i = 0; i <= 1000; ++ i)
            {
                Fixed32 theta = 2 * pi * i * radius / 100;

                Fixed32 x = RealMaths.Sin(theta);
                Fixed32 y = RealMaths.Cos(theta);               

                Assert.That(
                    new Vector2(x,  y).IsUnit(), 
                    Is.EqualTo(true));
            }
        }

        /// <summary>
        /// This test makes sure that the IsUnit member function returns the 
        /// correct result of FALSE for a number of scenarios where the test 
        /// vector is randomly generated and not normalised.  It's highly
        /// unlikely that the random generator will create a unit vector!
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_iv ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector2 a = GetNextRandomVector2();

                Assert.That(a.IsUnit(), Is.EqualTo(false));
            }
        }
            
        // Test Constant: Zero //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector2 initilised using the Zero constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Zero_i ()
        {
            Vector2 result = Vector2.Zero;
            Vector2 expected = new Vector2(0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: One //----------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector2 initilised using the One constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_One_i ()
        {
            Vector2 result = Vector2.One;
            Vector2 expected = new Vector2(1, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitX //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector2 initilised using the UnitX 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitX_i ()
        {
            Vector2 result = Vector2.UnitX;
            Vector2 expected = new Vector2(1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitY //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector2 initilised using the UnitY
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitY_i ()
        {
            Vector2 result = Vector2.UnitY;
            Vector2 expected = new Vector2(0, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Static Fn: Distance //----------------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the Distance method
        /// yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_Distance_i ()
        {
            {
                Vector2 a = new Vector2(0, 4);
                Vector2 b = new Vector2(3, 0);

                Fixed32 expected = 5;
                Fixed32 result;

                Vector2.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector2 a = new Vector2(0, -4);
                Vector2 b = new Vector2(3, 0);

                Fixed32 expected = 5;
                Fixed32 result;

                Vector2.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector2 a = new Vector2(0, -4);
                Vector2 b = new Vector2(-3, 0);

                Fixed32 expected = 5;
                Fixed32 result;

                Vector2.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector2 a = Vector2.Zero;

                Fixed32 expected = 0;
                Fixed32 result;

                Vector2.Distance(ref a, ref a, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Distance method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Distance_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector2 a = GetNextRandomVector2();

                Fixed32 expected =
                    RealMaths.Sqrt((a.X * a.X) + (a.Y * a.Y));

                Assert.That(a.Length(), Is.EqualTo(expected));
            }
        }

        // Test Static Fn: DistanceSquared //---------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the DistanceSquared
        /// method yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_DistanceSquared_i ()
        {
            {
                Vector2 a = new Vector2(0, 4);
                Vector2 b = new Vector2(3, 0);

                Fixed32 expected = 25;
                Fixed32 result;

                Vector2.DistanceSquared(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector2 a = Vector2.Zero;

                Fixed32 expected = 0;
                Fixed32 result;

                Vector2.DistanceSquared(ref a, ref a, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }


        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// DistanceSquared method yeilds the same results as those obtained
        /// from performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_DistanceSquared_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector2 a = GetNextRandomVector2();
                Vector2 b = GetNextRandomVector2();

                Vector2 c = b - a;

                Fixed32 expected = (c.X * c.X) + (c.Y * c.Y);
                Fixed32 result;

                Vector2.DistanceSquared(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        // Test Static Fn: Dot //---------------------------------------------//

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Dot method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector2 a = GetNextRandomVector2();
                Vector2 b = GetNextRandomVector2();

                Fixed32 expected = (a.X * b.X) + (a.Y * b.Y);
                Fixed32 result; Vector2.Dot(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        /// <summary>
        /// Assert that two unit vectors pointing in opposing directions yeild a
        /// dot product of negative one.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_ii ()
        {
            Vector2 a = new Vector2(1, 0);
            Vector2 b = new Vector2(-1, 0);

            Fixed32 expected = -1;
            Fixed32 result; Vector2.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that two unit vectors pointing in the same direction yeild a
        /// dot product of one.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_iii ()
        {
            Vector2 a = new Vector2(1, 0);
            Vector2 b = new Vector2(1, 0);

            Fixed32 expected = 1;
            Fixed32 result; Vector2.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that two perpendicular unit vectors yeild a dot product of
        /// zero.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_iv ()
        {
            Vector2 a = new Vector2(1, 0);
            Vector2 b = new Vector2(0, 1);

            Fixed32 expected = 0;
            Fixed32 result; Vector2.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Static Fn: Normalise //---------------------------------------//

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_i()
        {
            {
                Vector2 a = Vector2.Zero;

                Vector2 b;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException),
                    () =>
                    Vector2.Normalise(ref a, out b)
                );
            }

            {
                Vector2 a = new Vector2(
                    Fixed32.MaxValue,
                    Fixed32.MaxValue);

                Vector2 b;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException),
                    () =>
                    Vector2.Normalise(ref a, out b)
                );
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Normalise method yeilds a unit vector (with length equal to one);
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_ii ()
        {
            Fixed32 epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector2 a = GetNextRandomVector2();

                Vector2 b; Vector2.Normalise(ref a, out b);
                Fixed32 expected = 1;
                Fixed32 result1 = b.Length();
                Assert.That(result1, Is.EqualTo(expected).Within(epsilon));

                // The normalise function takes both a ref and out parameter,
                // need to check that if we pass in the same value as both
                // parameters we get the same results.
                Vector2 c = a;
                Vector2.Normalise(ref c, out c);
                Fixed32 result2 = c.Length();
                Assert.That(result2, Is.EqualTo(expected).Within(epsilon));
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Normalise method yeilds a vector, which when multipled by the
        /// length of the original vector results in the same vector as the
        /// original vector;
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_iii ()
        {
            Fixed32 epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector2 a = GetNextRandomVector2();
                Fixed32 l = a.Length();
                Vector2 expected = a;

                Vector2 b; Vector2.Normalise(ref a, out b);
                Vector2 result1 = b * l;
                AssertEqualWithinReason(result1, expected);

                Vector2 c = a;

                // The normalise function takes both a ref and out parameter,
                // need to check that if we pass in the same value as both
                // parameters we get the same results.
                Vector2.Normalise(ref c, out c);
                Vector2 result2 = c * l;
                AssertEqualWithinReason(result2, expected);
            }
        }

        // Test Static Fn: Reflect //-----------------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the Reflect method
        /// yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_Reflect_i ()
        {
            {
                Vector2 incident = new Vector2(20, -5);

                Vector2 normal = new Vector2(1, -1);
                Vector2.Normalise(ref normal, out normal);

                Vector2 expected = new Vector2(-5, 20);
                Vector2 result;
                Vector2.Reflect(ref incident, ref normal, out result);

                AssertEqualWithinReason(result, expected);
            }

            {
                Vector2 incident = new Vector2(20, -5);

                Vector2 normal = new Vector2(2, -1);
                Vector2.Normalise(ref normal, out normal);

                Vector2 expected = new Vector2(-16, 13);
                Vector2 result;
                Vector2.Reflect(ref incident, ref normal, out result);

                AssertEqualWithinReason(result, expected);
            }

            {
                Vector2 incident = Vector2.Zero;

                Vector2 normal = new Vector2(1, 0);

                Vector2 result;
                Vector2.Reflect(ref incident, ref normal, out result);

                AssertEqualWithinReason(result, Vector2.Zero);
            }
        }


        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Reflect method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Reflect_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector2 a = GetNextRandomVector2();

                Vector2 b = GetNextRandomVector2();

                Vector2.Normalise(ref b, out b);

                Vector2 result;
                Vector2.Reflect(ref a, ref b, out result);

                Fixed32 dot;
                Vector2.Dot(ref a, ref b, out dot);

                Vector2 expected = a - (2 * dot * b);

                AssertEqualWithinReason(result, expected);
            }
        }

        /// <summary>
        /// Assert that an argument exception is thrown if the value passed in
        /// to the normal parameter is not normalised.
        /// </summary>
        [Test]
        public void TestStaticFn_Reflect_iii ()
        {
            Vector2 incident = GetNextRandomVector2();
            Vector2 normal = new Vector2(12, -241);

            Vector2 result;

            Assert.Throws(
                typeof(ArgumentOutOfRangeException),
                () =>
                Vector2.Reflect(ref incident, ref normal, out result)
            );
        }

        // Test Static Fn: TransformMatrix44 //-------------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformMatix44_i ()
        {
            Vector2 position = new Vector2 (8, 70);

            Single pi; RealMaths.Pi (out pi);

            Matrix44 rotmati = Matrix44.Identity;
            Matrix44 rotmatx; Matrix44.CreateRotationX(pi, out rotmatx);
            Matrix44 rotmaty; Matrix44.CreateRotationY(pi, out rotmaty);
            Matrix44 rotmatxy = rotmatx * rotmaty;

            Vector2 expected1 = new Vector2 ( 8,  70);
            Vector2 expected2 = new Vector2 ( 8, -70);
            Vector2 expected3 = new Vector2 (-8,  70);
            Vector2 expected4 = new Vector2 (-8, -70);

            Vector2 test1; Vector2.Transform (ref position, ref rotmati, out test1);
            Vector2 test2; Vector2.Transform (ref position, ref rotmatx, out test2);
            Vector2 test3; Vector2.Transform (ref position, ref rotmaty, out test3);
            Vector2 test4; Vector2.Transform (ref position, ref rotmatxy, out test4);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
        }

        // Test Static Fn: TransformNormal //---------------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformNormal_i ()
        {
            Vector2 position = new Vector2 (8, 70);
            Vector2.Normalise (ref position, out position);
            Single pi; RealMaths.Pi (out pi);

            Matrix44 rotmati = Matrix44.Identity;
            Matrix44 rotmatx; Matrix44.CreateRotationX(pi, out rotmatx);
            Matrix44 rotmaty; Matrix44.CreateRotationY(pi, out rotmaty);
            Matrix44 rotmatxy = rotmatx * rotmaty;

            Vector2 expected1 = new Vector2 ( 8,  70);
            Vector2 expected2 = new Vector2 ( 8, -70);
            Vector2 expected3 = new Vector2 (-8,  70);
            Vector2 expected4 = new Vector2 (-8, -70);

            Vector2.Normalise (ref expected1, out expected1);
            Vector2.Normalise (ref expected2, out expected2);
            Vector2.Normalise (ref expected3, out expected3);
            Vector2.Normalise (ref expected4, out expected4);

            Vector2 test1; Vector2.TransformNormal (ref position, ref rotmati, out test1);
            Vector2 test2; Vector2.TransformNormal (ref position, ref rotmatx, out test2);
            Vector2 test3; Vector2.TransformNormal (ref position, ref rotmaty, out test3);
            Vector2 test4; Vector2.TransformNormal (ref position, ref rotmatxy, out test4);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);

            // should also work with the standard transform fn
            Vector2 test1n; Vector2.Transform (ref position, ref rotmati, out test1n);
            Vector2 test2n; Vector2.Transform (ref position, ref rotmatx, out test2n);
            Vector2 test3n; Vector2.Transform (ref position, ref rotmaty, out test3n);
            Vector2 test4n; Vector2.Transform (ref position, ref rotmatxy, out test4n);

            AssertEqualWithinReason(test1n, expected1);
            AssertEqualWithinReason(test2n, expected2);
            AssertEqualWithinReason(test3n, expected3);
            AssertEqualWithinReason(test4n, expected4);
        }

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformNormal_ii ()
        {
            Matrix44 rotmat = Matrix44.Identity;
            Vector2 normal = new Vector2 (21, -532);
            Vector2 result;
            Assert.Throws(
                typeof(ArgumentOutOfRangeException),
                () =>
                Vector2.TransformNormal(ref normal, ref rotmat, out result)
            );
        }

        // Test Static Fn: TransformQuaternion //-----------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformQuaternion_i ()
        {
            Vector2 position = new Vector2 (8, 70);
            Single pi; RealMaths.Pi (out pi);

            Quaternion quatmati = new Quaternion (0, 0, 0, 1);
            Quaternion quatmatx = new Quaternion (1, 0, 0, 0);
            Quaternion quatmaty = new Quaternion (0, 1, 0, 0);
            Quaternion quatmatxy = new Quaternion (0, 0, 1, 0);

            Vector2 expected1 = new Vector2 ( 8,  70);
            Vector2 expected2 = new Vector2 ( 8, -70);
            Vector2 expected3 = new Vector2 (-8,  70);
            Vector2 expected4 = new Vector2 (-8, -70);

            Vector2 test1; Vector2.Transform (ref position, ref quatmati, out test1);
            Vector2 test2; Vector2.Transform (ref position, ref quatmatx, out test2);
            Vector2 test3; Vector2.Transform (ref position, ref quatmaty, out test3);
            Vector2 test4; Vector2.Transform (ref position, ref quatmatxy, out test4);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
        }

        // Test Operator: Equality //-----------------------------------------//

        /// <summary>
        /// Helper method for testing equality.
        /// </summary>
        void TestEquality (Vector2 a, Vector2 b, Boolean expected )
        {
            // This test asserts the following:
            //   (a == b) == expected
            //   (b == a) == expected
            //   (a != b) == !expected
            //   (b != a) == !expected

            Boolean result_1a = (a == b);
            Boolean result_1b = (a.Equals(b));
            Boolean result_1c = (a.Equals((Object)b));
            
            Boolean result_2a = (b == a);
            Boolean result_2b = (b.Equals(a));
            Boolean result_2c = (b.Equals((Object)a));

            Boolean result_3a = (a != b);
            Boolean result_4a = (b != a);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_1c, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
            Assert.That(result_2c, Is.EqualTo(expected));
            Assert.That(result_3a, Is.EqualTo(!expected));
            Assert.That(result_4a, Is.EqualTo(!expected));
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of TRUE when two equal  
        /// Vector2 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_i ()
        {
            var a = new Vector2(44, -54);
            var b = new Vector2(44, -54);

            Boolean expected = true;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of FALSE when two unequal  
        /// Vector2 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_ii ()
        {
            var a = new Vector2(44, 54);
            var b = new Vector2(44, -54);

            Boolean expected = false;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Tests to make sure that all the equality opperators and functions 
        /// yield the expected result of TRUE when used on a number of randomly 
        /// generated pairs of equal Vector2 objects.
        /// </summary>
        [Test]
        public void TestOperator_Equality_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();

                Vector2 b = a;

                this.TestEquality(a, b, true);
            }
        }


        // Test Operator: Addition //-----------------------------------------//

        /// <summary>
        /// Helper method for testing addition.
        /// </summary>
        void TestAddition (Vector2 a, Vector2 b, Vector2 expected )
        {
            // This test asserts the following:
            //   a + b == expected
            //   b + a == expected

            var result_1a = a + b;
            var result_2a = b + a;

            Vector2 result_1b; Vector2.Add(ref a, ref b, out result_1b);
            Vector2 result_2b; Vector2.Add(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the addition opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_i ()
        {
            var a = new Vector2(3, -6);
            var b = new Vector2(-6, 12);

            var expected = new Vector2(-3, 6);

            this.TestAddition(a, b, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving the zero vector, all the 
        /// addition opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_ii ()
        {
            var a = new Vector2(-2313, 88);

            var expected = a;

            this.TestAddition(a, Vector2.Zero, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving two zero vectors, all the 
        /// addition opperators and functions yield the correct result of zero.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iii ()
        {
            this.TestAddition(Vector2.Zero, Vector2.Zero, Vector2.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// addition opperators and functions yield the same results as a
        /// manual addition calculation.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();
                var b = GetNextRandomVector2();

                var expected = new Vector2(a.X + b.X, a.Y + b.Y);

                this.TestAddition(a, b, expected);
            }
        }

        // Test Operator: Subtraction //--------------------------------------//
        
        /// <summary>
        /// Helper method for testing subtraction.
        /// </summary>
        void TestSubtraction (Vector2 a, Vector2 b, Vector2 expected )
        {
            // This test asserts the following:
            //   a - b == expected
            //   b - a == -expected

            var result_1a = a - b;
            var result_2a = b - a;

            Vector2 result_1b; Vector2.Subtract(ref a, ref b, out result_1b);
            Vector2 result_2b; Vector2.Subtract(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(-expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(-expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the subtraction opperators
        /// and functions yield the correct result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_i ()
        {
            var a = new Vector2(12, -4);
            var b = new Vector2(15, 11);
            var expected = new Vector2(-3, -15);
            this.TestSubtraction(a, b, expected);

            var c = new Vector2(-423, 342);
            this.TestSubtraction(c, Vector2.Zero, c);
        }

        /// <summary>
        /// Assert that when subtracting the zero vector fromt the zero vector, 
        /// all the subtraction opperators and functions yield the correct 
        /// result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_ii ()
        {
            this.TestSubtraction(Vector2.Zero, Vector2.Zero, Vector2.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// subtraction opperators and functions yield the same results as a
        /// manual subtraction calculation.
        /// </summary>
        [Test]
        public void TestOperator_Subtraction_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();
                var b = GetNextRandomVector2();

                var expected = new Vector2(a.X - b.X, a.Y - b.Y);

                this.TestSubtraction(a, b, expected);
            }
        }

        // Test Operator: Negation //-----------------------------------------//
        
        /// <summary>
        /// Helper method for testing negation.
        /// </summary>
        void TestNegation (Vector2 a, Vector2 expected )
        {
            // This test asserts the following:
            //   -a == expected

            var result_1a = -a;

            Vector2 result_1b; Vector2.Negate(ref a, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the negation opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_i ()
        {
            Fixed32 r = 3432;
            Fixed32 s = -6218;
            Fixed32 t = -3432;
            Fixed32 u = 6218;

            var a = new Vector2(r, s);
            var b = new Vector2(u, t);
            var c = new Vector2(t, u);
            var d = new Vector2(s, r);

            this.TestNegation(a, c);
            this.TestNegation(b, d);
        }

        /// <summary>
        /// Assert that, for known examples involving the zero vector, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_ii ()
        {
            Fixed32 t = -3432;
            Fixed32 u = 6218;
            Fixed32 r = 3432;
            Fixed32 s = -6218;

            var c = new Vector2(t, u);
            var d = new Vector2(s, r);

            this.TestNegation(c, Vector2.Zero - c);
            this.TestNegation(d, Vector2.Zero - d);
        }

        /// <summary>
        /// Assert that when negating the zero vector, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iii ()
        {
            this.TestNegation(Vector2.Zero, Vector2.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// negation opperators and functions yield the same results as a
        /// manual negation calculation.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();
                this.TestNegation(a, Vector2.Zero - a);
            }
        }

        // Test Operator: Multiplication //-----------------------------------//

        /// <summary>
        /// Helper method for testing multiplication.
        /// </summary>
        void TestMultiplication (Vector2 a, Vector2 b, Vector2 expected )
        {
            // This test asserts the following:
            //   a * b == expected
            //   b * a == expected

            var result_1a = a * b;
            var result_2a = b * a;

            Vector2 result_1b; Vector2.Multiply(ref a, ref b, out result_1b);
            Vector2 result_2b; Vector2.Multiply(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the multiplication opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_i ()
        {
            Fixed32 r = 18;
            Fixed32 s = -54;

            Fixed32 x = 3;
            Fixed32 y = 6;
            Fixed32 z = -9;

            var a = new Vector2(x, y);
            var b = new Vector2(y, z);
            var c = new Vector2(r, s);

            this.TestMultiplication(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// multiplication opperators and functions yield the same results as a
        /// manual multiplication calculation.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();
                var b = GetNextRandomVector2();

                var c = new Vector2(a.X * b.X, a.Y * b.Y);

                this.TestMultiplication(a, b, c);
            }
        }


        // Test Operator: Division //-----------------------------------------//

        /// <summary>
        /// Helper method for testing division.
        /// </summary>
        void TestDivision (Vector2 a, Vector2 b, Vector2 expected )
        {
            // This test asserts the following:
            //   a / b == expected

            var result_1a = a / b;

            Vector2 result_1b; Vector2.Divide(ref a, ref b, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example using whole numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_i ()
        {
            Fixed32 r = 10;
            Fixed32 s = -40;

            Fixed32 x = 2000;
            Fixed32 y = 200;
            Fixed32 z = -5;

            var a = new Vector2(x, y);
            var b = new Vector2(y, z);
            var c = new Vector2(r, s);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a known example using fractional numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_ii ()
        {
            Fixed32 t = ((Fixed32) 1 ) / ((Fixed32) 10);
            Fixed32 u = ((Fixed32) (-1) ) / ((Fixed32) 40 );
            Fixed32 x = 2000;
            Fixed32 y = 200;
            Fixed32 z = -5;

            var a = new Vector2(y, z);
            var b = new Vector2(x, y);
            var c = new Vector2(t, u);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// division opperators and functions yield the same results as a
        /// manual addition division.
        /// </summary>
        [Test]
        public void TestOperator_Division_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();
                var b = GetNextRandomVector2();

                var c = new Vector2(a.X / b.X, a.Y / b.Y);

                this.TestDivision(a, b, c);
            }
        }

        // Test Static Fn: SmoothStep //--------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();
                var b = GetNextRandomVector2();

                Fixed32 amount1 = 0;
                Vector2 result1;

                Vector2.SmoothStep (
                    ref a, ref b, amount1, out result1);

                AssertEqualWithinReason(result1, a);

                Fixed32 amount2 = 1;
                Vector2 result2;

                Vector2.SmoothStep (
                    ref a, ref b, amount2, out result2);

                AssertEqualWithinReason(result2, b);
            }
        }

        /// <summary>
        /// Assert that, for known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_ii ()
        {
            var a = GetNextRandomVector2();
            var b = GetNextRandomVector2();

            Fixed32 half; RealMaths.Half(out half);

            var tests = new Fixed32[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector2 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector2.SmoothStep (
                            ref a, ref b, amount, out result)
                    );
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_iii ()
        {
            var a = new Vector2( -30, -30 );
            var b = new Vector2( +30, +30 );

            Fixed32 one = 1;

            Fixed32 i;
            RealMaths.FromFraction(1755, 64, out i); // 27.421875
            
            Fixed32 j;
            RealMaths.FromFraction( 165,  8, out j); // 20.625
            
            Fixed32 k;
            RealMaths.FromFraction( 705, 64, out k); // 11.015625

            Fixed32 a0 = 0;
            Fixed32 a1 = (one * 1) / 8;
            Fixed32 a2 = (one * 2) / 8;
            Fixed32 a3 = (one * 3) / 8;
            Fixed32 a4 = (one * 4) / 8;
            Fixed32 a5 = (one * 5) / 8;
            Fixed32 a6 = (one * 6) / 8;
            Fixed32 a7 = (one * 7) / 8;
            Fixed32 a8 = 1;

            Vector2 r0 = a;
            Vector2 r1 = new Vector2( -i, -i );
            Vector2 r2 = new Vector2( -j, -j );
            Vector2 r3 = new Vector2( -k, -k );
            Vector2 r4 = Vector2.Zero;
            Vector2 r5 = new Vector2(  k,  k );
            Vector2 r6 = new Vector2(  j,  j );
            Vector2 r7 = new Vector2(  i,  i );
            Vector2 r8 = b;

            var knownResults = new List<Tuple<Fixed32, Vector2>>
            {
                new Tuple<Fixed32, Vector2>( a0, r0 ),
                new Tuple<Fixed32, Vector2>( a1, r1 ),
                new Tuple<Fixed32, Vector2>( a2, r2 ),
                new Tuple<Fixed32, Vector2>( a3, r3 ),
                new Tuple<Fixed32, Vector2>( a4, r4 ),
                new Tuple<Fixed32, Vector2>( a5, r5 ),
                new Tuple<Fixed32, Vector2>( a6, r6 ),
                new Tuple<Fixed32, Vector2>( a7, r7 ),
                new Tuple<Fixed32, Vector2>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector2 result;

                Vector2.SmoothStep (
                    ref a, ref b, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        // Test Static Fn: CatmullRom //--------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector2();
                var b = GetNextRandomVector2();
                var c = GetNextRandomVector2();
                var d = GetNextRandomVector2();

                Fixed32 amount1 = 0;
                Vector2 result1;

                Vector2.CatmullRom (
                    ref a, ref b, ref c, ref d, amount1, out result1);

                AssertEqualWithinReason(result1, b);

                Fixed32 amount2 = 1;
                Vector2 result2;

                Vector2.CatmullRom (
                    ref a, ref b, ref c, ref d, amount2, out result2);

                AssertEqualWithinReason(result2, c);
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_ii ()
        {
            var a = new Vector2( -90, +30 );
            var b = new Vector2( -30, -30 );
            var c = new Vector2( +30, +30 );
            var d = new Vector2( +90, -30 );

            Fixed32 one = 1;

            Fixed32 u = 15;
            Fixed32 v = (Fixed32) 165  / (Fixed32)  8; // 20.5
            Fixed32 w = (Fixed32) 45   / (Fixed32)  2; // 20.625
            Fixed32 x = (Fixed32) 1755 / (Fixed32) 64; // 27.421875
            Fixed32 y = (Fixed32) 15   / (Fixed32)  2; // 14.5
            Fixed32 z = (Fixed32) 705  / (Fixed32) 64; // 11.015625

            Fixed32 a0 = 0;
            Fixed32 a1 = (one * 1) / 8;
            Fixed32 a2 = (one * 2) / 8;
            Fixed32 a3 = (one * 3) / 8;
            Fixed32 a4 = (one * 4) / 8;
            Fixed32 a5 = (one * 5) / 8;
            Fixed32 a6 = (one * 6) / 8;
            Fixed32 a7 = (one * 7) / 8;
            Fixed32 a8 = 1;

            Vector2 r0 = b;
            Vector2 r1 = new Vector2( -w, -x );
            Vector2 r2 = new Vector2( -u, -v );
            Vector2 r3 = new Vector2( -y, -z );
            Vector2 r4 = Vector2.Zero;
            Vector2 r5 = new Vector2(  y,  z );
            Vector2 r6 = new Vector2(  u,  v );
            Vector2 r7 = new Vector2(  w,  x );
            Vector2 r8 = c;

            var knownResults = new List<Tuple<Fixed32, Vector2>>
            {
                new Tuple<Fixed32, Vector2>( a0, r0 ),
                new Tuple<Fixed32, Vector2>( a1, r1 ),
                new Tuple<Fixed32, Vector2>( a2, r2 ),
                new Tuple<Fixed32, Vector2>( a3, r3 ),
                new Tuple<Fixed32, Vector2>( a4, r4 ),
                new Tuple<Fixed32, Vector2>( a5, r5 ),
                new Tuple<Fixed32, Vector2>( a6, r6 ),
                new Tuple<Fixed32, Vector2>( a7, r7 ),
                new Tuple<Fixed32, Vector2>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector2 result;

                Vector2.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        /// <summary>
        /// Assert that, for known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_iii ()
        {
            var a = GetNextRandomVector2();
            var b = GetNextRandomVector2();
            var c = GetNextRandomVector2();
            var d = GetNextRandomVector2();
            
            Fixed32 half; RealMaths.Half(out half);

            var tests = new Fixed32[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector2 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector2.CatmullRom (
                            ref a, ref b, ref c, ref d, amount, out result)
                );
            }
        }

        /// <summary>
        /// This tests compares results against an example where all the control
        /// points are in a straight line.  In this case the resulting spline
        /// should be a straight line.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_iv ()
        {
            var a = new Vector2( -90, -90 );
            var b = new Vector2( -30, -30 );
            var c = new Vector2( +30, +30 );
            var d = new Vector2( +90, +90 );

            Fixed32 one = 1;

            Fixed32 a0 = 0;
            Fixed32 a1 = (one * 1) / 4;
            Fixed32 a2 = (one * 2) / 4;
            Fixed32 a3 = (one * 3) / 4;
            Fixed32 a4 = 1;

            Vector2 r0 = b;
            Vector2 r1 = new Vector2( -15, -15 );
            Vector2 r2 = Vector2.Zero;
            Vector2 r3 = new Vector2( 15, 15 );
            Vector2 r4 = c;

            var knownResults = new List<Tuple<Fixed32, Vector2>>
            {
                new Tuple<Fixed32, Vector2>( a0, r0 ),
                new Tuple<Fixed32, Vector2>( a1, r1 ),
                new Tuple<Fixed32, Vector2>( a2, r2 ),
                new Tuple<Fixed32, Vector2>( a3, r3 ),
                new Tuple<Fixed32, Vector2>( a4, r4 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector2 result;

                Vector2.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        // Test Static Fn: Hermite //-----------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a  = GetNextRandomVector2();
                var b  = GetNextRandomVector2();

                var c = GetNextRandomVector2();
                var d = GetNextRandomVector2();

                Vector2 an; Vector2.Normalise(ref c, out an);
                Vector2 bn; Vector2.Normalise(ref d, out bn);

                Fixed32 amount1 = 0;
                Vector2 result1;

                Vector2.Hermite (
                    ref a, ref an, ref b, ref bn, amount1, out result1);

                AssertEqualWithinReason(result1, a);

                Fixed32 amount2 = 1;
                Vector2 result2;

                Vector2.Hermite (
                    ref a, ref an, ref b, ref bn, amount2, out result2);

                AssertEqualWithinReason(result2, b);
            }
        }

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_ii ()
        {
            var a = GetNextRandomVector2();
            var b = GetNextRandomVector2();
            var c = GetNextRandomVector2();
            var d = GetNextRandomVector2();

            Vector2 an; Vector2.Normalise(ref c, out an);
            Vector2 bn; Vector2.Normalise(ref d, out bn);

            Fixed32 half; RealMaths.Half(out half);

            var tests = new Fixed32[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector2 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector2.Hermite (
                            ref a, ref an, ref b, ref bn, amount, out result)
                    );
                
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_iii ()
        {
            var a = new Vector2( -100, +50 );
            var b = new Vector2( +100, -50 );

            var c = new Vector2( -10, +5 );
            var d = new Vector2( +10, -5 );

            Vector2 an; Vector2.Normalise(ref c, out an);
            Vector2 bn; Vector2.Normalise(ref d, out bn);

            Fixed32 one = 1;
            
            // 100.1953125
            Fixed32 e = (Fixed32) 51300 / (Fixed32) 512;

            // 50.09765625
            Fixed32 f = (Fixed32) 12825 / (Fixed32) 256;

            // 91.25
            Fixed32 g = (Fixed32) 365 / (Fixed32) 4;

            // 45.625
            Fixed32 h = (Fixed32) 365 / (Fixed32) 8;

            // 75.7421875
            Fixed32 i = (Fixed32) 9695 / (Fixed32) 128;

            // 37.87109375
            Fixed32 j = (Fixed32) 9695 / (Fixed32) 256;

            // 56.25
            Fixed32 k = (Fixed32) 225 / (Fixed32) 4;

            // 28.125
            Fixed32 l = (Fixed32) 225 / (Fixed32) 8;

            // 35.3515625
            Fixed32 m = (Fixed32) 4525 / (Fixed32) 128;

            // 17.67578125
            Fixed32 n = (Fixed32) 4525 / (Fixed32) 256;

            // 15.625
            Fixed32 o = (Fixed32) 125 / (Fixed32) 8;

            // 7.8125
            Fixed32 p = (Fixed32) 125 / (Fixed32) 16;

            // 0.3515625
            Fixed32 q = (Fixed32) 45 / (Fixed32) 128;

            // 0.17578125
            Fixed32 r = (Fixed32) 45 / (Fixed32) 256;

            Fixed32 a0 = 0;
            Fixed32 a1 = (one * 1) / 8;
            Fixed32 a2 = (one * 2) / 8;
            Fixed32 a3 = (one * 3) / 8;
            Fixed32 a4 = (one * 4) / 8;
            Fixed32 a5 = (one * 5) / 8;
            Fixed32 a6 = (one * 6) / 8;
            Fixed32 a7 = (one * 7) / 8;
            Fixed32 a8 = 1;

            Vector2 r0 = b;
            Vector2 r1 = new Vector2(  e, -f );
            Vector2 r2 = new Vector2(  g, -h );
            Vector2 r3 = new Vector2(  i, -j );
            Vector2 r4 = new Vector2(  k, -l );
            Vector2 r5 = new Vector2(  m, -n );
            Vector2 r6 = new Vector2(  o, -p );
            Vector2 r7 = new Vector2( -q,  r );
            Vector2 r8 = c;

            var knownResults = new List<Tuple<Fixed32, Vector2>>
            {
                new Tuple<Fixed32, Vector2>( a0, r0 ),
                new Tuple<Fixed32, Vector2>( a1, r1 ),
                new Tuple<Fixed32, Vector2>( a2, r2 ),
                new Tuple<Fixed32, Vector2>( a3, r3 ),
                new Tuple<Fixed32, Vector2>( a4, r4 ),
                new Tuple<Fixed32, Vector2>( a5, r5 ),
                new Tuple<Fixed32, Vector2>( a6, r6 ),
                new Tuple<Fixed32, Vector2>( a7, r7 ),
                new Tuple<Fixed32, Vector2>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector2 result;

                Vector2.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

                /// <summary>
        /// Assert that, running the Min function on a number of randomly
        /// generated pairs of Vector2 objects, yields the same results as those
        /// obtained from performing a manual Min calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Min ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector2 a = GetNextRandomVector2();
                Vector2 b = a * 2;

                Vector2 result;
                Vector2.Min (ref a, ref b, out result);

                Assert.That(result.X, Is.EqualTo(a.X < b.X ? a.X : b.X ));
                Assert.That(result.Y, Is.EqualTo(a.Y < b.Y ? a.Y : b.Y ));
            }
        }

        /// <summary>
        /// Assert that, running the Max function on a number of randomly
        /// generated pairs of Vector2 objects, yields the same results as those
        /// obtained from performing a manual Max calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Max ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector2 a = GetNextRandomVector2();
                Vector2 b = GetNextRandomVector2();

                Vector2 result;
                Vector2.Max (ref a, ref b, out result);

                Assert.That(result.X, Is.EqualTo(a.X > b.X ? a.X : b.X ));
                Assert.That(result.Y, Is.EqualTo(a.Y > b.Y ? a.Y : b.Y ));
            }
        }

        /// <summary>
        /// Assert that, running the Clamp function on a number of randomly
        /// generated Vector2 objects for a given min-max range, yields
        /// results that fall within that range.
        /// </summary>
        [Test]
        public void TestStaticFn_Clamp_i ()
        {
            Vector2 min = new Vector2(-30, 1);
            Vector2 max = new Vector2(32, 130);

            for(Int32 i = 0; i < 100; ++i)
            {
                Vector2 a = GetNextRandomVector2();

                Vector2 result;
                Vector2.Clamp (ref a, ref min, ref max, out result);

                Assert.That(result.X, Is.LessThanOrEqualTo(max.X));
                Assert.That(result.Y, Is.LessThanOrEqualTo(max.Y));
                Assert.That(result.X, Is.GreaterThanOrEqualTo(min.X));
                Assert.That(result.Y, Is.GreaterThanOrEqualTo(min.Y));
            }
        }

        /// <summary>
        /// Assert that, running the Clamp function on an a Vector2 object known
        /// to fall outside of a given min-max range, yields a result that fall 
        /// within that range.
        /// </summary>
        [Test]
        public void TestStaticFn_Clamp_ii ()
        {
            Vector2 min = new Vector2(-30, 1);
            Vector2 max = new Vector2(32, 130);

            Vector2 a = new Vector2(-100, 1113);

            Vector2 expected = new Vector2(-30, 130);

            Vector2 result;
            Vector2.Clamp (ref a, ref min, ref max, out result);

            Assert.That(result.X, Is.LessThanOrEqualTo(max.X));
            Assert.That(result.Y, Is.LessThanOrEqualTo(max.Y));
            Assert.That(result.X, Is.GreaterThanOrEqualTo(min.X));
            Assert.That(result.Y, Is.GreaterThanOrEqualTo(min.Y));

            AssertEqualWithinReason(result, expected);

        }

        /// <summary>
        /// Assert that, running the Lerp function on a number of randomly
        /// generated pairs of Vector2 objects for a range of weighting amounts, 
        /// yields the same results as those obtained from performing a manual 
        /// Lerp calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_i ()
        {
            for(Int32 j = 0; j < 100; ++j)
            {
                Fixed32 delta = j;

                delta = delta / 100;

                for(Int32 i = 0; i < 100; ++i)
                {
                    Vector2 a = GetNextRandomVector2();
                    Vector2 b = GetNextRandomVector2();

                    Vector2 result;
                    Vector2.Lerp (ref a, ref b, delta, out result);

                    Vector2 expected = a + ( ( b - a ) * delta );

                    AssertEqualWithinReason(result, expected);
                }
            }
        }

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_ii ()
        {
            Vector2 a = GetNextRandomVector2();
            Vector2 b = GetNextRandomVector2();

            Fixed32 half; RealMaths.Half(out half);

            var tests = new Fixed32[] { 2, half + 1, -half, -1 };

            foreach( var weighting in tests )
            {
                Vector2 result; 
                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector2.Lerp (
                            ref a, ref b, weighting, out result)
                    );
            }
        }


    }    /// <summary>
    /// 
    /// </summary>
    [TestFixture]
    public class Vector3Tests
    {
        /// <summary>
        /// The random number generator used for testing.
        /// </summary>
        static readonly System.Random rand;

        /// <summary>
        /// Static constructor used to ensure that the random number generator
        /// always gets initilised with the same seed, making the tests
        /// behave in a deterministic manner.
        /// </summary>
        static Vector3Tests ()
        {
            rand = new System.Random(0);
        }

        /// <summary>
        /// Helper function for getting the next random Fixed32 value.
        /// </summary>
        static Fixed32 GetNextRandomFixed32 ()
        {
            Fixed32 randomValue = rand.NextFixed32();

            Fixed32 zero = 0;
            Fixed32 multiplier = 1000;

            randomValue *= multiplier;

            Boolean randomBoolean = (rand.Next(0, 1) == 0) ? true : false;

            if( randomBoolean )
                randomValue = zero - randomValue;

            return randomValue;
        }

        /// <summary>
        /// Helper function for getting the next random Vector3.
        /// </summary>
        static Vector3 GetNextRandomVector3 ()
        {
            Fixed32 a = GetNextRandomFixed32();
            Fixed32 b = GetNextRandomFixed32();
            Fixed32 c = GetNextRandomFixed32();

            return new Vector3(a, b, c);
        }

        /// <summary>
        /// Helper to encapsulate asserting that two Vector3s are equal.
        /// </summary>
        static void AssertEqualWithinReason (Vector3 a, Vector3 b)
        {
            Fixed32 tolerance; RealMaths.TestTolerance(out tolerance);

            Assert.That(a.X, Is.EqualTo(b.X).Within(tolerance));
            Assert.That(a.Y, Is.EqualTo(b.Y).Within(tolerance));
            Assert.That(a.Z, Is.EqualTo(b.Z).Within(tolerance));
        }
        

        // Test: StructLayout //----------------------------------------------//

        /// <summary>
        /// This test makes sure that the struct layout has been defined
        /// correctly.
        /// </summary>
        [Test]
        public void Test_StructLayout_i ()
        {
            Type t = typeof(Vector3);

            Assert.That(
                t.StructLayoutAttribute.Value, 
                Is.EqualTo(LayoutKind.Sequential));
        }

        /// <summary>
        /// This test makes sure that when examining the memory addresses of the 
        /// X, Y and Z member variables of a number of randomly generated 
        /// Vector3 objects the results are as expected. 
        /// </summary>
        [Test]
        public unsafe void Test_StructLayout_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector3 vec = GetNextRandomVector3();

                GCHandle h_vec = GCHandle.Alloc(vec, GCHandleType.Pinned);

                IntPtr vecAddress = h_vec.AddrOfPinnedObject();

                Fixed32[] data = new Fixed32[3];

                // nb: when Fixed32 and Half are moved back into the main
                //     dev branch there will be need for an extension method for
                //     Marshal that will perform the copy for those types. 
                MarshalHelper.Copy(vecAddress, data, 0, 3);
                Assert.That(data[0], Is.EqualTo(vec.X));
                Assert.That(data[1], Is.EqualTo(vec.Y));
                Assert.That(data[2], Is.EqualTo(vec.Z));
                
                h_vec.Free();
            }
        }

        // Test: Constructors //----------------------------------------------//

        /// <summary>
        /// This test goes though each public constuctor and ensures that the 
        /// data members of the structure have been properly set.
        /// </summary>
        [Test]
        public void Test_Constructors_i ()
        {
            {
                // Test default values
                Vector3 a = new Vector3();
                Assert.That(a, Is.EqualTo(Vector3.Zero));
            }
            {
                // Test Vector3( Fixed32, Fixed32, Fixed32 )
                Fixed32 a = -189;
                Fixed32 b = 429;
                Fixed32 c = 4298;
                Vector3 d = new Vector3(a, b, c);
                Assert.That(d.X, Is.EqualTo(a));
                Assert.That(d.Y, Is.EqualTo(b));
                Assert.That(d.Z, Is.EqualTo(c));
            }
            {
                // Test Vector3( Vector2, Fixed32 )
                Vector2 a = new Vector2(-189, 429);
                Fixed32 b = 4298;
                Vector3 c = new Vector3(a, b);
                Assert.That(c.X, Is.EqualTo(a.X));
                Assert.That(c.Y, Is.EqualTo(a.Y));
                Assert.That(c.Z, Is.EqualTo(b));
            }
            {
                // Test no constructor
                Vector3 a;
                a.X = 0;
                a.Y = 0;
                a.Z = 0;
                Assert.That(a, Is.EqualTo(Vector3.Zero));
            }
        }

        // Test Member Fn: ToString //----------------------------------------//

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i ()
        {
            Vector3 a = new Vector3(42, -17, 13);

            String result = a.ToString();

            String expected = "{X:42 Y:-17 Z:13}";

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: GetHashCode //-------------------------------------//

        /// <summary>
        /// Makes sure that the hashing function is good by testing 10,000
        /// random scenarios and ensuring that there are no more than 10
        /// collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            var hs1 = new System.Collections.Generic.HashSet<Vector3>();
            var hs2 = new System.Collections.Generic.HashSet<Int32>();

            for(Int32 i = 0; i < 10000; ++i)
            {
                var a = GetNextRandomVector3();

                hs1.Add(a);
                hs2.Add(a.GetHashCode());
            }

            Assert.That(hs1.Count, Is.EqualTo(hs2.Count).Within(10));
        }

        // Test Member Fn: Length //------------------------------------------//

        /// <summary>
        /// Tests that for a known example the Length member function yields
        /// the correct result.
        /// </summary>
        [Test]
        public void TestMemberFn_Length_i ()
        {
            Vector3 a = new Vector3(3, -4, 12);

            Fixed32 expected = 13;

            Fixed32 result = a.Length();

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: LengthSquared //-----------------------------------//

        /// <summary>
        /// Tests that for a known example the LengthSquared member function 
        /// yields the correct result.
        /// </summary>
        [Test]
        public void TestMemberFn_LengthSquared_i ()
        {
            Vector3 a = new Vector3(3, -4, 12);

            Fixed32 expected = 169;

            Fixed32 result = a.LengthSquared();

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: IsUnit //------------------------------------------//

        /// <summary>
        /// Tests that for the simple vectors the IsUnit member function
        /// returns the correct result of TRUE.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_i ()
        {
            Vector3 a = new Vector3( 1,  0,  0);
            Vector3 b = new Vector3(-1,  0,  0);
            Vector3 c = new Vector3( 0,  1,  0);
            Vector3 d = new Vector3( 0, -1,  0);
            Vector3 e = new Vector3( 0,  0,  1);
            Vector3 f = new Vector3( 0,  0, -1);
            Vector3 g = new Vector3( 1,  1,  1);
            Vector3 h = new Vector3( 0,  0,  0);

            Assert.That(a.IsUnit(), Is.EqualTo(true));
            Assert.That(b.IsUnit(), Is.EqualTo(true));
            Assert.That(c.IsUnit(), Is.EqualTo(true));
            Assert.That(d.IsUnit(), Is.EqualTo(true));
            Assert.That(e.IsUnit(), Is.EqualTo(true));
            Assert.That(f.IsUnit(), Is.EqualTo(true));

            Assert.That(g.IsUnit(), Is.EqualTo(false));
            Assert.That(h.IsUnit(), Is.EqualTo(false));
        }

        /// <summary>
        /// This test makes sure that the IsUnit member function returns the 
        /// correct result of TRUE for a number of scenarios where the test 
        /// vector is both random and normalised.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector3 a = GetNextRandomVector3();

                Vector3 b; Vector3.Normalise(ref a, out b);

                Assert.That(b.IsUnit(), Is.EqualTo(true));
            }
        }

        /// <summary>
        /// This test ensures that the IsUnit member function correctly
        /// returns TRUE for a collection of vectors, all known to be of unit 
        /// length.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_iii ()
        {
            Fixed32 radius = 1;

            Fixed32 pi; RealMaths.Pi(out pi);

            for( Int32 i = 0; i <= 31; ++ i)
            {
                for( Int32 j = 0; j <= 31; ++ j)
                {
                    Fixed32 theta = 2 * pi * i / 100;
                    Fixed32 phi = 2 * pi * j / 100;

                    Fixed32 x = 
                        RealMaths.Cos(theta) * 
                        RealMaths.Sin(phi) * radius;

                    Fixed32 y = 
                        RealMaths.Sin(theta) * 
                        RealMaths.Sin(phi) * radius;

                    Fixed32 z = 
                        RealMaths.Cos(phi) * radius;                

                    Assert.That(
                        new Vector3( x,  y,  z).IsUnit(), 
                        Is.EqualTo(true));
                }
            }
        }

        /// <summary>
        /// This test makes sure that the IsUnit member function returns the 
        /// correct result of FALSE for a number of scenarios where the test 
        /// vector is randomly generated and not normalised.  It's highly
        /// unlikely that the random generator will create a unit vector!
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_iv ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector3 a = GetNextRandomVector3();

                Assert.That(a.IsUnit(), Is.EqualTo(false));
            }
        }
            
        // Test Constant: Zero //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the Zero constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Zero_i ()
        {
            Vector3 result = Vector3.Zero;
            Vector3 expected = new Vector3(0, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: One //----------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the One constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_One_i ()
        {
            Vector3 result = Vector3.One;
            Vector3 expected = new Vector3(1, 1, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitX //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the UnitX 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitX_i ()
        {
            Vector3 result = Vector3.UnitX;
            Vector3 expected = new Vector3(1, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitY //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the UnitY
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitY_i ()
        {
            Vector3 result = Vector3.UnitY;
            Vector3 expected = new Vector3(0, 1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitZ //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the UnitZ
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitZ_i ()
        {
            Vector3 result = Vector3.UnitZ;
            Vector3 expected = new Vector3(0, 0, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Up //-----------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the Up
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Up_i ()
        {
            Vector3 result = Vector3.Up;
            Vector3 expected = new Vector3(0, 1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Down //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the Down
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Down_i ()
        {
            Vector3 result = Vector3.Down;
            Vector3 expected = new Vector3(0, -1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Right //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the Right
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Right_i ()
        {
            Vector3 result = Vector3.Right;
            Vector3 expected = new Vector3(1, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Left //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the Left
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Left_i ()
        {
            Vector3 result = Vector3.Left;
            Vector3 expected = new Vector3(-1, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Forward //------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the Forward
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Forward_i ()
        {
            Vector3 result = Vector3.Forward;
            Vector3 expected = new Vector3(0, 0, -1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: Backward //-----------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector3 initilised using the Backward
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Backward_i ()
        {
            Vector3 result = Vector3.Backward;
            Vector3 expected = new Vector3(0, 0, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Static Fn: Distance //----------------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the Distance method
        /// yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_Distance_i ()
        {
            {
                Vector3 a = new Vector3(0, 4, 12);
                Vector3 b = new Vector3(3, 0, 0);

                Fixed32 expected = 13;
                Fixed32 result;

                Vector3.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector3 a = new Vector3(0, -4, 12);
                Vector3 b = new Vector3(3, 0, 0);

                Fixed32 expected = 13;
                Fixed32 result;

                Vector3.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector3 a = new Vector3(0, -4, -12);
                Vector3 b = new Vector3(-3, 0, 0);

                Fixed32 expected = 13;
                Fixed32 result;

                Vector3.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector3 a = Vector3.Zero;

                Fixed32 expected = 0;
                Fixed32 result;

                Vector3.Distance(ref a, ref a, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Distance method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Distance_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector3 a = GetNextRandomVector3();

                Fixed32 expected =
                    RealMaths.Sqrt((a.X * a.X) + (a.Y * a.Y) + (a.Z * a.Z));

                Assert.That(a.Length(), Is.EqualTo(expected));
            }
        }

        // Test Static Fn: DistanceSquared //---------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the DistanceSquared
        /// method yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_DistanceSquared_i ()
        {
            {
                Vector3 a = new Vector3(0, 4, 12);
                Vector3 b = new Vector3(3, 0, 0);

                Fixed32 expected = 161;
                Fixed32 result;

                Vector3.DistanceSquared(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector3 a = Vector3.Zero;

                Fixed32 expected = 0;
                Fixed32 result;

                Vector3.DistanceSquared(ref a, ref a, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }


        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// DistanceSquared method yeilds the same results as those obtained
        /// from performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_DistanceSquared_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector3 a = GetNextRandomVector3();
                Vector3 b = GetNextRandomVector3();

                Vector3 c = b - a;

                Fixed32 expected = (c.X * c.X) + (c.Y * c.Y) + (c.Z * c.Z);
                Fixed32 result;

                Vector3.DistanceSquared(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        // Test Static Fn: Dot //---------------------------------------------//

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Dot method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector3 a = GetNextRandomVector3();
                Vector3 b = GetNextRandomVector3();

                Fixed32 expected = (a.X * b.X) + (a.Y * b.Y) + (a.Z * b.Z);
                Fixed32 result; Vector3.Dot(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        /// <summary>
        /// Assert that two unit vectors pointing in opposing directions yeild a
        /// dot product of negative one.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_ii ()
        {
            Vector3 a = new Vector3(0, 0, 1);
            Vector3 b = new Vector3(0, 0, -1);

            Fixed32 expected = -1;
            Fixed32 result; Vector3.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that two unit vectors pointing in the same direction yeild a
        /// dot product of one.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_iii ()
        {
            Vector3 a = new Vector3(0, 0, 1);
            Vector3 b = new Vector3(0, 0, 1);

            Fixed32 expected = 1;
            Fixed32 result; Vector3.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that two perpendicular unit vectors yeild a dot product of
        /// zero.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_iv ()
        {
            Vector3 a = new Vector3(0, 1, 0);
            Vector3 b = new Vector3(0, 0, 1);

            Fixed32 expected = 0;
            Fixed32 result; Vector3.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Static Fn: Normalise //---------------------------------------//

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_i()
        {
            {
                Vector3 a = Vector3.Zero;

                Vector3 b;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException),
                    () =>
                    Vector3.Normalise(ref a, out b)
                );
            }

            {
                Vector3 a = new Vector3(
                    Fixed32.MaxValue,
                    Fixed32.MaxValue,
                    Fixed32.MaxValue);

                Vector3 b;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException),
                    () =>
                    Vector3.Normalise(ref a, out b)
                );
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Normalise method yeilds a unit vector (with length equal to one);
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_ii ()
        {
            Fixed32 epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector3 a = GetNextRandomVector3();

                Vector3 b; Vector3.Normalise(ref a, out b);
                Fixed32 expected = 1;
                Fixed32 result1 = b.Length();
                Assert.That(result1, Is.EqualTo(expected).Within(epsilon));

                // The normalise function takes both a ref and out parameter,
                // need to check that if we pass in the same value as both
                // parameters we get the same results.
                Vector3 c = a;
                Vector3.Normalise(ref c, out c);
                Fixed32 result2 = c.Length();
                Assert.That(result2, Is.EqualTo(expected).Within(epsilon));
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Normalise method yeilds a vector, which when multipled by the
        /// length of the original vector results in the same vector as the
        /// original vector;
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_iii ()
        {
            Fixed32 epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector3 a = GetNextRandomVector3();
                Fixed32 l = a.Length();
                Vector3 expected = a;

                Vector3 b; Vector3.Normalise(ref a, out b);
                Vector3 result1 = b * l;
                AssertEqualWithinReason(result1, expected);

                Vector3 c = a;

                // The normalise function takes both a ref and out parameter,
                // need to check that if we pass in the same value as both
                // parameters we get the same results.
                Vector3.Normalise(ref c, out c);
                Vector3 result2 = c * l;
                AssertEqualWithinReason(result2, expected);
            }
        }

        // Test Static Fn: Cross //-------------------------------------------//
        [Test]
        public void TestStaticFn_Cross_i ()
        {
            Assert.That(true, Is.EqualTo(false));
        }

        // Test Static Fn: Reflect //-----------------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the Reflect method
        /// yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_Reflect_i ()
        {
            {
                Vector3 incident = new Vector3(20, -5, 10);

                Vector3 normal = new Vector3(1, -1, 2);
                Vector3.Normalise(ref normal, out normal);

                Vector3 expected = new Vector3(-5, 20, 2);
                Vector3 result;
                Vector3.Reflect(ref incident, ref normal, out result);

                AssertEqualWithinReason(result, expected);
            }

            {
                Vector3 incident = new Vector3(20, -5, 10);

                Vector3 normal = new Vector3(2, -1, 2);
                Vector3.Normalise(ref normal, out normal);

                Vector3 expected = new Vector3(-16, 13, 2);
                Vector3 result;
                Vector3.Reflect(ref incident, ref normal, out result);

                AssertEqualWithinReason(result, expected);
            }

            {
                Vector3 incident = Vector3.Zero;

                Vector3 normal = new Vector3(0, 0, 1);

                Vector3 result;
                Vector3.Reflect(ref incident, ref normal, out result);

                AssertEqualWithinReason(result, Vector3.Zero);
            }
        }


        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Reflect method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Reflect_ii ()
        {
            Fixed32 epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector3 a = GetNextRandomVector3();

                Vector3 b = GetNextRandomVector3();

                Vector3.Normalise(ref b, out b);

                Vector3 result;
                Vector3.Reflect(ref a, ref b, out result);

                Fixed32 dot;
                Vector3.Dot(ref a, ref b, out dot);

                Vector3 expected = a - (2 * dot * b);

                AssertEqualWithinReason(result, expected);
            }
        }

        /// <summary>
        /// Assert that an argument exception is thrown if the value passed in
        /// to the normal parameter is not normalised.
        /// </summary>
        [Test]
        public void TestStaticFn_Reflect_iii ()
        {
            Vector3 incident = GetNextRandomVector3();
            Vector3 normal = new Vector3(12, -241, 123);

            Vector3 result;

            Assert.Throws(
                typeof(ArgumentOutOfRangeException),
                () =>
                Vector3.Reflect(ref incident, ref normal, out result)
            );
        }

        // Test Static Fn: TransformMatrix44 //-------------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformMatix44_i ()
        {
            Vector3 position = new Vector3 (10, 50, -20);

            Single pi; RealMaths.Pi (out pi);
            Single tau; RealMaths.Tau (out tau);

            Matrix44 rotmati = Matrix44.Identity;
            Matrix44 rotmatx; Matrix44.CreateRotationX(pi, out rotmatx);
            Matrix44 rotmaty; Matrix44.CreateRotationY(tau, out rotmaty);
            Matrix44 rotmatz; Matrix44.CreateRotationZ(-pi, out rotmatz);
            Matrix44 rotmatxyz = rotmatx * rotmaty * rotmatz;

            Vector3 expected1 = new Vector3 ( 10,  50, -20);
            Vector3 expected2 = new Vector3 ( 10, -50,  20);
            Vector3 expected3 = new Vector3 ( 10,  50, -20);
            Vector3 expected4 = new Vector3 (-10, -50, -20);
            Vector3 expected5 = new Vector3 (-10,  50,  20);

            Vector3 test1; Vector3.Transform (ref position, ref rotmati, out test1);
            Vector3 test2; Vector3.Transform (ref position, ref rotmatx, out test2);
            Vector3 test3; Vector3.Transform (ref position, ref rotmaty, out test3);
            Vector3 test4; Vector3.Transform (ref position, ref rotmatz, out test4);
            Vector3 test5; Vector3.Transform (ref position, ref rotmatxyz, out test5);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
            AssertEqualWithinReason(test5, expected5);
        }

        // Test Static Fn: TransformNormal //---------------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformNormal_i ()
        {
            Vector3 position = new Vector3 (10, 50, -20);
            Vector3.Normalise (ref position, out position);

            Single pi; RealMaths.Pi (out pi);
            Single tau; RealMaths.Tau (out tau);

            Matrix44 rotmati = Matrix44.Identity;
            Matrix44 rotmatx; Matrix44.CreateRotationX(pi, out rotmatx);
            Matrix44 rotmaty; Matrix44.CreateRotationY(tau, out rotmaty);
            Matrix44 rotmatz; Matrix44.CreateRotationZ(-pi, out rotmatz);
            Matrix44 rotmatxyz = rotmatx * rotmaty * rotmatz;

            Vector3 expected1 = new Vector3 ( 10,  50, -20);
            Vector3 expected2 = new Vector3 ( 10, -50,  20);
            Vector3 expected3 = new Vector3 ( 10,  50, -20);
            Vector3 expected4 = new Vector3 (-10, -50, -20);
            Vector3 expected5 = new Vector3 (-10,  50,  20);

            Vector3.Normalise (ref expected1, out expected1);
            Vector3.Normalise (ref expected2, out expected2);
            Vector3.Normalise (ref expected3, out expected3);
            Vector3.Normalise (ref expected4, out expected4);
            Vector3.Normalise (ref expected5, out expected5);

            Vector3 test1; Vector3.TransformNormal (ref position, ref rotmati, out test1);
            Vector3 test2; Vector3.TransformNormal (ref position, ref rotmatx, out test2);
            Vector3 test3; Vector3.TransformNormal (ref position, ref rotmaty, out test3);
            Vector3 test4; Vector3.TransformNormal (ref position, ref rotmatz, out test4);
            Vector3 test5; Vector3.TransformNormal (ref position, ref rotmatxyz, out test5);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
            AssertEqualWithinReason(test5, expected5);

            // should also work with the standard transform fn
            Vector3 test1n; Vector3.TransformNormal (ref position, ref rotmati, out test1n);
            Vector3 test2n; Vector3.TransformNormal (ref position, ref rotmatx, out test2n);
            Vector3 test3n; Vector3.TransformNormal (ref position, ref rotmaty, out test3n);
            Vector3 test4n; Vector3.TransformNormal (ref position, ref rotmatz, out test4n);
            Vector3 test5n; Vector3.TransformNormal (ref position, ref rotmatxyz, out test5n);

            AssertEqualWithinReason(test1n, expected1);
            AssertEqualWithinReason(test2n, expected2);
            AssertEqualWithinReason(test3n, expected3);
            AssertEqualWithinReason(test4n, expected4);
            AssertEqualWithinReason(test5n, expected5);
        }

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformNormal_ii ()
        {
            Matrix44 rotmat = Matrix44.Identity;
            Vector3 normal = new Vector3 (21, -532, 0);
            Vector3 result;
            Assert.Throws(
                typeof(ArgumentOutOfRangeException),
                () =>
                Vector3.TransformNormal(ref normal, ref rotmat, out result)
            );
        }

        // Test Static Fn: TransformQuaternion //-----------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformQuaternion_i ()
        {
            Vector3 position = new Vector3 (10, 50, -20);

            Single pi;
            RealMaths.Pi (out pi);

            Quaternion quatmati = new Quaternion (0, 0, 0, 1);
            Quaternion quatmatx = new Quaternion (1, 0, 0, 0);
            Quaternion quatmaty = new Quaternion (0, 0, 0, 1);
            Quaternion quatmatz = new Quaternion (0, 0, 1, 0);
            Quaternion quatmatxyz = new Quaternion (0, 1, 0, 0);

            Vector3 expected1 = new Vector3 ( 10,  50, -20);
            Vector3 expected2 = new Vector3 ( 10, -50,  20);
            Vector3 expected3 = new Vector3 ( 10,  50, -20);
            Vector3 expected4 = new Vector3 (-10, -50, -20);
            Vector3 expected5 = new Vector3 (-10,  50,  20);

            Vector3 test1; Vector3.Transform (ref position, ref quatmati, out test1);
            Vector3 test2; Vector3.Transform (ref position, ref quatmatx, out test2);
            Vector3 test3; Vector3.Transform (ref position, ref quatmaty, out test3);
            Vector3 test4; Vector3.Transform (ref position, ref quatmatz, out test4);
            Vector3 test5; Vector3.Transform (ref position, ref quatmatxyz, out test5);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
            AssertEqualWithinReason(test5, expected5);
        }

        // Test Operator: Equality //-----------------------------------------//

        /// <summary>
        /// Helper method for testing equality.
        /// </summary>
        void TestEquality (Vector3 a, Vector3 b, Boolean expected )
        {
            // This test asserts the following:
            //   (a == b) == expected
            //   (b == a) == expected
            //   (a != b) == !expected
            //   (b != a) == !expected

            Boolean result_1a = (a == b);
            Boolean result_1b = (a.Equals(b));
            Boolean result_1c = (a.Equals((Object)b));
            
            Boolean result_2a = (b == a);
            Boolean result_2b = (b.Equals(a));
            Boolean result_2c = (b.Equals((Object)a));

            Boolean result_3a = (a != b);
            Boolean result_4a = (b != a);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_1c, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
            Assert.That(result_2c, Is.EqualTo(expected));
            Assert.That(result_3a, Is.EqualTo(!expected));
            Assert.That(result_4a, Is.EqualTo(!expected));
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of TRUE when two equal  
        /// Vector3 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_i ()
        {
            var a = new Vector3(44, -54, -22);
            var b = new Vector3(44, -54, -22);

            Boolean expected = true;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of FALSE when two unequal  
        /// Vector3 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_ii ()
        {
            var a = new Vector3(44, 54, 2);
            var b = new Vector3(44, -54, 2);

            Boolean expected = false;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Tests to make sure that all the equality opperators and functions 
        /// yield the expected result of TRUE when used on a number of randomly 
        /// generated pairs of equal Vector3 objects.
        /// </summary>
        [Test]
        public void TestOperator_Equality_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();

                Vector3 b = a;

                this.TestEquality(a, b, true);
            }
        }


        // Test Operator: Addition //-----------------------------------------//

        /// <summary>
        /// Helper method for testing addition.
        /// </summary>
        void TestAddition (Vector3 a, Vector3 b, Vector3 expected )
        {
            // This test asserts the following:
            //   a + b == expected
            //   b + a == expected

            var result_1a = a + b;
            var result_2a = b + a;

            Vector3 result_1b; Vector3.Add(ref a, ref b, out result_1b);
            Vector3 result_2b; Vector3.Add(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the addition opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_i ()
        {
            var a = new Vector3(3, -6, 44);
            var b = new Vector3(-6, 12, 18);

            var expected = new Vector3(-3, 6, 62);

            this.TestAddition(a, b, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving the zero vector, all the 
        /// addition opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_ii ()
        {
            var a = new Vector3(-2313, 88, 199);

            var expected = a;

            this.TestAddition(a, Vector3.Zero, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving two zero vectors, all the 
        /// addition opperators and functions yield the correct result of zero.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iii ()
        {
            this.TestAddition(Vector3.Zero, Vector3.Zero, Vector3.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// addition opperators and functions yield the same results as a
        /// manual addition calculation.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();
                var b = GetNextRandomVector3();

                var expected = new Vector3(
                    a.X + b.X, a.Y + b.Y, a.Z + b.Z);

                this.TestAddition(a, b, expected);
            }
        }

        // Test Operator: Subtraction //--------------------------------------//
        
        /// <summary>
        /// Helper method for testing subtraction.
        /// </summary>
        void TestSubtraction (Vector3 a, Vector3 b, Vector3 expected )
        {
            // This test asserts the following:
            //   a - b == expected
            //   b - a == -expected

            var result_1a = a - b;
            var result_2a = b - a;

            Vector3 result_1b; Vector3.Subtract(ref a, ref b, out result_1b);
            Vector3 result_2b; Vector3.Subtract(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(-expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(-expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the subtraction opperators
        /// and functions yield the correct result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_i ()
        {
            var a = new Vector3(12, -4, 14);
            var b = new Vector3(15, 11, 7);
            var expected = new Vector3(-3, -15, 7);
            this.TestSubtraction(a, b, expected);

            var c = new Vector3(-423, 342, 7);
            this.TestSubtraction(c, Vector3.Zero, c);
        }

        /// <summary>
        /// Assert that when subtracting the zero vector fromt the zero vector, 
        /// all the subtraction opperators and functions yield the correct 
        /// result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_ii ()
        {
            this.TestSubtraction(Vector3.Zero, Vector3.Zero, Vector3.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// subtraction opperators and functions yield the same results as a
        /// manual subtraction calculation.
        /// </summary>
        [Test]
        public void TestOperator_Subtraction_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();
                var b = GetNextRandomVector3();

                var expected = new Vector3(a.X - b.X, a.Y - b.Y, a.Z - b.Z);

                this.TestSubtraction(a, b, expected);
            }
        }

        // Test Operator: Negation //-----------------------------------------//
        
        /// <summary>
        /// Helper method for testing negation.
        /// </summary>
        void TestNegation (Vector3 a, Vector3 expected )
        {
            // This test asserts the following:
            //   -a == expected

            var result_1a = -a;

            Vector3 result_1b; Vector3.Negate(ref a, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the negation opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_i ()
        {
            Fixed32 r = 3432;
            Fixed32 s = -6218;
            Fixed32 t = -3432;
            Fixed32 u = 6218;

            var a = new Vector3(r, s, t);
            var b = new Vector3(u, t, s);
            var c = new Vector3(t, u, r);
            var d = new Vector3(s, r, u);

            this.TestNegation(a, c);
            this.TestNegation(b, d);
        }

        /// <summary>
        /// Assert that, for known examples involving the zero vector, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_ii ()
        {
            Fixed32 t = -3432;
            Fixed32 u = 6218;
            Fixed32 r = 3432;
            Fixed32 s = -6218;

            var c = new Vector3(t, u, r);
            var d = new Vector3(s, r, u);

            this.TestNegation(c, Vector3.Zero - c);
            this.TestNegation(d, Vector3.Zero - d);
        }

        /// <summary>
        /// Assert that when negating the zero vector, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iii ()
        {
            this.TestNegation(Vector3.Zero, Vector3.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// negation opperators and functions yield the same results as a
        /// manual negation calculation.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();
                this.TestNegation(a, Vector3.Zero - a);
            }
        }

        // Test Operator: Multiplication //-----------------------------------//

        /// <summary>
        /// Helper method for testing multiplication.
        /// </summary>
        void TestMultiplication (Vector3 a, Vector3 b, Vector3 expected )
        {
            // This test asserts the following:
            //   a * b == expected
            //   b * a == expected

            var result_1a = a * b;
            var result_2a = b * a;

            Vector3 result_1b; Vector3.Multiply(ref a, ref b, out result_1b);
            Vector3 result_2b; Vector3.Multiply(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the multiplication opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_i ()
        {
            Fixed32 r = -27;
            Fixed32 s = 36;
            Fixed32 t = 9;

            Fixed32 x = 3;
            Fixed32 y = 6;
            Fixed32 z = -9;

            var a = new Vector3(x, y, x);
            var b = new Vector3(z, y, x);
            var c = new Vector3(r, s, t);

            this.TestMultiplication(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// multiplication opperators and functions yield the same results as a
        /// manual multiplication calculation.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();
                var b = GetNextRandomVector3();

                var c = new Vector3(a.X * b.X, a.Y * b.Y, a.Z * b.Z);

                this.TestMultiplication(a, b, c);
            }
        }


        // Test Operator: Division //-----------------------------------------//

        /// <summary>
        /// Helper method for testing division.
        /// </summary>
        void TestDivision (Vector3 a, Vector3 b, Vector3 expected )
        {
            // This test asserts the following:
            //   a / b == expected

            var result_1a = a / b;

            Vector3 result_1b; Vector3.Divide(ref a, ref b, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example using whole numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_i ()
        {
            Fixed32 r = 10;
            Fixed32 s = -40;
            Fixed32 t = 1;

            Fixed32 x = 2000;
            Fixed32 y = 200;
            Fixed32 z = -5;

            var a = new Vector3(x, y, x);
            var b = new Vector3(y, z, x);
            var c = new Vector3(r, s, t);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a known example using fractional numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_ii ()
        {
            Fixed32 t = ((Fixed32) 1 ) / ((Fixed32) 10);
            Fixed32 u = ((Fixed32) (-1) ) / ((Fixed32) 40 );
            Fixed32 v = -20;
            Fixed32 w = 100;
            Fixed32 x = 2000;
            Fixed32 y = 200;
            Fixed32 z = -5;

            var a = new Vector3(y, z, w);
            var b = new Vector3(x, y, z);
            var c = new Vector3(t, u, v);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// division opperators and functions yield the same results as a
        /// manual addition division.
        /// </summary>
        [Test]
        public void TestOperator_Division_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();
                var b = GetNextRandomVector3();

                var c = new Vector3(a.X / b.X, a.Y / b.Y, a.Z / b.Z);

                this.TestDivision(a, b, c);
            }
        }

        // Test Static Fn: SmoothStep //--------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();
                var b = GetNextRandomVector3();

                Fixed32 amount1 = 0;
                Vector3 result1;

                Vector3.SmoothStep (
                    ref a, ref b, amount1, out result1);

                AssertEqualWithinReason(result1, a);

                Fixed32 amount2 = 1;
                Vector3 result2;

                Vector3.SmoothStep (
                    ref a, ref b, amount2, out result2);

                AssertEqualWithinReason(result2, b);
            }
        }

        /// <summary>
        /// Assert that, for known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_ii ()
        {
            var a = GetNextRandomVector3();
            var b = GetNextRandomVector3();

            Fixed32 half; RealMaths.Half(out half);

            var tests = new Fixed32[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector3 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector3.SmoothStep (
                            ref a, ref b, amount, out result)
                    );
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_iii ()
        {
            var a = new Vector3( -30, -30, -30 );
            var b = new Vector3( +30, +30, +30 );

            Fixed32 one = 1;

            Fixed32 i;
            RealMaths.FromFraction(1755, 64, out i); // 27.421875
            
            Fixed32 j;
            RealMaths.FromFraction( 165,  8, out j); // 20.625
            
            Fixed32 k;
            RealMaths.FromFraction( 705, 64, out k); // 11.015625

            Fixed32 a0 = 0;
            Fixed32 a1 = (one * 1) / 8;
            Fixed32 a2 = (one * 2) / 8;
            Fixed32 a3 = (one * 3) / 8;
            Fixed32 a4 = (one * 4) / 8;
            Fixed32 a5 = (one * 5) / 8;
            Fixed32 a6 = (one * 6) / 8;
            Fixed32 a7 = (one * 7) / 8;
            Fixed32 a8 = 1;

            Vector3 r0 = a;
            Vector3 r1 = new Vector3( -i, -i, -i );
            Vector3 r2 = new Vector3( -j, -j, -j );
            Vector3 r3 = new Vector3( -k, -k, -k );
            Vector3 r4 = Vector3.Zero;
            Vector3 r5 = new Vector3(  k,  k,  k );
            Vector3 r6 = new Vector3(  j,  j,  j );
            Vector3 r7 = new Vector3(  i,  i,  i );
            Vector3 r8 = b;

            var knownResults = new List<Tuple<Fixed32, Vector3>>
            {
                new Tuple<Fixed32, Vector3>( a0, r0 ),
                new Tuple<Fixed32, Vector3>( a1, r1 ),
                new Tuple<Fixed32, Vector3>( a2, r2 ),
                new Tuple<Fixed32, Vector3>( a3, r3 ),
                new Tuple<Fixed32, Vector3>( a4, r4 ),
                new Tuple<Fixed32, Vector3>( a5, r5 ),
                new Tuple<Fixed32, Vector3>( a6, r6 ),
                new Tuple<Fixed32, Vector3>( a7, r7 ),
                new Tuple<Fixed32, Vector3>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector3 result;

                Vector3.SmoothStep (
                    ref a, ref b, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        // Test Static Fn: CatmullRom //--------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector3();
                var b = GetNextRandomVector3();
                var c = GetNextRandomVector3();
                var d = GetNextRandomVector3();

                Fixed32 amount1 = 0;
                Vector3 result1;

                Vector3.CatmullRom (
                    ref a, ref b, ref c, ref d, amount1, out result1);

                AssertEqualWithinReason(result1, b);

                Fixed32 amount2 = 1;
                Vector3 result2;

                Vector3.CatmullRom (
                    ref a, ref b, ref c, ref d, amount2, out result2);

                AssertEqualWithinReason(result2, c);
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_ii ()
        {
            var a = new Vector3( -90, +30, +90 );
            var b = new Vector3( -30, -30, +30 );
            var c = new Vector3( +30, +30, -30 );
            var d = new Vector3( +90, -30, -90 );

            Fixed32 one = 1;

            Fixed32 u = 15;
            Fixed32 v = (Fixed32) 165  / (Fixed32)  8; // 20.5
            Fixed32 w = (Fixed32) 45   / (Fixed32)  2; // 20.625
            Fixed32 x = (Fixed32) 1755 / (Fixed32) 64; // 27.421875
            Fixed32 y = (Fixed32) 15   / (Fixed32)  2; // 14.5
            Fixed32 z = (Fixed32) 705  / (Fixed32) 64; // 11.015625

            Fixed32 a0 = 0;
            Fixed32 a1 = (one * 1) / 8;
            Fixed32 a2 = (one * 2) / 8;
            Fixed32 a3 = (one * 3) / 8;
            Fixed32 a4 = (one * 4) / 8;
            Fixed32 a5 = (one * 5) / 8;
            Fixed32 a6 = (one * 6) / 8;
            Fixed32 a7 = (one * 7) / 8;
            Fixed32 a8 = 1;

            Vector3 r0 = b;
            Vector3 r1 = new Vector3( -w, -x,  w );
            Vector3 r2 = new Vector3( -u, -v,  u );
            Vector3 r3 = new Vector3( -y, -z,  y );
            Vector3 r4 = Vector3.Zero;
            Vector3 r5 = new Vector3(  y,  z, -y );
            Vector3 r6 = new Vector3(  u,  v, -u );
            Vector3 r7 = new Vector3(  w,  x, -w );
            Vector3 r8 = c;

            var knownResults = new List<Tuple<Fixed32, Vector3>>
            {
                new Tuple<Fixed32, Vector3>( a0, r0 ),
                new Tuple<Fixed32, Vector3>( a1, r1 ),
                new Tuple<Fixed32, Vector3>( a2, r2 ),
                new Tuple<Fixed32, Vector3>( a3, r3 ),
                new Tuple<Fixed32, Vector3>( a4, r4 ),
                new Tuple<Fixed32, Vector3>( a5, r5 ),
                new Tuple<Fixed32, Vector3>( a6, r6 ),
                new Tuple<Fixed32, Vector3>( a7, r7 ),
                new Tuple<Fixed32, Vector3>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector3 result;

                Vector3.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_iii ()
        {
            var a = GetNextRandomVector3();
            var b = GetNextRandomVector3();
            var c = GetNextRandomVector3();
            var d = GetNextRandomVector3();
            
            Fixed32 half; RealMaths.Half(out half);

            var tests = new Fixed32[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector3 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector3.CatmullRom (
                            ref a, ref b, ref c, ref d, amount, out result)
                );
            }
        }

        /// <summary>
        /// This tests compares results against an example where all the control
        /// points are in a straight line.  In this case the resulting spline
        /// should be a straight line.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_iv ()
        {
            var a = new Vector3( -90, -90, +90 );
            var b = new Vector3( -30, -30, +30 );
            var c = new Vector3( +30, +30, -30 );
            var d = new Vector3( +90, +90, -90 );

            Fixed32 one = 1;

            Fixed32 a0 = 0;
            Fixed32 a1 = (one * 1) / 4;
            Fixed32 a2 = (one * 2) / 4;
            Fixed32 a3 = (one * 3) / 4;
            Fixed32 a4 = 1;

            Vector3 r0 = b;
            Vector3 r1 = new Vector3( -15, -15,  15 );
            Vector3 r2 = Vector3.Zero;
            Vector3 r3 = new Vector3(  15,  15, -15 );
            Vector3 r4 = c;

            var knownResults = new List<Tuple<Fixed32, Vector3>>
            {
                new Tuple<Fixed32, Vector3>( a0, r0 ),
                new Tuple<Fixed32, Vector3>( a1, r1 ),
                new Tuple<Fixed32, Vector3>( a2, r2 ),
                new Tuple<Fixed32, Vector3>( a3, r3 ),
                new Tuple<Fixed32, Vector3>( a4, r4 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector3 result;

                Vector3.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        // Test Static Fn: Hermite //-----------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a  = GetNextRandomVector3();
                var b  = GetNextRandomVector3();

                var c = GetNextRandomVector3();
                var d = GetNextRandomVector3();

                Vector3 an; Vector3.Normalise(ref c, out an);
                Vector3 bn; Vector3.Normalise(ref d, out bn);

                Fixed32 amount1 = 0;
                Vector3 result1;

                Vector3.Hermite (
                    ref a, ref an, ref b, ref bn, amount1, out result1);

                AssertEqualWithinReason(result1, a);

                Fixed32 amount2 = 1;
                Vector3 result2;

                Vector3.Hermite (
                    ref a, ref an, ref b, ref bn, amount2, out result2);

                AssertEqualWithinReason(result2, b);
            }
        }

        /// <summary>
        /// Assert that, for known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_ii ()
        {
            var a = GetNextRandomVector3();
            var b = GetNextRandomVector3();
            var c = GetNextRandomVector3();
            var d = GetNextRandomVector3();

            Vector3 an; Vector3.Normalise(ref c, out an);
            Vector3 bn; Vector3.Normalise(ref d, out bn);

            Fixed32 half; RealMaths.Half(out half);

            var tests = new Fixed32[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector3 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector3.Hermite (
                            ref a, ref an, ref b, ref bn, amount, out result)
                    );
                
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_iii ()
        {
            var a = new Vector3( -100, +50, +100 );
            var b = new Vector3( +100, -50, -100 );

            var c = new Vector3( -10, +5, +10 );
            var d = new Vector3( +10, -5, -10 );

            Vector3 an; Vector3.Normalise(ref c, out an);
            Vector3 bn; Vector3.Normalise(ref d, out bn);

            Fixed32 one = 1;
            
            // 100.1953125
            Fixed32 e = (Fixed32) 51300 / (Fixed32) 512;

            // 50.09765625
            Fixed32 f = (Fixed32) 12825 / (Fixed32) 256;

            // 91.25
            Fixed32 g = (Fixed32) 365 / (Fixed32) 4;

            // 45.625
            Fixed32 h = (Fixed32) 365 / (Fixed32) 8;

            // 75.7421875
            Fixed32 i = (Fixed32) 9695 / (Fixed32) 128;

            // 37.87109375
            Fixed32 j = (Fixed32) 9695 / (Fixed32) 256;

            // 56.25
            Fixed32 k = (Fixed32) 225 / (Fixed32) 4;

            // 28.125
            Fixed32 l = (Fixed32) 225 / (Fixed32) 8;

            // 35.3515625
            Fixed32 m = (Fixed32) 4525 / (Fixed32) 128;

            // 17.67578125
            Fixed32 n = (Fixed32) 4525 / (Fixed32) 256;

            // 15.625
            Fixed32 o = (Fixed32) 125 / (Fixed32) 8;

            // 7.8125
            Fixed32 p = (Fixed32) 125 / (Fixed32) 16;

            // 0.3515625
            Fixed32 q = (Fixed32) 45 / (Fixed32) 128;

            // 0.17578125
            Fixed32 r = (Fixed32) 45 / (Fixed32) 256;

            Fixed32 a0 = 0;
            Fixed32 a1 = (one * 1) / 8;
            Fixed32 a2 = (one * 2) / 8;
            Fixed32 a3 = (one * 3) / 8;
            Fixed32 a4 = (one * 4) / 8;
            Fixed32 a5 = (one * 5) / 8;
            Fixed32 a6 = (one * 6) / 8;
            Fixed32 a7 = (one * 7) / 8;
            Fixed32 a8 = 1;

            Vector3 r0 = b;
            Vector3 r1 = new Vector3(  e, -f, -e );
            Vector3 r2 = new Vector3(  g, -h, -g );
            Vector3 r3 = new Vector3(  i, -j, -i );
            Vector3 r4 = new Vector3(  k, -l, -k );
            Vector3 r5 = new Vector3(  m, -n, -m );
            Vector3 r6 = new Vector3(  o, -p, -o );
            Vector3 r7 = new Vector3( -q,  r,  q );
            Vector3 r8 = c;

            var knownResults = new List<Tuple<Fixed32, Vector3>>
            {
                new Tuple<Fixed32, Vector3>( a0, r0 ),
                new Tuple<Fixed32, Vector3>( a1, r1 ),
                new Tuple<Fixed32, Vector3>( a2, r2 ),
                new Tuple<Fixed32, Vector3>( a3, r3 ),
                new Tuple<Fixed32, Vector3>( a4, r4 ),
                new Tuple<Fixed32, Vector3>( a5, r5 ),
                new Tuple<Fixed32, Vector3>( a6, r6 ),
                new Tuple<Fixed32, Vector3>( a7, r7 ),
                new Tuple<Fixed32, Vector3>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector3 result;

                Vector3.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

                /// <summary>
        /// Assert that, running the Min function on a number of randomly
        /// generated pairs of Vector3 objects, yields the same results as those
        /// obtained from performing a manual Min calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Min ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector3 a = GetNextRandomVector3();
                Vector3 b = a * 2;

                Vector3 result;
                Vector3.Min (ref a, ref b, out result);

                Assert.That(result.X, Is.EqualTo(a.X < b.X ? a.X : b.X ));
                Assert.That(result.Y, Is.EqualTo(a.Y < b.Y ? a.Y : b.Y ));
                Assert.That(result.Z, Is.EqualTo(a.Z < b.Z ? a.Z : b.Z ));
            }
        }

        /// <summary>
        /// Assert that, running the Max function on a number of randomly
        /// generated pairs of Vector3 objects, yields the same results as those
        /// obtained from performing a manual Max calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Max ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector3 a = GetNextRandomVector3();
                Vector3 b = GetNextRandomVector3();

                Vector3 result;
                Vector3.Max (ref a, ref b, out result);

                Assert.That(result.X, Is.EqualTo(a.X > b.X ? a.X : b.X ));
                Assert.That(result.Y, Is.EqualTo(a.Y > b.Y ? a.Y : b.Y ));
                Assert.That(result.Z, Is.EqualTo(a.Z > b.Z ? a.Z : b.Z ));
            }
        }

        /// <summary>
        /// Assert that, running the Clamp function on a number of randomly
        /// generated Vector3 objects for a given min-max range, yields
        /// results that fall within that range.
        /// </summary>
        [Test]
        public void TestStaticFn_Clamp_i ()
        {
            Vector3 min = new Vector3(-30, 1, 18);
            Vector3 max = new Vector3(32, 130, 47);

            for(Int32 i = 0; i < 100; ++i)
            {
                Vector3 a = GetNextRandomVector3();

                Vector3 result;
                Vector3.Clamp (ref a, ref min, ref max, out result);

                Assert.That(result.X, Is.LessThanOrEqualTo(max.X));
                Assert.That(result.Y, Is.LessThanOrEqualTo(max.Y));
                Assert.That(result.X, Is.GreaterThanOrEqualTo(min.X));
                Assert.That(result.Y, Is.GreaterThanOrEqualTo(min.Y));
            }
        }

        /// <summary>
        /// Assert that, running the Clamp function on an a Vector3 object known
        /// to fall outside of a given min-max range, yields a result that fall 
        /// within that range.
        /// </summary>
        [Test]
        public void TestStaticFn_Clamp_ii ()
        {
            Vector3 min = new Vector3(-30, 1, 18);
            Vector3 max = new Vector3(32, 130, 47);

            Vector3 a = new Vector3(-100, 1113, 50);

            Vector3 expected = new Vector3(-30, 130, 47);

            Vector3 result;
            Vector3.Clamp (ref a, ref min, ref max, out result);

            Assert.That(result.X, Is.LessThanOrEqualTo(max.X));
            Assert.That(result.Y, Is.LessThanOrEqualTo(max.Y));
            Assert.That(result.Z, Is.LessThanOrEqualTo(max.Z));
            Assert.That(result.X, Is.GreaterThanOrEqualTo(min.X));
            Assert.That(result.Y, Is.GreaterThanOrEqualTo(min.Y));
            Assert.That(result.Z, Is.GreaterThanOrEqualTo(min.Z));

            AssertEqualWithinReason(result, expected);

        }

        /// <summary>
        /// Assert that, running the Lerp function on a number of randomly
        /// generated pairs of Vector3 objects for a range of weighting amounts, 
        /// yields the same results as those obtained from performing a manual 
        /// Lerp calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_i ()
        {
            for(Int32 j = 0; j < 100; ++j)
            {
                Fixed32 delta = j;

                delta = delta / 100;

                for(Int32 i = 0; i < 100; ++i)
                {
                    Vector3 a = GetNextRandomVector3();
                    Vector3 b = GetNextRandomVector3();

                    Vector3 result;
                    Vector3.Lerp (ref a, ref b, delta, out result);

                    Vector3 expected = a + ( ( b - a ) * delta );

                    AssertEqualWithinReason(result, expected);
                }
            }
        }

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_ii ()
        {
            Vector3 a = GetNextRandomVector3();
            Vector3 b = GetNextRandomVector3();

            Fixed32 half; RealMaths.Half(out half);

            var tests = new Fixed32[] { 2, half + 1, -half, -1 };

            foreach( var weighting in tests )
            {
                Vector3 result; 
                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector3.Lerp (
                            ref a, ref b, weighting, out result)
                    );
            }
        }


    }    /// <summary>
    /// 
    /// </summary>
    [TestFixture]
    public class Vector4Tests
    {
        /// <summary>
        /// The random number generator used for testing.
        /// </summary>
        static readonly System.Random rand;

        /// <summary>
        /// Static constructor used to ensure that the random number generator
        /// always gets initilised with the same seed, making the tests
        /// behave in a deterministic manner.
        /// </summary>
        static Vector4Tests ()
        {
            rand = new System.Random(0);
        }

        /// <summary>
        /// Helper function for getting the next random Fixed32 value.
        /// </summary>
        static Fixed32 GetNextRandomFixed32 ()
        {
            Fixed32 randomValue = rand.NextFixed32();

            Fixed32 zero = 0;
            Fixed32 multiplier = 1000;

            randomValue *= multiplier;

            Boolean randomBoolean = (rand.Next(0, 1) == 0) ? true : false;

            if( randomBoolean )
                randomValue = zero - randomValue;

            return randomValue;
        }

        /// <summary>
        /// Helper function for getting the next random Vector4.
        /// </summary>
        static Vector4 GetNextRandomVector4 ()
        {
            Fixed32 a = GetNextRandomFixed32();
            Fixed32 b = GetNextRandomFixed32();
            Fixed32 c = GetNextRandomFixed32();
            Fixed32 d = GetNextRandomFixed32();

            return new Vector4(a, b, c, d);
        }

        /// <summary>
        /// Helper to encapsulate asserting that two Vector4s are equal.
        /// </summary>
        static void AssertEqualWithinReason (Vector4 a, Vector4 b)
        {
            Fixed32 tolerance; RealMaths.TestTolerance(out tolerance);

            Assert.That(a.X, Is.EqualTo(b.X).Within(tolerance));
            Assert.That(a.Y, Is.EqualTo(b.Y).Within(tolerance));
            Assert.That(a.Z, Is.EqualTo(b.Z).Within(tolerance));
            Assert.That(a.W, Is.EqualTo(b.W).Within(tolerance));
        }
        

        // Test: StructLayout //----------------------------------------------//

        /// <summary>
        /// This test makes sure that the struct layout has been defined
        /// correctly.
        /// </summary>
        [Test]
        public void Test_StructLayout_i ()
        {
            Type t = typeof(Vector4);

            Assert.That(
                t.StructLayoutAttribute.Value, 
                Is.EqualTo(LayoutKind.Sequential));
        }

        /// <summary>
        /// This test makes sure that when examining the memory addresses of the 
        /// X, Y, Z and W member variables of a number of randomly generated 
        /// Vector4 objects the results are as expected. 
        /// </summary>
        [Test]
        public unsafe void Test_StructLayout_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector4 vec = GetNextRandomVector4();

                GCHandle h_vec = GCHandle.Alloc(vec, GCHandleType.Pinned);

                IntPtr vecAddress = h_vec.AddrOfPinnedObject();

                Fixed32[] data = new Fixed32[4];

                // nb: when Fixed32 and Half are moved back into the main
                //     dev branch there will be need for an extension method for
                //     Marshal that will perform the copy for those types. 
                MarshalHelper.Copy(vecAddress, data, 0, 4);
                Assert.That(data[0], Is.EqualTo(vec.X));
                Assert.That(data[1], Is.EqualTo(vec.Y));
                Assert.That(data[2], Is.EqualTo(vec.Z));
                Assert.That(data[3], Is.EqualTo(vec.W));
                
                h_vec.Free();
            }
        }

        // Test: Constructors //----------------------------------------------//

        /// <summary>
        /// This test goes though each public constuctor and ensures that the 
        /// data members of the structure have been properly set.
        /// </summary>
        [Test]
        public void Test_Constructors_i ()
        {
            {
                // Test default values
                Vector4 a = new Vector4();
                Assert.That(a, Is.EqualTo(Vector4.Zero));
            }
            {
                // Test Vector4( Fixed32, Fixed32, Fixed32 )
                Fixed32 a = -189;
                Fixed32 b = 429;
                Fixed32 c = 4298;
                Fixed32 d = 341;
                Vector4 e = new Vector4(a, b, c, d);
                Assert.That(e.X, Is.EqualTo(a));
                Assert.That(e.Y, Is.EqualTo(b));
                Assert.That(e.Z, Is.EqualTo(c));
                Assert.That(e.W, Is.EqualTo(d));
            }
            {
                // Test Vector4( Vector2, Fixed32, Fixed32 )
                Vector2 a = new Vector2(-189, 429);
                Fixed32 b = 4298;
                Fixed32 c = 341;
                Vector4 d = new Vector4(a, b, c);
                Assert.That(d.X, Is.EqualTo(a.X));
                Assert.That(d.Y, Is.EqualTo(a.Y));
                Assert.That(d.Z, Is.EqualTo(b));
                Assert.That(d.W, Is.EqualTo(c));
            }
            {
                // Test Vector4( Vector3, Fixed32 )
                Vector3 a = new Vector3(-189, 429, 4298);
                Fixed32 b = 341;
                Vector4 c = new Vector4(a, b);
                Assert.That(c.X, Is.EqualTo(a.X));
                Assert.That(c.Y, Is.EqualTo(a.Y));
                Assert.That(c.Z, Is.EqualTo(a.Z));
                Assert.That(c.W, Is.EqualTo(b));
            }
            {
                // Test no constructor
                Vector4 a;
                a.X = 0;
                a.Y = 0;
                a.Z = 0;
                a.W = 0;
                Assert.That(a, Is.EqualTo(Vector4.Zero));
            }
        }

        // Test Member Fn: ToString //----------------------------------------//

        /// <summary>
        /// For a given example, this test ensures that the ToString function
        /// yields the expected string.
        /// </summary>
        [Test]
        public void TestMemberFn_ToString_i ()
        {
            Vector4 a = new Vector4(42, -17, 13, 44);

            String result = a.ToString();

            String expected = "{X:42 Y:-17 Z:13 W:44}";

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: GetHashCode //-------------------------------------//

        /// <summary>
        /// Makes sure that the hashing function is good by testing 10,000
        /// random scenarios and ensuring that there are no more than 10
        /// collisions.
        /// </summary>
        [Test]
        public void TestMemberFn_GetHashCode_i ()
        {
            var hs1 = new System.Collections.Generic.HashSet<Vector4>();
            var hs2 = new System.Collections.Generic.HashSet<Int32>();

            for(Int32 i = 0; i < 10000; ++i)
            {
                var a = GetNextRandomVector4();

                hs1.Add(a);
                hs2.Add(a.GetHashCode());
            }

            Assert.That(hs1.Count, Is.EqualTo(hs2.Count).Within(10));
        }

        // Test Member Fn: Length //------------------------------------------//

        /// <summary>
        /// Tests that for a known example the Length member function yields
        /// the correct result.
        /// </summary>
        [Test]
        public void TestMemberFn_Length_i ()
        {
            Vector4 a = new Vector4(3, -4, 12, 84);

            Fixed32 expected = 85;

            Fixed32 result = a.Length();

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: LengthSquared //-----------------------------------//

        /// <summary>
        /// Tests that for a known example the LengthSquared member function 
        /// yields the correct result.
        /// </summary>
        [Test]
        public void TestMemberFn_LengthSquared_i ()
        {
            Vector4 a = new Vector4(3, -4, 12, 84);

            Fixed32 expected = 7225;

            Fixed32 result = a.LengthSquared();

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Member Fn: IsUnit //------------------------------------------//

        /// <summary>
        /// Tests that for the simple vectors the IsUnit member function
        /// returns the correct result of TRUE.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_i ()
        {
            Vector4 a = new Vector4( 1,  0,  0,  0);
            Vector4 b = new Vector4(-1,  0,  0,  0);
            Vector4 c = new Vector4( 0,  1,  0,  0);
            Vector4 d = new Vector4( 0, -1,  0,  0);
            Vector4 e = new Vector4( 0,  0,  1,  0);
            Vector4 f = new Vector4( 0,  0, -1,  0);
            Vector4 g = new Vector4( 0,  0,  0,  1);
            Vector4 h = new Vector4( 0,  0,  0, -1);
            Vector4 i = new Vector4( 1,  1,  1,  1);
            Vector4 j = new Vector4( 0,  0,  0,  0);

            Assert.That(a.IsUnit(), Is.EqualTo(true));
            Assert.That(b.IsUnit(), Is.EqualTo(true));
            Assert.That(c.IsUnit(), Is.EqualTo(true));
            Assert.That(d.IsUnit(), Is.EqualTo(true));
            Assert.That(e.IsUnit(), Is.EqualTo(true));
            Assert.That(f.IsUnit(), Is.EqualTo(true));
            Assert.That(g.IsUnit(), Is.EqualTo(true));
            Assert.That(h.IsUnit(), Is.EqualTo(true));

            Assert.That(i.IsUnit(), Is.EqualTo(false));
            Assert.That(j.IsUnit(), Is.EqualTo(false));
        }

        /// <summary>
        /// This test makes sure that the IsUnit member function returns the 
        /// correct result of TRUE for a number of scenarios where the test 
        /// vector is both random and normalised.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_ii ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector4 a = GetNextRandomVector4();

                Vector4 b; Vector4.Normalise(ref a, out b);

                Assert.That(b.IsUnit(), Is.EqualTo(true));
            }
        }

        /// <summary>
        /// This test ensures that the IsUnit member function correctly
        /// returns TRUE for a collection of vectors, all known to be of unit 
        /// length.
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_iii ()
        {
            Fixed32 radius = 1;

            Fixed32 pi; RealMaths.Pi(out pi);

            for( Int32 i = 0; i <= 10; ++ i)
            {
                for( Int32 j = 0; j <= 10; ++ j)
                {
                    for( Int32 k = 0; k <= 10; ++ k)
                    {
                        Fixed32 theta = 2 * pi * i / 100;
                        Fixed32 phi = 2 * pi * j / 100;
                        Fixed32 gamma = 2 * pi * k / 100;

                        Fixed32 x = 
                            RealMaths.Cos(theta) * 
                            RealMaths.Sin(phi) * 
                            RealMaths.Sin(gamma) * radius;
                        
                        Fixed32 y = 
                            RealMaths.Sin(theta) * 
                            RealMaths.Sin(phi) * 
                            RealMaths.Sin(gamma) * radius;
                        
                        Fixed32 z = 
                            RealMaths.Cos(phi) * 
                            RealMaths.Sin(gamma) * radius;
                        
                        Fixed32 w = 
                            RealMaths.Cos(gamma) * radius;          

                        Assert.That(
                            new Vector4(x, y,  z, w).IsUnit(), 
                            Is.EqualTo(true));
                    }
                }
            }
        }

        /// <summary>
        /// This test makes sure that the IsUnit member function returns the 
        /// correct result of FALSE for a number of scenarios where the test 
        /// vector is randomly generated and not normalised.  It's highly
        /// unlikely that the random generator will create a unit vector!
        /// </summary>
        [Test]
        public void TestMemberFn_IsUnit_iv ()
        {
            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector4 a = GetNextRandomVector4();

                Assert.That(a.IsUnit(), Is.EqualTo(false));
            }
        }
            
        // Test Constant: Zero //---------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector4 initilised using the Zero constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_Zero_i ()
        {
            Vector4 result = Vector4.Zero;
            Vector4 expected = new Vector4(0, 0, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: One //----------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector4 initilised using the One constant
        /// has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_One_i ()
        {
            Vector4 result = Vector4.One;
            Vector4 expected = new Vector4(1, 1, 1, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitX //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector4 initilised using the UnitX 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitX_i ()
        {
            Vector4 result = Vector4.UnitX;
            Vector4 expected = new Vector4(1, 0, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitY //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector4 initilised using the UnitY
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitY_i ()
        {
            Vector4 result = Vector4.UnitY;
            Vector4 expected = new Vector4(0, 1, 0, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitZ //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector4 initilised using the UnitZ 
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitZ_i ()
        {
            Vector4 result = Vector4.UnitZ;
            Vector4 expected = new Vector4(0, 0, 1, 0);
            AssertEqualWithinReason(result, expected);
        }

        // Test Constant: UnitW //--------------------------------------------//

        /// <summary>
        /// Tests to make sure that a Vector4 initilised using the UnitW
        /// constant has it's member variables correctly set.
        /// </summary>
        [Test]
        public void TestConstant_UnitW_i ()
        {
            Vector4 result = Vector4.UnitW;
            Vector4 expected = new Vector4(0, 0, 0, 1);
            AssertEqualWithinReason(result, expected);
        }

        // Test Static Fn: Distance //----------------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the Distance method
        /// yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_Distance_i ()
        {
            {
                Vector4 a = new Vector4(0, 4, 12, 0);
                Vector4 b = new Vector4(3, 0, 0, 84);

                Fixed32 expected = 85;
                Fixed32 result;

                Vector4.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector4 a = new Vector4(0, -4, 12, 0);
                Vector4 b = new Vector4(3, 0, 0, 84);

                Fixed32 expected = 85;
                Fixed32 result;

                Vector4.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector4 a = new Vector4(0, -4, -12, 0);
                Vector4 b = new Vector4(-3, 0, 0, -84);

                Fixed32 expected = 85;
                Fixed32 result;

                Vector4.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector4 a = Vector4.Zero;

                Fixed32 expected = 0;
                Fixed32 result;

                Vector4.Distance(ref a, ref a, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Distance method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Distance_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector4 a = GetNextRandomVector4();

                Fixed32 expected =
                    RealMaths.Sqrt((a.X * a.X) + (a.Y * a.Y) + (a.Z * a.Z) + (a.W * a.W));

                Assert.That(a.Length(), Is.EqualTo(expected));
            }
        }

        // Test Static Fn: DistanceSquared //---------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the DistanceSquared
        /// method yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_DistanceSquared_i ()
        {
            {
                Vector4 a = new Vector4(0, 4, 12, 0);
                Vector4 b = new Vector4(3, 0, 0, 84);

                Fixed32 expected = 7225;
                Fixed32 result;

                Vector4.DistanceSquared(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector4 a = Vector4.Zero;

                Fixed32 expected = 0;
                Fixed32 result;

                Vector4.DistanceSquared(ref a, ref a, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }


        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// DistanceSquared method yeilds the same results as those obtained
        /// from performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_DistanceSquared_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector4 a = GetNextRandomVector4();
                Vector4 b = GetNextRandomVector4();

                Vector4 c = b - a;

                Fixed32 expected = (c.X * c.X) + (c.Y * c.Y) + (c.Z * c.Z) + (c.W * c.W);
                Fixed32 result;

                Vector4.DistanceSquared(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        // Test Static Fn: Dot //---------------------------------------------//

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Dot method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector4 a = GetNextRandomVector4();
                Vector4 b = GetNextRandomVector4();

                Fixed32 expected = (a.X * b.X) + (a.Y * b.Y) + (a.Z * b.Z) + (a.W * b.W);
                Fixed32 result; Vector4.Dot(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        /// <summary>
        /// Assert that two unit vectors pointing in opposing directions yeild a
        /// dot product of negative one.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_ii ()
        {
            Vector4 a = new Vector4(0, 0, 0, 1);
            Vector4 b = new Vector4(0, 0, 0, -1);

            Fixed32 expected = -1;
            Fixed32 result; Vector4.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that two unit vectors pointing in the same direction yeild a
        /// dot product of one.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_iii ()
        {
            Vector4 a = new Vector4(0, 0, 0, 1);
            Vector4 b = new Vector4(0, 0, 0, 1);

            Fixed32 expected = 1;
            Fixed32 result; Vector4.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that two perpendicular unit vectors yeild a dot product of
        /// zero.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_iv ()
        {
            Vector4 a = new Vector4(0, 0, 1, 0);
            Vector4 b = new Vector4(0, 0, 0, 1);

            Fixed32 expected = 0;
            Fixed32 result; Vector4.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Static Fn: Normalise //---------------------------------------//

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_i()
        {
            {
                Vector4 a = Vector4.Zero;

                Vector4 b;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException),
                    () =>
                    Vector4.Normalise(ref a, out b)
                );
            }

            {
                Vector4 a = new Vector4(
                    Fixed32.MaxValue,
                    Fixed32.MaxValue,
                    Fixed32.MaxValue,
                    Fixed32.MaxValue);

                Vector4 b;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException),
                    () =>
                    Vector4.Normalise(ref a, out b)
                );
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Normalise method yeilds a unit vector (with length equal to one);
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_ii ()
        {
            Fixed32 epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector4 a = GetNextRandomVector4();

                Vector4 b; Vector4.Normalise(ref a, out b);
                Fixed32 expected = 1;
                Fixed32 result1 = b.Length();
                Assert.That(result1, Is.EqualTo(expected).Within(epsilon));

                // The normalise function takes both a ref and out parameter,
                // need to check that if we pass in the same value as both
                // parameters we get the same results.
                Vector4 c = a;
                Vector4.Normalise(ref c, out c);
                Fixed32 result2 = c.Length();
                Assert.That(result2, Is.EqualTo(expected).Within(epsilon));
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Normalise method yeilds a vector, which when multipled by the
        /// length of the original vector results in the same vector as the
        /// original vector;
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_iii ()
        {
            Fixed32 epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector4 a = GetNextRandomVector4();
                Fixed32 l = a.Length();
                Vector4 expected = a;

                Vector4 b; Vector4.Normalise(ref a, out b);
                Vector4 result1 = b * l;
                AssertEqualWithinReason(result1, expected);

                Vector4 c = a;

                // The normalise function takes both a ref and out parameter,
                // need to check that if we pass in the same value as both
                // parameters we get the same results.
                Vector4.Normalise(ref c, out c);
                Vector4 result2 = c * l;
                AssertEqualWithinReason(result2, expected);
            }
        }

        // Test Static Fn: TransformMatrix44 //-------------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformMatix44_i ()
        {
            Vector4 position = new Vector4 (-40, -20, 10, 20);

            Single pi; RealMaths.Pi (out pi);
            Single tau; RealMaths.Tau (out tau);

            Matrix44 rotmati = Matrix44.Identity;
            Matrix44 rotmatx; Matrix44.CreateRotationX(tau, out rotmatx);
            Matrix44 rotmaty; Matrix44.CreateRotationY(pi, out rotmaty);
            Matrix44 rotmatz; Matrix44.CreateRotationZ(-tau, out rotmatz);
            Matrix44 rotmatxyz = rotmatx * rotmaty * rotmatz;

            Vector4 expected1 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected2 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected3 = new Vector4 ( 40, -20, -10, 20);
            Vector4 expected4 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected5 = new Vector4 ( 40, -20, -10, 20);

            Vector4 test1; Vector4.Transform (ref position, ref rotmati, out test1);
            Vector4 test2; Vector4.Transform (ref position, ref rotmatx, out test2);
            Vector4 test3; Vector4.Transform (ref position, ref rotmaty, out test3);
            Vector4 test4; Vector4.Transform (ref position, ref rotmatz, out test4);
            Vector4 test5; Vector4.Transform (ref position, ref rotmatxyz, out test5);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
            AssertEqualWithinReason(test5, expected5);
        }

        // Test Static Fn: TransformNormal //---------------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformNormal_i ()
        {
            Vector4 position = new Vector4 (-40, -20, 10, 20);
            Vector4.Normalise (ref position, out position);

            Single pi; RealMaths.Pi (out pi);
            Single tau; RealMaths.Tau (out tau);

            Matrix44 rotmati = Matrix44.Identity;
            Matrix44 rotmatx; Matrix44.CreateRotationX(pi, out rotmatx);
            Matrix44 rotmaty; Matrix44.CreateRotationY(tau, out rotmaty);
            Matrix44 rotmatz; Matrix44.CreateRotationZ(-pi, out rotmatz);
            Matrix44 rotmatxyz = rotmatx * rotmaty * rotmatz;

            Vector4 expected1 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected2 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected3 = new Vector4 ( 40, -20, -10, 20);
            Vector4 expected4 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected5 = new Vector4 ( 40, -20, -10, 20);

            Vector4.Normalise (ref expected1, out expected1);
            Vector4.Normalise (ref expected2, out expected2);
            Vector4.Normalise (ref expected3, out expected3);
            Vector4.Normalise (ref expected4, out expected4);
            Vector4.Normalise (ref expected5, out expected5);

            Vector4 test1; Vector4.TransformNormal (ref position, ref rotmati, out test1);
            Vector4 test2; Vector4.TransformNormal (ref position, ref rotmatx, out test2);
            Vector4 test3; Vector4.TransformNormal (ref position, ref rotmaty, out test3);
            Vector4 test4; Vector4.TransformNormal (ref position, ref rotmatz, out test4);
            Vector4 test5; Vector4.TransformNormal (ref position, ref rotmatxyz, out test5);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
            AssertEqualWithinReason(test5, expected5);

            // should also work with the standard transform fn
            Vector4 test1n; Vector4.Transform (ref position, ref rotmati, out test1n);
            Vector4 test2n; Vector4.Transform (ref position, ref rotmatx, out test2n);
            Vector4 test3n; Vector4.Transform (ref position, ref rotmaty, out test3n);
            Vector4 test4n; Vector4.Transform (ref position, ref rotmatz, out test4n);
            Vector4 test5n; Vector4.Transform (ref position, ref rotmatxyz, out test5n);

            AssertEqualWithinReason(test1n, expected1);
            AssertEqualWithinReason(test2n, expected2);
            AssertEqualWithinReason(test3n, expected3);
            AssertEqualWithinReason(test4n, expected4);
            AssertEqualWithinReason(test5n, expected5);
        }

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformNormal_ii ()
        {
            Matrix44 rotmat = Matrix44.Identity;
            Vector4 normal = new Vector4 (21, -532, 0, 91);
            Vector4 result;
            Assert.Throws(
                typeof(ArgumentOutOfRangeException),
                () =>
                Vector4.TransformNormal(ref normal, ref rotmat, out result)
            );
        }

        // Test Static Fn: TransformQuaternion //-----------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformQuaternion_i ()
        {
            Vector4 position = new Vector4 (-40, -20, 10, 20);

            Single pi;
            RealMaths.Pi (out pi);

            Quaternion quatmati = new Quaternion (0, 0, 0, 1);
            Quaternion quatmatx = new Quaternion (0, 0, 0, 1);
            Quaternion quatmaty = new Quaternion (0, 1, 0, 0);
            Quaternion quatmatz = new Quaternion (0, 0, 0, 1);
            Quaternion quatmatxyz = new Quaternion (0, 1, 0, 0);

            Vector4 expected1 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected2 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected3 = new Vector4 ( 40, -20, -10, 20);
            Vector4 expected4 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected5 = new Vector4 ( 40, -20, -10, 20);

            Vector4 test1; Vector4.Transform (ref position, ref quatmati, out test1);
            Vector4 test2; Vector4.Transform (ref position, ref quatmatx, out test2);
            Vector4 test3; Vector4.Transform (ref position, ref quatmaty, out test3);
            Vector4 test4; Vector4.Transform (ref position, ref quatmatz, out test4);
            Vector4 test5; Vector4.Transform (ref position, ref quatmatxyz, out test5);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
            AssertEqualWithinReason(test5, expected5);
        }

        // Test Operator: Equality //-----------------------------------------//

        /// <summary>
        /// Helper method for testing equality.
        /// </summary>
        void TestEquality (Vector4 a, Vector4 b, Boolean expected )
        {
            // This test asserts the following:
            //   (a == b) == expected
            //   (b == a) == expected
            //   (a != b) == !expected
            //   (b != a) == !expected

            Boolean result_1a = (a == b);
            Boolean result_1b = (a.Equals(b));
            Boolean result_1c = (a.Equals((Object)b));
            
            Boolean result_2a = (b == a);
            Boolean result_2b = (b.Equals(a));
            Boolean result_2c = (b.Equals((Object)a));

            Boolean result_3a = (a != b);
            Boolean result_4a = (b != a);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_1c, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
            Assert.That(result_2c, Is.EqualTo(expected));
            Assert.That(result_3a, Is.EqualTo(!expected));
            Assert.That(result_4a, Is.EqualTo(!expected));
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of TRUE when two equal  
        /// Vector4 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_i ()
        {
            var a = new Vector4(44, -54, -22, 11);
            var b = new Vector4(44, -54, -22, 11);

            Boolean expected = true;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Makes sure that, for a known example, all the equality opperators
        /// and functions yield the expected result of FALSE when two unequal  
        /// Vector4 objects are compared.
        /// </summary>
        [Test]
        public void TestOperator_Equality_ii ()
        {
            var a = new Vector4(44, 54, 2, 11);
            var b = new Vector4(44, -54, 2, -1);

            Boolean expected = false;

            this.TestEquality(a, b, expected);
        }

        /// <summary>
        /// Tests to make sure that all the equality opperators and functions 
        /// yield the expected result of TRUE when used on a number of randomly 
        /// generated pairs of equal Vector4 objects.
        /// </summary>
        [Test]
        public void TestOperator_Equality_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();

                Vector4 b = a;

                this.TestEquality(a, b, true);
            }
        }


        // Test Operator: Addition //-----------------------------------------//

        /// <summary>
        /// Helper method for testing addition.
        /// </summary>
        void TestAddition (Vector4 a, Vector4 b, Vector4 expected )
        {
            // This test asserts the following:
            //   a + b == expected
            //   b + a == expected

            var result_1a = a + b;
            var result_2a = b + a;

            Vector4 result_1b; Vector4.Add(ref a, ref b, out result_1b);
            Vector4 result_2b; Vector4.Add(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the addition opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_i ()
        {
            var a = new Vector4(3, -6, 44, 11);
            var b = new Vector4(-6, 12, 18, -3);

            var expected = new Vector4(-3, 6, 62, 8);

            this.TestAddition(a, b, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving the zero vector, all the 
        /// addition opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Addition_ii ()
        {
            var a = new Vector4(-2313, 88, 199, 42);

            var expected = a;

            this.TestAddition(a, Vector4.Zero, expected);
        }

        /// <summary>
        /// Assert that, for a known example involving two zero vectors, all the 
        /// addition opperators and functions yield the correct result of zero.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iii ()
        {
            this.TestAddition(Vector4.Zero, Vector4.Zero, Vector4.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// addition opperators and functions yield the same results as a
        /// manual addition calculation.
        /// </summary>
        [Test]
        public void TestOperator_Addition_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();
                var b = GetNextRandomVector4();

                var expected = new Vector4(
                    a.X + b.X, a.Y + b.Y, a.Z + b.Z, a.W + b.W);

                this.TestAddition(a, b, expected);
            }
        }

        // Test Operator: Subtraction //--------------------------------------//
        
        /// <summary>
        /// Helper method for testing subtraction.
        /// </summary>
        void TestSubtraction (Vector4 a, Vector4 b, Vector4 expected )
        {
            // This test asserts the following:
            //   a - b == expected
            //   b - a == -expected

            var result_1a = a - b;
            var result_2a = b - a;

            Vector4 result_1b; Vector4.Subtract(ref a, ref b, out result_1b);
            Vector4 result_2b; Vector4.Subtract(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(-expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(-expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the subtraction opperators
        /// and functions yield the correct result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_i ()
        {
            var a = new Vector4(12, -4, 14, 18);
            var b = new Vector4(15, 11, 7, 27);
            var expected = new Vector4(-3, -15, 7, -9);
            this.TestSubtraction(a, b, expected);

            var c = new Vector4(-423, 342, 7, -800);
            this.TestSubtraction(c, Vector4.Zero, c);
        }

        /// <summary>
        /// Assert that when subtracting the zero vector fromt the zero vector, 
        /// all the subtraction opperators and functions yield the correct 
        /// result.
        /// <summary>
        [Test]
        public void TestOperator_Subtraction_ii ()
        {
            this.TestSubtraction(Vector4.Zero, Vector4.Zero, Vector4.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// subtraction opperators and functions yield the same results as a
        /// manual subtraction calculation.
        /// </summary>
        [Test]
        public void TestOperator_Subtraction_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();
                var b = GetNextRandomVector4();

                var expected = new Vector4(
                    a.X - b.X, a.Y - b.Y, a.Z - b.Z, a.W - b.W);

                this.TestSubtraction(a, b, expected);
            }
        }

        // Test Operator: Negation //-----------------------------------------//
        
        /// <summary>
        /// Helper method for testing negation.
        /// </summary>
        void TestNegation (Vector4 a, Vector4 expected )
        {
            // This test asserts the following:
            //   -a == expected

            var result_1a = -a;

            Vector4 result_1b; Vector4.Negate(ref a, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for known examples, all the negation opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_i ()
        {
            Fixed32 r = 3432;
            Fixed32 s = -6218;
            Fixed32 t = -3432;
            Fixed32 u = 6218;

            var a = new Vector4(r, s, t, u);
            var b = new Vector4(u, t, s, r);
            var c = new Vector4(t, u, r, s);
            var d = new Vector4(s, r, u, t);

            this.TestNegation(a, c);
            this.TestNegation(b, d);
        }

        /// <summary>
        /// Assert that, for known examples involving the zero vector, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_ii ()
        {
            Fixed32 t = -3432;
            Fixed32 u = 6218;
            Fixed32 r = 3432;
            Fixed32 s = -6218;

            var c = new Vector4(t, u, r, s);
            var d = new Vector4(s, r, u, t);

            this.TestNegation(c, Vector4.Zero - c);
            this.TestNegation(d, Vector4.Zero - d);
        }

        /// <summary>
        /// Assert that when negating the zero vector, all the 
        /// negation opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iii ()
        {
            this.TestNegation(Vector4.Zero, Vector4.Zero);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// negation opperators and functions yield the same results as a
        /// manual negation calculation.
        /// </summary>
        [Test]
        public void TestOperator_Negation_iv ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();
                this.TestNegation(a, Vector4.Zero - a);
            }
        }

        // Test Operator: Multiplication //-----------------------------------//

        /// <summary>
        /// Helper method for testing multiplication.
        /// </summary>
        void TestMultiplication (Vector4 a, Vector4 b, Vector4 expected )
        {
            // This test asserts the following:
            //   a * b == expected
            //   b * a == expected

            var result_1a = a * b;
            var result_2a = b * a;

            Vector4 result_1b; Vector4.Multiply(ref a, ref b, out result_1b);
            Vector4 result_2b; Vector4.Multiply(ref b, ref a, out result_2b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_2a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
            Assert.That(result_2b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example, all the multiplication opperators
        /// and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_i ()
        {
            Fixed32 r = -27;
            Fixed32 s = 36;
            Fixed32 t = 9;
            Fixed32 u = -54;

            Fixed32 x = 3;
            Fixed32 y = 6;
            Fixed32 z = -9;

            var a = new Vector4(x, y, x, y);
            var b = new Vector4(z, y, x, z);
            var c = new Vector4(r, s, t, u);

            this.TestMultiplication(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// multiplication opperators and functions yield the same results as a
        /// manual multiplication calculation.
        /// </summary>
        [Test]
        public void TestOperator_Multiplication_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();
                var b = GetNextRandomVector4();

                var c = new Vector4(
                    a.X * b.X, a.Y * b.Y, a.Z * b.Z, a.W * b.W);

                this.TestMultiplication(a, b, c);
            }
        }


        // Test Operator: Division //-----------------------------------------//

        /// <summary>
        /// Helper method for testing division.
        /// </summary>
        void TestDivision (Vector4 a, Vector4 b, Vector4 expected )
        {
            // This test asserts the following:
            //   a / b == expected

            var result_1a = a / b;

            Vector4 result_1b; Vector4.Divide(ref a, ref b, out result_1b);
            
            Assert.That(result_1a, Is.EqualTo(expected));
            Assert.That(result_1b, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that, for a known example using whole numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_i ()
        {
            Fixed32 r = 10;
            Fixed32 s = -40;
            Fixed32 t = 1;
            Fixed32 u = -400;

            Fixed32 x = 2000;
            Fixed32 y = 200;
            Fixed32 z = -5;

            var a = new Vector4(x, y, x, x);
            var b = new Vector4(y, z, x, z);
            var c = new Vector4(r, s, t, u);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a known example using fractional numbers, all the 
        /// division opperators and functions yield the correct result.
        /// </summary>
        [Test]
        public void TestOperator_Division_ii ()
        {
            Fixed32 s = 4;
            Fixed32 t = ((Fixed32) 1 ) / ((Fixed32) 10);
            Fixed32 u = ((Fixed32) (-1) ) / ((Fixed32) 40 );
            Fixed32 v = -20;
            Fixed32 w = 100;
            Fixed32 x = 2000;
            Fixed32 y = 200;
            Fixed32 z = -5;

            var a = new Vector4(y, z, w, v);
            var b = new Vector4(x, y, z, z);
            var c = new Vector4(t, u, v, s);

            this.TestDivision(a, b, c);
        }

        /// <summary>
        /// Assert that, for a number of randomly generated scenarios, all the 
        /// division opperators and functions yield the same results as a
        /// manual addition division.
        /// </summary>
        [Test]
        public void TestOperator_Division_iii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();
                var b = GetNextRandomVector4();

                var c = new Vector4(
                    a.X / b.X, a.Y / b.Y, a.Z / b.Z, a.W / b.W);

                this.TestDivision(a, b, c);
            }
        }

        // Test Static Fn: SmoothStep //--------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();
                var b = GetNextRandomVector4();

                Fixed32 amount1 = 0;
                Vector4 result1;

                Vector4.SmoothStep (
                    ref a, ref b, amount1, out result1);

                AssertEqualWithinReason(result1, a);

                Fixed32 amount2 = 1;
                Vector4 result2;

                Vector4.SmoothStep (
                    ref a, ref b, amount2, out result2);

                AssertEqualWithinReason(result2, b);
            }
        }

        /// <summary>
        /// Assert that, for known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_ii ()
        {
            var a = GetNextRandomVector4();
            var b = GetNextRandomVector4();

            Fixed32 half; RealMaths.Half(out half);

            var tests = new Fixed32[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector4 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector4.SmoothStep (
                            ref a, ref b, amount, out result)
                    );
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_SmoothStep_iii ()
        {
            var a = new Vector4( -30, -30, -30, -30 );
            var b = new Vector4( +30, +30, +30, +30 );

            Fixed32 one = 1;

            Fixed32 i;
            RealMaths.FromFraction(1755, 64, out i); // 27.421875
            
            Fixed32 j;
            RealMaths.FromFraction( 165,  8, out j); // 20.625
            
            Fixed32 k;
            RealMaths.FromFraction( 705, 64, out k); // 11.015625

            Fixed32 a0 = 0;
            Fixed32 a1 = (one * 1) / 8;
            Fixed32 a2 = (one * 2) / 8;
            Fixed32 a3 = (one * 3) / 8;
            Fixed32 a4 = (one * 4) / 8;
            Fixed32 a5 = (one * 5) / 8;
            Fixed32 a6 = (one * 6) / 8;
            Fixed32 a7 = (one * 7) / 8;
            Fixed32 a8 = 1;

            Vector4 r0 = a;
            Vector4 r1 = new Vector4( -i, -i, -i, -i );
            Vector4 r2 = new Vector4( -j, -j, -j, -j );
            Vector4 r3 = new Vector4( -k, -k, -k, -k );
            Vector4 r4 = Vector4.Zero;
            Vector4 r5 = new Vector4(  k,  k,  k,  k );
            Vector4 r6 = new Vector4(  j,  j,  j,  j );
            Vector4 r7 = new Vector4(  i,  i,  i,  i );
            Vector4 r8 = b;

            var knownResults = new List<Tuple<Fixed32, Vector4>>
            {
                new Tuple<Fixed32, Vector4>( a0, r0 ),
                new Tuple<Fixed32, Vector4>( a1, r1 ),
                new Tuple<Fixed32, Vector4>( a2, r2 ),
                new Tuple<Fixed32, Vector4>( a3, r3 ),
                new Tuple<Fixed32, Vector4>( a4, r4 ),
                new Tuple<Fixed32, Vector4>( a5, r5 ),
                new Tuple<Fixed32, Vector4>( a6, r6 ),
                new Tuple<Fixed32, Vector4>( a7, r7 ),
                new Tuple<Fixed32, Vector4>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector4 result;

                Vector4.SmoothStep (
                    ref a, ref b, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        // Test Static Fn: CatmullRom //--------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a = GetNextRandomVector4();
                var b = GetNextRandomVector4();
                var c = GetNextRandomVector4();
                var d = GetNextRandomVector4();

                Fixed32 amount1 = 0;
                Vector4 result1;

                Vector4.CatmullRom (
                    ref a, ref b, ref c, ref d, amount1, out result1);

                AssertEqualWithinReason(result1, b);

                Fixed32 amount2 = 1;
                Vector4 result2;

                Vector4.CatmullRom (
                    ref a, ref b, ref c, ref d, amount2, out result2);

                AssertEqualWithinReason(result2, c);
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_ii ()
        {
            var a = new Vector4( -90, +30, +90, -30 );
            var b = new Vector4( -30, -30, +30, +30 );
            var c = new Vector4( +30, +30, -30, -30 );
            var d = new Vector4( +90, -30, -90, -30 );

            Fixed32 one = 1;

            Fixed32 u = 15;
            Fixed32 v = (Fixed32) 165  / (Fixed32)  8; // 20.5
            Fixed32 w = (Fixed32) 45   / (Fixed32)  2; // 20.625
            Fixed32 x = (Fixed32) 1755 / (Fixed32) 64; // 27.421875
            Fixed32 y = (Fixed32) 15   / (Fixed32)  2; // 14.5
            Fixed32 z = (Fixed32) 705  / (Fixed32) 64; // 11.015625

            Fixed32 a0 = 0;
            Fixed32 a1 = (one * 1) / 8;
            Fixed32 a2 = (one * 2) / 8;
            Fixed32 a3 = (one * 3) / 8;
            Fixed32 a4 = (one * 4) / 8;
            Fixed32 a5 = (one * 5) / 8;
            Fixed32 a6 = (one * 6) / 8;
            Fixed32 a7 = (one * 7) / 8;
            Fixed32 a8 = 1;

            Vector4 r0 = b;
            Vector4 r1 = new Vector4( -w, -x,  w,  x );
            Vector4 r2 = new Vector4( -u, -v,  u,  v );
            Vector4 r3 = new Vector4( -y, -z,  y,  z );
            Vector4 r4 = Vector4.Zero;
            Vector4 r5 = new Vector4(  y,  z, -y, -z );
            Vector4 r6 = new Vector4(  u,  v, -u, -v );
            Vector4 r7 = new Vector4(  w,  x, -w, -x );
            Vector4 r8 = c;

            var knownResults = new List<Tuple<Fixed32, Vector4>>
            {
                new Tuple<Fixed32, Vector4>( a0, r0 ),
                new Tuple<Fixed32, Vector4>( a1, r1 ),
                new Tuple<Fixed32, Vector4>( a2, r2 ),
                new Tuple<Fixed32, Vector4>( a3, r3 ),
                new Tuple<Fixed32, Vector4>( a4, r4 ),
                new Tuple<Fixed32, Vector4>( a5, r5 ),
                new Tuple<Fixed32, Vector4>( a6, r6 ),
                new Tuple<Fixed32, Vector4>( a7, r7 ),
                new Tuple<Fixed32, Vector4>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector4 result;

                Vector4.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        /// <summary>
        /// Assert that, for known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_iii ()
        {
            var a = GetNextRandomVector4();
            var b = GetNextRandomVector4();
            var c = GetNextRandomVector4();
            var d = GetNextRandomVector4();
            
            Fixed32 half; RealMaths.Half(out half);

            var tests = new Fixed32[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector4 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector4.CatmullRom (
                            ref a, ref b, ref c, ref d, amount, out result)
                );
            }
        }

        /// <summary>
        /// This tests compares results against an example where all the control
        /// points are in a straight line.  In this case the resulting spline
        /// should be a straight line.
        /// </summary>
        [Test]
        public void TestStaticFn_CatmullRom_iv ()
        {
            var a = new Vector4( -90, +30, +90, -30 );
            var b = new Vector4( -30, -30, +30, +30 );
            var c = new Vector4( +30, +30, -30, -30 );
            var d = new Vector4( +90, -30, -90, -30 );

            Fixed32 one = 1;

            Fixed32 a0 = 0;
            Fixed32 a1 = (one * 1) / 4;
            Fixed32 a2 = (one * 2) / 4;
            Fixed32 a3 = (one * 3) / 4;
            Fixed32 a4 = 1;

            Vector4 r0 = b;
            Vector4 r1 = new Vector4( -15, -15,  15,  15 );
            Vector4 r2 = Vector4.Zero;
            Vector4 r3 = new Vector4(  15,  15, -15, -15 );
            Vector4 r4 = c;

            var knownResults = new List<Tuple<Fixed32, Vector4>>
            {
                new Tuple<Fixed32, Vector4>( a0, r0 ),
                new Tuple<Fixed32, Vector4>( a1, r1 ),
                new Tuple<Fixed32, Vector4>( a2, r2 ),
                new Tuple<Fixed32, Vector4>( a3, r3 ),
                new Tuple<Fixed32, Vector4>( a4, r4 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector4 result;

                Vector4.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

        // Test Static Fn: Hermite //-----------------------------------------//

        /// <summary>
        /// This test runs a number of random scenarios and makes sure that when
        /// the weighting parameter is at it's limits the spline passes directly 
        /// through the correct control points.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                var a  = GetNextRandomVector4();
                var b  = GetNextRandomVector4();

                var c = GetNextRandomVector4();
                var d = GetNextRandomVector4();

                Vector4 an; Vector4.Normalise(ref c, out an);
                Vector4 bn; Vector4.Normalise(ref d, out bn);

                Fixed32 amount1 = 0;
                Vector4 result1;

                Vector4.Hermite (
                    ref a, ref an, ref b, ref bn, amount1, out result1);

                AssertEqualWithinReason(result1, a);

                Fixed32 amount2 = 1;
                Vector4 result2;

                Vector4.Hermite (
                    ref a, ref an, ref b, ref bn, amount2, out result2);

                AssertEqualWithinReason(result2, b);
            }
        }

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_ii ()
        {
            var a = GetNextRandomVector4();
            var b = GetNextRandomVector4();
            var c = GetNextRandomVector4();
            var d = GetNextRandomVector4();

            Vector4 an; Vector4.Normalise(ref c, out an);
            Vector4 bn; Vector4.Normalise(ref d, out bn);

            Fixed32 half; RealMaths.Half(out half);

            var tests = new Fixed32[] { 2, half + 1, -half, -1 };

            foreach( var amount in tests )
            {
                Vector4 result;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector4.Hermite (
                            ref a, ref an, ref b, ref bn, amount, out result)
                    );
                
            }
        }

        /// <summary>
        /// This tests compares results against a known example.
        /// </summary>
        [Test]
        public void TestStaticFn_Hermite_iii ()
        {
            var a = new Vector4( -100, +50, +100, -50 );
            var b = new Vector4( +100, -50, -100, +50 );

            var c = new Vector4( -10, +5, +10, -5 );
            var d = new Vector4( +10, -5, -10, +5 );

            Vector4 an; Vector4.Normalise(ref c, out an);
            Vector4 bn; Vector4.Normalise(ref d, out bn);

            Fixed32 one = 1;
            
            // 100.1953125
            Fixed32 e = (Fixed32) 51300 / (Fixed32) 512;

            // 50.09765625
            Fixed32 f = (Fixed32) 12825 / (Fixed32) 256;

            // 91.25
            Fixed32 g = (Fixed32) 365 / (Fixed32) 4;

            // 45.625
            Fixed32 h = (Fixed32) 365 / (Fixed32) 8;

            // 75.7421875
            Fixed32 i = (Fixed32) 9695 / (Fixed32) 128;

            // 37.87109375
            Fixed32 j = (Fixed32) 9695 / (Fixed32) 256;

            // 56.25
            Fixed32 k = (Fixed32) 225 / (Fixed32) 4;

            // 28.125
            Fixed32 l = (Fixed32) 225 / (Fixed32) 8;

            // 35.3515625
            Fixed32 m = (Fixed32) 4525 / (Fixed32) 128;

            // 17.67578125
            Fixed32 n = (Fixed32) 4525 / (Fixed32) 256;

            // 15.625
            Fixed32 o = (Fixed32) 125 / (Fixed32) 8;

            // 7.8125
            Fixed32 p = (Fixed32) 125 / (Fixed32) 16;

            // 0.3515625
            Fixed32 q = (Fixed32) 45 / (Fixed32) 128;

            // 0.17578125
            Fixed32 r = (Fixed32) 45 / (Fixed32) 256;

            Fixed32 a0 = 0;
            Fixed32 a1 = (one * 1) / 8;
            Fixed32 a2 = (one * 2) / 8;
            Fixed32 a3 = (one * 3) / 8;
            Fixed32 a4 = (one * 4) / 8;
            Fixed32 a5 = (one * 5) / 8;
            Fixed32 a6 = (one * 6) / 8;
            Fixed32 a7 = (one * 7) / 8;
            Fixed32 a8 = 1;

            Vector4 r0 = b;
            Vector4 r1 = new Vector4(  e, -f, -e,  f );
            Vector4 r2 = new Vector4(  g, -h, -g,  h );
            Vector4 r3 = new Vector4(  i, -j, -i,  j );
            Vector4 r4 = new Vector4(  k, -l, -k,  l );
            Vector4 r5 = new Vector4(  m, -n, -m,  n );
            Vector4 r6 = new Vector4(  o, -p, -o,  p );
            Vector4 r7 = new Vector4( -q,  r,  q, -r );
            Vector4 r8 = c;

            var knownResults = new List<Tuple<Fixed32, Vector4>>
            {
                new Tuple<Fixed32, Vector4>( a0, r0 ),
                new Tuple<Fixed32, Vector4>( a1, r1 ),
                new Tuple<Fixed32, Vector4>( a2, r2 ),
                new Tuple<Fixed32, Vector4>( a3, r3 ),
                new Tuple<Fixed32, Vector4>( a4, r4 ),
                new Tuple<Fixed32, Vector4>( a5, r5 ),
                new Tuple<Fixed32, Vector4>( a6, r6 ),
                new Tuple<Fixed32, Vector4>( a7, r7 ),
                new Tuple<Fixed32, Vector4>( a8, r8 ),
            };

            foreach(var knownResult in knownResults )
            {
                Vector4 result;

                Vector4.CatmullRom (
                    ref a, ref b, ref c, ref d, knownResult.Item1, out result);

                AssertEqualWithinReason(result, knownResult.Item2);
            }
        }

                /// <summary>
        /// Assert that, running the Min function on a number of randomly
        /// generated pairs of Vector4 objects, yields the same results as those
        /// obtained from performing a manual Min calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Min ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector4 a = GetNextRandomVector4();
                Vector4 b = a * 2;

                Vector4 result;
                Vector4.Min (ref a, ref b, out result);

                Assert.That(result.X, Is.EqualTo(a.X < b.X ? a.X : b.X ));
                Assert.That(result.Y, Is.EqualTo(a.Y < b.Y ? a.Y : b.Y ));
                Assert.That(result.Z, Is.EqualTo(a.Z < b.Z ? a.Z : b.Z ));
                Assert.That(result.W, Is.EqualTo(a.W < b.W ? a.W : b.W ));
            }
        }

        /// <summary>
        /// Assert that, running the Max function on a number of randomly
        /// generated pairs of Vector4 objects, yields the same results as those
        /// obtained from performing a manual Max calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Max ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector4 a = GetNextRandomVector4();
                Vector4 b = GetNextRandomVector4();

                Vector4 result;
                Vector4.Max (ref a, ref b, out result);

                Assert.That(result.X, Is.EqualTo(a.X > b.X ? a.X : b.X ));
                Assert.That(result.Y, Is.EqualTo(a.Y > b.Y ? a.Y : b.Y ));
                Assert.That(result.Z, Is.EqualTo(a.Z > b.Z ? a.Z : b.Z ));
                Assert.That(result.W, Is.EqualTo(a.W > b.W ? a.W : b.W ));
            }
        }

        /// <summary>
        /// Assert that, running the Clamp function on a number of randomly
        /// generated Vector4 objects for a given min-max range, yields
        /// results that fall within that range.
        /// </summary>
        [Test]
        public void TestStaticFn_Clamp_i ()
        {
            Vector4 min = new Vector4(-30, 1, 18, -22);
            Vector4 max = new Vector4(32, 130, 47, -2);

            for(Int32 i = 0; i < 100; ++i)
            {
                Vector4 a = GetNextRandomVector4();

                Vector4 result;
                Vector4.Clamp (ref a, ref min, ref max, out result);

                Assert.That(result.X, Is.LessThanOrEqualTo(max.X));
                Assert.That(result.Y, Is.LessThanOrEqualTo(max.Y));
                Assert.That(result.X, Is.GreaterThanOrEqualTo(min.X));
                Assert.That(result.Y, Is.GreaterThanOrEqualTo(min.Y));
            }
        }

        /// <summary>
        /// Assert that, running the Clamp function on an a Vector4 object known
        /// to fall outside of a given min-max range, yields a result that fall 
        /// within that range.
        /// </summary>
        [Test]
        public void TestStaticFn_Clamp_ii ()
        {
            Vector4 min = new Vector4(-30, 1, 18, -22);
            Vector4 max = new Vector4(32, 130, 47, -2);

            Vector4 a = new Vector4(-100, 1113, 50, 14);

            Vector4 expected = new Vector4(-30, 130, 47, -2);

            Vector4 result;
            Vector4.Clamp (ref a, ref min, ref max, out result);

            Assert.That(result.X, Is.LessThanOrEqualTo(max.X));
            Assert.That(result.Y, Is.LessThanOrEqualTo(max.Y));
            Assert.That(result.Z, Is.LessThanOrEqualTo(max.Z));
            Assert.That(result.W, Is.LessThanOrEqualTo(max.W));
            Assert.That(result.X, Is.GreaterThanOrEqualTo(min.X));
            Assert.That(result.Y, Is.GreaterThanOrEqualTo(min.Y));
            Assert.That(result.Z, Is.GreaterThanOrEqualTo(min.Z));
            Assert.That(result.W, Is.GreaterThanOrEqualTo(min.W));

            AssertEqualWithinReason(result, expected);

        }

        /// <summary>
        /// Assert that, running the Lerp function on a number of randomly
        /// generated pairs of Vector4 objects for a range of weighting amounts, 
        /// yields the same results as those obtained from performing a manual 
        /// Lerp calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_i ()
        {
            for(Int32 j = 0; j < 100; ++j)
            {
                Fixed32 delta = j;

                delta = delta / 100;

                for(Int32 i = 0; i < 100; ++i)
                {
                    Vector4 a = GetNextRandomVector4();
                    Vector4 b = GetNextRandomVector4();

                    Vector4 result;
                    Vector4.Lerp (ref a, ref b, delta, out result);

                    Vector4 expected = a + ( ( b - a ) * delta );

                    AssertEqualWithinReason(result, expected);
                }
            }
        }

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Lerp_ii ()
        {
            Vector4 a = GetNextRandomVector4();
            Vector4 b = GetNextRandomVector4();

            Fixed32 half; RealMaths.Half(out half);

            var tests = new Fixed32[] { 2, half + 1, -half, -1 };

            foreach( var weighting in tests )
            {
                Vector4 result; 
                Assert.Throws(
                    typeof(ArgumentOutOfRangeException), 
                    () => 
                        Vector4.Lerp (
                            ref a, ref b, weighting, out result)
                    );
            }
        }


    }}

