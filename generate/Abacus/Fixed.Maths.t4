        #region Maths

        static Fixed32 Sqrt (Fixed32 f, Int32 numberOfIterations)
        {
            if (f.numerator < 0) //NaN in Math.Sqrt
            {
                throw new ArithmeticException("Input Error");
            }
            
            if (f.numerator == 0)
            {
                return Zero;
            }

            Fixed32 k = (f + One) >> 1;
            
            for (Int32 i = 0; i < numberOfIterations; i++)
            {
                k = (k + (f / k)) >> 1;
            }
            
            if (k.numerator < 0)
            {
                throw new ArithmeticException("Overflow");
            }
            
            return k;
        }
        
        internal static Fixed32 Sqrt (Fixed32 f)
        {
            Int32 numberOfIterations = 8;
            
            if (f.numerator > 0x64000) // 409,600
            {
                numberOfIterations = 12;
            }

            if (f.numerator > 0x3e8000) // 4,096,000
            {
                numberOfIterations = 16;
            }
            
            return Sqrt (f, numberOfIterations);
        }

        internal static Fixed32 Square (Fixed32 f)
        {
            int v = f.numerator >> (n / 2);
            int w = f.numerator >> (n - (n / 2));
            return CreateFromRaw (v * w);
        }

        internal static Fixed32 Sin (Fixed32 f)
        {
            Fixed32 x_ = f % Fixed32.Tau;

            if (x_ > Fixed32.Pi)
                x_ -= Fixed32.Tau;

            Fixed32 xx = x_ * x_;

            Fixed32 y = 0;
            y -= Fixed32.One / new Fixed32(2 * 3 * 4 * 5 * 6 * 7);
            y *= xx;
            y += Fixed32.One / new Fixed32(2 * 3 * 4 * 5);
            y *= xx;
            y -= Fixed32.One / new Fixed32(2 * 3);
            y *= xx;
            y += Fixed32.One;
            y *= x_;

            return y;
        }
        
        internal static Fixed32 Cos (Fixed32 f)
        {
            return Sin (PiOver2 - f);
        }
        
        internal static Fixed32 Tan (Fixed32 f)
        {
            return Sin (f) / Cos (f);
        }
        
        public static void Add (ref Fixed32 one, ref Fixed32 other, out Fixed32 ouput)
        {
            ouput.numerator = checked(one.numerator + other.numerator);
        }

        public static void Subtract(ref Fixed32 one, ref Fixed32 other, out Fixed32 ouput)
        {
            ouput.numerator = checked(one.numerator - other.numerator);
        }

        public static void Multiply(ref Fixed32 one, ref Fixed32 other, out Fixed32 output)
        {
            Int64 temp = (Int64)one.numerator * (Int64)other.numerator;

            // rounds: mid values are rounded up
            temp = temp + k;

            // correct by dividing by base
            try
            {
                output.numerator = (Int32)(temp >> n);
            }
            catch (OverflowException)
            {
                if (temp > 0)
                    output.numerator = Int32.MaxValue;
                else
                    output.numerator = Int32.MinValue;
                
            }
        }

        public static void Divide(ref Fixed32 one, ref Fixed32 other, out Fixed32 output)
        {
            Int64 temp = ((Int64)one.numerator) << n;

            // pre-multiply by the base (Upscale to Q16 so that the result will be in Q8 format)
            temp = temp + (((Int64)other.numerator) >> 1);

            // So the result will be rounded ; mid values are rounded up.
            output.numerator = (Int32)(temp / ((Int64)other.numerator));
        }

        #endregion

