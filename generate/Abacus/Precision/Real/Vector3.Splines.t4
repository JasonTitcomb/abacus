        // Splines //---------------------------------------------------------//

        /// <summary>
        /// Interpolates between two vectors using a cubic equation.
        /// </summary>
        public static void SmoothStep (
            ref Vector3 vector1,
            ref Vector3 vector2,
            <#= type #> amount,
            out Vector3 result)
        {
            <#= type #> zero = 0;
            <#= type #> one = 1;
            <#= type #> two = 2;
            <#= type #> three = 3;

            // Make sure that the weighting vector is within the supported range.
            if( amount < zero || amount > one )
            {
                throw new ArgumentOutOfRangeException();
            }

            amount = (amount > one) ? one : ((amount < zero) ? zero : amount);
            amount = (amount * amount) * (three - (two * amount));

            result.X = vector1.X + ((vector2.X - vector1.X) * amount);
            result.Y = vector1.Y + ((vector2.Y - vector1.Y) * amount);
            result.Z = vector1.Z + ((vector2.Z - vector1.Z) * amount);
        }

        /// <summary>
        /// Performs a Catmull-Rom interpolation using the specified positions.
        /// Features:
        /// - The spline passes through all of the control points.
        /// - The spline is C^1 continuous, meaning that there are no
        ///   discontinuities in the tangent direction and magnitude.
        /// - The spline is not C^2 continuous.  The second derivative is
        ///   linearly interpolated within each segment, causing the curvature
        ///   to vary linearly over the length of the segment.
        /// </summary>
        public static void CatmullRom (
            ref Vector3 vector1,
            ref Vector3 vector2,
            ref Vector3 vector3,
            ref Vector3 vector4,
            <#= type #> amount,
            out Vector3 result)
        {
            <#= type #> half; RealMaths.Half(out half);
            <#= type #> zero = 0;
            <#= type #> one = 1;
            <#= type #> two = 2;
            <#= type #> three = 3;
            <#= type #> four = 4;
            <#= type #> five = 5;

            // Make sure that the weighting vector is within the supported range.
            if( amount < zero || amount > one )
            {
                throw new ArgumentOutOfRangeException();
            }

            <#= type #> squared = amount * amount;
            <#= type #> cubed = amount * squared;

            result.X =
                half * ((((two * vector2.X) + ((-vector1.X + vector3.X) *
                amount)) + (((((two * vector1.X) - (five * vector2.X)) + (four *
                vector3.X)) - vector4.X) * squared)) + ((((-vector1.X + (three *
                vector2.X)) - (three * vector3.X)) + vector4.X) * cubed));

            result.Y =
                half * ((((two * vector2.Y) + ((-vector1.Y + vector3.Y) *
                amount)) + (((((two * vector1.Y) - (five * vector2.Y)) + (four *
                vector3.Y)) - vector4.Y) * squared)) + ((((-vector1.Y + (three *
                vector2.Y)) - (three * vector3.Y)) + vector4.Y) * cubed));

            result.Z =
                half * ((((two * vector2.Z) + ((-vector1.Z + vector3.Z) *
                amount)) + (((((two * vector1.Z) - (five * vector2.Z)) + (four *
                vector3.Z)) - vector4.Z) * squared)) + ((((-vector1.Z + (three *
                vector2.Z)) - (three * vector3.Z)) + vector4.Z) * cubed));
        }

        /// <summary>
        /// Performs a Hermite spline interpolation.
        /// </summary>
        public static void Hermite (
            ref Vector3 vector1,
            ref Vector3 tangent1,
            ref Vector3 vector2,
            ref Vector3 tangent2,
            <#= type #> amount,
            out Vector3 result)
        {
            <#= type #> zero = 0;
            <#= type #> one = 1;
            <#= type #> two = 2;
            <#= type #> three = 3;

            // Make sure that the weighting vector is within the supported range.
            if( amount < zero || amount > one )
            {
                throw new ArgumentOutOfRangeException();
            }

            // Make sure that the tangents have been normalised.
            if( !tangent1.IsUnit() || !tangent2.IsUnit() )
            {
                throw new ArgumentOutOfRangeException();
            }

            <#= type #> squared = amount * amount;
            <#= type #> cubed = amount * squared;

            <#= type #> a = ((two * cubed) - (three * squared)) + one;
            <#= type #> b = (-two * cubed) + (three * squared);
            <#= type #> c = (cubed - (two * squared)) + amount;
            <#= type #> d = cubed - squared;

            result.X =
                (vector1.X * a) + (vector2.X * b) +
                (tangent1.X * c) + (tangent2.X * d);

            result.Y =
                (vector1.Y * a) + (vector2.Y * b) +
                (tangent1.Y * c) + (tangent2.Y * d);

            result.Z =
                (vector1.Z * a) + (vector2.Z * b) +
                (tangent1.Z * c) + (tangent2.Z * d);
        }

