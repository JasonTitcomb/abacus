        // Splines //---------------------------------------------------------//

        /// <summary>
        /// Interpolates between two values using a cubic equation.
        /// </summary>
        public static void SmoothStep (
            ref Vector4 value1,
            ref Vector4 value2,
            <#= type #> amount,
            out Vector4 result)
        {
            <#= type #> zero = 0;
            <#= type #> one = 1;
            <#= type #> two = 2;
            <#= type #> three = 3;

            // Make sure that the weighting value is within the supported range.
            if( amount < zero || amount > one )
            {
                throw new ArgumentOutOfRangeException();
            }

            amount = (amount > one) ? one : ((amount < zero) ? zero : amount);
            amount = (amount * amount) * (three - (two * amount));

            result.X = value1.X + ((value2.X - value1.X) * amount);
            result.Y = value1.Y + ((value2.Y - value1.Y) * amount);
            result.Z = value1.Z + ((value2.Z - value1.Z) * amount);
            result.W = value1.W + ((value2.W - value1.W) * amount);
        }

        /// <summary>
        /// Performs a Catmull-Rom interpolation using the specified positions.
        /// Features:
        /// - The spline passes through all of the control points.
        /// - The spline is C^1 continuous, meaning that there are no
        ///   discontinuities in the tangent direction and magnitude.
        /// - The spline is not C^2 continuous.  The second derivative is
        ///   linearly interpolated within each segment, causing the curvature
        ///   to vary linearly over the length of the segment.
        /// </summary>
        public static void CatmullRom (
            ref Vector4 value1,
            ref Vector4 value2,
            ref Vector4 value3,
            ref Vector4 value4,
            <#= type #> amount,
            out Vector4 result)
        {
            <#= type #> half; RealMaths.Half(out half);
            <#= type #> zero = 0;
            <#= type #> one = 1;
            <#= type #> two = 2;
            <#= type #> three = 3;
            <#= type #> four = 4;
            <#= type #> five = 5;

            // Make sure that the weighting value is within the supported range.
            if( amount < zero || amount > one )
            {
                throw new ArgumentOutOfRangeException();
            }

            <#= type #> squared = amount * amount;
            <#= type #> cubed = amount * squared;

            result.X =
                half * ((((two * value2.X) + ((-value1.X + value3.X) *
                amount)) + (((((two * value1.X) - (five * value2.X)) + (four *
                value3.X)) - value4.X) * squared)) + ((((-value1.X + (three *
                value2.X)) - (three * value3.X)) + value4.X) * cubed));

            result.Y =
                half * ((((two * value2.Y) + ((-value1.Y + value3.Y) *
                amount)) + (((((two * value1.Y) - (five * value2.Y)) + (four *
                value3.Y)) - value4.Y) * squared)) + ((((-value1.Y + (three *
                value2.Y)) - (three * value3.Y)) + value4.Y) * cubed));

            result.Z =
                half * ((((two * value2.Z) + ((-value1.Z + value3.Z) *
                amount)) + (((((two * value1.Z) - (five * value2.Z)) + (four *
                value3.Z)) - value4.Z) * squared)) + ((((-value1.Z + (three *
                value2.Z)) - (three * value3.Z)) + value4.Z) * cubed));

            result.W =
                half * ((((two * value2.W) + ((-value1.W + value3.W) *
                amount)) + (((((two * value1.W) - (five * value2.W)) + (four *
                value3.W)) - value4.W) * squared)) + ((((-value1.W + (three *
                value2.W)) - (three * value3.W)) + value4.W) * cubed));
        }

        /// <summary>
        /// Performs a Hermite spline interpolation.
        /// </summary>
        public static void Hermite (
            ref Vector4 value1,
            ref Vector4 tangent1,
            ref Vector4 value2,
            ref Vector4 tangent2,
            <#= type #> amount,
            out Vector4 result)
        {
            <#= type #> zero = 0;
            <#= type #> one = 1;
            <#= type #> two = 2;
            <#= type #> three = 3;

            // Make sure that the weighting value is within the supported range.
            if( amount < zero || amount > one )
            {
                throw new ArgumentOutOfRangeException();
            }

            // Make sure that the tangents have been normalised.
            if( !tangent1.IsUnit() || !tangent2.IsUnit() )
            {
                throw new ArgumentOutOfRangeException();
            }

            <#= type #> squared = amount * amount;
            <#= type #> cubed = amount * squared;

            <#= type #> a = ((two * cubed) - (three * squared)) + one;
            <#= type #> b = (-two * cubed) + (three * squared);
            <#= type #> c = (cubed - (two * squared)) + amount;
            <#= type #> d = cubed - squared;

            result.X =
                (value1.X * a) + (value2.X * b) +
                (tangent1.X * c) + (tangent2.X * d);

            result.Y =
                (value1.Y * a) + (value2.Y * b) +
                (tangent1.Y * c) + (tangent2.Y * d);

            result.Z =
                (value1.Z * a) + (value2.Z * b) +
                (tangent1.Z * c) + (tangent2.Z * d);

            result.W =
                (value1.W * a) + (value2.W * b) +
                (tangent1.W * c) + (tangent2.W * d);
        }

