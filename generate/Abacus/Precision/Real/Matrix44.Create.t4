        /// <summary>
        /// todo
        /// </summary>
        public static void CreateTranslation (
            ref Vector3 position,
            out Matrix44 result)
        {
            result.R0C0 = 1;
            result.R0C1 = 0;
            result.R0C2 = 0;
            result.R0C3 = 0;
            result.R1C0 = 0;
            result.R1C1 = 1;
            result.R1C2 = 0;
            result.R1C3 = 0;
            result.R2C0 = 0;
            result.R2C1 = 0;
            result.R2C2 = 1;
            result.R2C3 = 0;
            result.R3C0 = position.X;
            result.R3C1 = position.Y;
            result.R3C2 = position.Z;
            result.R3C3 = 1;
        }

        /// <summary>
        /// todo
        /// </summary>
        public static void CreateTranslation (
            ref <#= type #> xPosition,
            ref <#= type #> yPosition,
            ref <#= type #> zPosition,
            out Matrix44 result)
        {
            result.R0C0 = 1;
            result.R0C1 = 0;
            result.R0C2 = 0;
            result.R0C3 = 0;
            result.R1C0 = 0;
            result.R1C1 = 1;
            result.R1C2 = 0;
            result.R1C3 = 0;
            result.R2C0 = 0;
            result.R2C1 = 0;
            result.R2C2 = 1;
            result.R2C3 = 0;
            result.R3C0 = xPosition;
            result.R3C1 = yPosition;
            result.R3C2 = zPosition;
            result.R3C3 = 1;
        }

        /// <summary>
        /// Creates a scaling matrix based on x, y, z.
        /// </summary>
        public static void CreateScale (
            ref <#= type #> xScale,
            ref <#= type #> yScale,
            ref <#= type #> zScale,
            out Matrix44 result)
        {
            result.R0C0 = xScale;
            result.R0C1 = 0;
            result.R0C2 = 0;
            result.R0C3 = 0;
            result.R1C0 = 0;
            result.R1C1 = yScale;
            result.R1C2 = 0;
            result.R1C3 = 0;
            result.R2C0 = 0;
            result.R2C1 = 0;
            result.R2C2 = zScale;
            result.R2C3 = 0;
            result.R3C0 = 0;
            result.R3C1 = 0;
            result.R3C2 = 0;
            result.R3C3 = 1;
        }

        /// <summary>
        /// Creates a scaling matrix based on a vector.
        /// </summary>
        public static void CreateScale (
            ref Vector3 scales,
            out Matrix44 result)
        {
            result.R0C0 = scales.X;
            result.R0C1 = 0;
            result.R0C2 = 0;
            result.R0C3 = 0;
            result.R1C0 = 0;
            result.R1C1 = scales.Y;
            result.R1C2 = 0;
            result.R1C3 = 0;
            result.R2C0 = 0;
            result.R2C1 = 0;
            result.R2C2 = scales.Z;
            result.R2C3 = 0;
            result.R3C0 = 0;
            result.R3C1 = 0;
            result.R3C2 = 0;
            result.R3C3 = 1;
        }

        /// <summary>
        /// Create a scaling matrix consistant along each axis
        /// </summary>
        public static void CreateScale (
            ref <#= type #> scale,
            out Matrix44 result)
        {
            result.R0C0 = scale;
            result.R0C1 = 0;
            result.R0C2 = 0;
            result.R0C3 = 0;
            result.R1C0 = 0;
            result.R1C1 = scale;
            result.R1C2 = 0;
            result.R1C3 = 0;
            result.R2C0 = 0;
            result.R2C1 = 0;
            result.R2C2 = scale;
            result.R2C3 = 0;
            result.R3C0 = 0;
            result.R3C1 = 0;
            result.R3C2 = 0;
            result.R3C3 = 1;
        }

        /// <summary>
        /// http://en.wikipedia.org/wiki/Rotation_matrix
        /// </summary>
        public static void CreateRotationX (
            ref <#= type #> radians,
            out Matrix44 result)
        {
            <#= type #> cos = RealMaths.Cos (radians);
            <#= type #> sin = RealMaths.Sin (radians);

            result.R0C0 = 1;
            result.R0C1 = 0;
            result.R0C2 = 0;
            result.R0C3 = 0;
            result.R1C0 = 0;
            result.R1C1 = cos;
            result.R1C2 = sin;
            result.R1C3 = 0;
            result.R2C0 = 0;
            result.R2C1 = -sin;
            result.R2C2 = cos;
            result.R2C3 = 0;
            result.R3C0 = 0;
            result.R3C1 = 0;
            result.R3C2 = 0;
            result.R3C3 = 1;
        }

        /// <summary>
        /// http://en.wikipedia.org/wiki/Rotation_matrix
        /// </summary>
        public static void CreateRotationY (
            ref <#= type #> radians,
            out Matrix44 result)
        {
            <#= type #> cos = RealMaths.Cos (radians);
            <#= type #> sin = RealMaths.Sin (radians);

            result.R0C0 = cos;
            result.R0C1 = 0;
            result.R0C2 = -sin;
            result.R0C3 = 0;
            result.R1C0 = 0;
            result.R1C1 = 1;
            result.R1C2 = 0;
            result.R1C3 = 0;
            result.R2C0 = sin;
            result.R2C1 = 0;
            result.R2C2 = cos;
            result.R2C3 = 0;
            result.R3C0 = 0;
            result.R3C1 = 0;
            result.R3C2 = 0;
            result.R3C3 = 1;
        }

        /// <summary>
        /// http://en.wikipedia.org/wiki/Rotation_matrix
        /// </summary>
        public static void CreateRotationZ (
            ref <#= type #> radians,
            out Matrix44 result)
        {
            <#= type #> cos = RealMaths.Cos (radians);
            <#= type #> sin = RealMaths.Sin (radians);

            result.R0C0 = cos;
            result.R0C1 = sin;
            result.R0C2 = 0;
            result.R0C3 = 0;
            result.R1C0 = -sin;
            result.R1C1 = cos;
            result.R1C2 = 0;
            result.R1C3 = 0;
            result.R2C0 = 0;
            result.R2C1 = 0;
            result.R2C2 = 1;
            result.R2C3 = 0;
            result.R3C0 = 0;
            result.R3C1 = 0;
            result.R3C2 = 0;
            result.R3C3 = 1;
        }

        /// <summary>
        /// todo
        /// </summary>
        public static void CreateFromAxisAngle (
            ref Vector3 axis,
            ref <#= type #> angle,
            out Matrix44 result)
        {
            <#= type #> one = 1;

            <#= type #> x = axis.X;
            <#= type #> y = axis.Y;
            <#= type #> z = axis.Z;

            <#= type #> sin = RealMaths.Sin (angle);
            <#= type #> cos = RealMaths.Cos (angle);

            <#= type #> xx = x * x;
            <#= type #> yy = y * y;
            <#= type #> zz = z * z;

            <#= type #> xy = x * y;
            <#= type #> xz = x * z;
            <#= type #> yz = y * z;

            result.R0C0 = xx + (cos * (one - xx));
            result.R0C1 = (xy - (cos * xy)) + (sin * z);
            result.R0C2 = (xz - (cos * xz)) - (sin * y);
            result.R0C3 = 0;

            result.R1C0 = (xy - (cos * xy)) - (sin * z);
            result.R1C1 = yy + (cos * (one - yy));
            result.R1C2 = (yz - (cos * yz)) + (sin * x);
            result.R1C3 = 0;

            result.R2C0 = (xz - (cos * xz)) + (sin * y);
            result.R2C1 = (yz - (cos * yz)) - (sin * x);
            result.R2C2 = zz + (cos * (one - zz));
            result.R2C3 = 0;

            result.R3C0 = 0;
            result.R3C1 = 0;
            result.R3C2 = 0;
            result.R3C3 = one;
        }

        /// <summary>
        /// todo
        /// </summary>
        public static void CreateFromAllAxis (
            ref Vector3 right,
            ref Vector3 up,
            ref Vector3 backward,
            out Matrix44 result)
        {
            Boolean isRightUnit; Vector3.IsUnit (ref right, out isRightUnit);
            Boolean isUpUnit; Vector3.IsUnit (ref up, out isUpUnit);
            Boolean isBackwardUnit; Vector3.IsUnit (ref backward, out isBackwardUnit);

            if(!isRightUnit || !isUpUnit || !isBackwardUnit )
            {
                throw new ArgumentException("The input vertors must be normalised.");
            }

            result.R0C0 = right.X;
            result.R0C1 = right.Y;
            result.R0C2 = right.Z;
            result.R0C3 = 0;
            result.R1C0 = up.X;
            result.R1C1 = up.Y;
            result.R1C2 = up.Z;
            result.R1C3 = 0;
            result.R2C0 = backward.X;
            result.R2C1 = backward.Y;
            result.R2C2 = backward.Z;
            result.R2C3 = 0;
            result.R3C0 = 0;
            result.R3C1 = 0;
            result.R3C2 = 0;
            result.R3C3 = 1;
        }

        /// <summary>
        /// todo  ???????????
        /// </summary>
        public static void CreateWorldNew (
            ref Vector3 position,
            ref Vector3 forward,
            ref Vector3 up,
            out Matrix44 result)
        {
            Vector3 backward; Vector3.Negate (ref forward, out backward);

            Vector3 right;

            Vector3.Cross (ref up, ref backward, out right);

            Vector3.Normalise(ref right, out right);

            Matrix44.CreateFromAllAxis(ref right, ref up, ref backward, out result);

            result.R3C0 = position.X;
            result.R3C1 = position.Y;
            result.R3C2 = position.Z;
        }

        /// <summary>
        /// todo
        /// </summary>
        public static void CreateWorld (
            ref Vector3 position,
            ref Vector3 forward,
            ref Vector3 up,
            out Matrix44 result)
        {
            Boolean isForwardUnit; Vector3.IsUnit (ref forward, out isForwardUnit);
            Boolean isUpUnit; Vector3.IsUnit (ref up, out isUpUnit);

            if(!isForwardUnit || !isUpUnit )
            {
                throw new ArgumentException("The input vertors must be normalised.");
            }

            Vector3 backward; Vector3.Negate (ref forward, out backward);

            Vector3 vector; Vector3.Normalise (ref backward, out vector);

            Vector3 cross; Vector3.Cross (ref up, ref vector, out cross);

            Vector3 vector2; Vector3.Normalise (ref cross, out vector2);

            Vector3 vector3; Vector3.Cross (ref vector, ref vector2, out vector3);

            result.R0C0 = vector2.X;
            result.R0C1 = vector2.Y;
            result.R0C2 = vector2.Z;
            result.R0C3 = 0;
            result.R1C0 = vector3.X;
            result.R1C1 = vector3.Y;
            result.R1C2 = vector3.Z;
            result.R1C3 = 0;
            result.R2C0 = vector.X;
            result.R2C1 = vector.Y;
            result.R2C2 = vector.Z;
            result.R2C3 = 0;
            result.R3C0 = position.X;
            result.R3C1 = position.Y;
            result.R3C2 = position.Z;
            result.R3C3 = 1;
        }

        /// <summary>
        /// todo
        /// </summary>
        public static void CreateFromQuaternion (
            ref Quaternion quaternion,
            out Matrix44 result)
        {
            Boolean quaternionIsUnit;
            Quaternion.IsUnit (ref quaternion, out quaternionIsUnit);
            if(!quaternionIsUnit)
            {
                throw new ArgumentException("Input quaternion must be normalised.");
            }

            <#= type #> zero = 0;
            <#= type #> one = 1;

            <#= type #> ii = quaternion.I + quaternion.I;
            <#= type #> jj = quaternion.J + quaternion.J;
            <#= type #> kk = quaternion.K + quaternion.K;

            <#= type #> uii = quaternion.U * ii;
            <#= type #> ujj = quaternion.U * jj;
            <#= type #> ukk = quaternion.U * kk;
            <#= type #> iii = quaternion.I * ii;
            <#= type #> ijj = quaternion.I * jj;
            <#= type #> ikk = quaternion.I * kk;
            <#= type #> jjj = quaternion.J * jj;
            <#= type #> jkk = quaternion.J * kk;
            <#= type #> kkk = quaternion.K * kk;

            result.R0C0 = one - (jjj + kkk);
            result.R1C0 = ijj - ukk;
            result.R2C0 = ikk + ujj;
            result.R3C0 = zero;

            result.R0C1 = ijj + ukk;
            result.R1C1 = one - (iii + kkk);
            result.R2C1 = jkk - uii;
            result.R3C1 = zero;

            result.R0C2 = ikk - ujj;
            result.R1C2 = jkk + uii;
            result.R2C2 = one - (iii + jjj);
            result.R3C2 = zero;

            result.R0C3 = zero;
            result.R1C3 = zero;
            result.R2C3 = zero;
            result.R3C3 = one;
        }

        /// <summary>
        /// todo
        /// </summary>
        public static void CreateFromYawPitchRoll (
            ref <#= type #> yaw,
            ref <#= type #> pitch,
            ref <#= type #> roll,
            out Matrix44 result)
        {
            Quaternion quaternion;

            Quaternion.CreateFromYawPitchRoll (ref yaw, ref pitch, ref roll, out quaternion);

            CreateFromQuaternion (ref quaternion, out result);
        }

































