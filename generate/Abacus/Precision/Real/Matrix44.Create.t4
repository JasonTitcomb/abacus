        /// <summary>
        /// todo
        /// </summary>
        public static void CreateTranslation (
            ref Vector3 position,
            out Matrix44 result)
        {
            result.M11 = 1;
            result.M12 = 0;
            result.M13 = 0;
            result.M14 = 0;
            result.M21 = 0;
            result.M22 = 1;
            result.M23 = 0;
            result.M24 = 0;
            result.M31 = 0;
            result.M32 = 0;
            result.M33 = 1;
            result.M34 = 0;
            result.M41 = position.X;
            result.M42 = position.Y;
            result.M43 = position.Z;
            result.M44 = 1;
        }

        /// <summary>
        /// todo
        /// </summary>
        public static void CreateTranslation (
            ref <#= type #> xPosition,
            ref <#= type #> yPosition,
            ref <#= type #> zPosition,
            out Matrix44 result)
        {
            result.M11 = 1;
            result.M12 = 0;
            result.M13 = 0;
            result.M14 = 0;
            result.M21 = 0;
            result.M22 = 1;
            result.M23 = 0;
            result.M24 = 0;
            result.M31 = 0;
            result.M32 = 0;
            result.M33 = 1;
            result.M34 = 0;
            result.M41 = xPosition;
            result.M42 = yPosition;
            result.M43 = zPosition;
            result.M44 = 1;
        }

        /// <summary>
        /// Creates a scaling matrix based on x, y, z.
        /// </summary>
        public static void CreateScale (
            ref <#= type #> xScale,
            ref <#= type #> yScale,
            ref <#= type #> zScale,
            out Matrix44 result)
        {
            result.M11 = xScale;
            result.M12 = 0;
            result.M13 = 0;
            result.M14 = 0;
            result.M21 = 0;
            result.M22 = yScale;
            result.M23 = 0;
            result.M24 = 0;
            result.M31 = 0;
            result.M32 = 0;
            result.M33 = zScale;
            result.M34 = 0;
            result.M41 = 0;
            result.M42 = 0;
            result.M43 = 0;
            result.M44 = 1;
        }

        /// <summary>
        /// Creates a scaling matrix based on a vector.
        /// </summary>
        public static void CreateScale (
            ref Vector3 scales,
            out Matrix44 result)
        {
            result.M11 = scales.X;
            result.M12 = 0;
            result.M13 = 0;
            result.M14 = 0;
            result.M21 = 0;
            result.M22 = scales.Y;
            result.M23 = 0;
            result.M24 = 0;
            result.M31 = 0;
            result.M32 = 0;
            result.M33 = scales.Z;
            result.M34 = 0;
            result.M41 = 0;
            result.M42 = 0;
            result.M43 = 0;
            result.M44 = 1;
        }

        /// <summary>
        /// Create a scaling matrix consistant along each axis
        /// </summary>
        public static void CreateScale (
            ref <#= type #> scale,
            out Matrix44 result)
        {
            result.M11 = scale;
            result.M12 = 0;
            result.M13 = 0;
            result.M14 = 0;
            result.M21 = 0;
            result.M22 = scale;
            result.M23 = 0;
            result.M24 = 0;
            result.M31 = 0;
            result.M32 = 0;
            result.M33 = scale;
            result.M34 = 0;
            result.M41 = 0;
            result.M42 = 0;
            result.M43 = 0;
            result.M44 = 1;
        }

        /// <summary>
        /// http://en.wikipedia.org/wiki/Rotation_matrix
        /// </summary>
        public static void CreateRotationX (
            ref <#= type #> radians,
            out Matrix44 result)
        {
            <#= type #> cos = RealMaths.Cos (radians);
            <#= type #> sin = RealMaths.Sin (radians);

            result.M11 = 1;
            result.M12 = 0;
            result.M13 = 0;
            result.M14 = 0;
            result.M21 = 0;
            result.M22 = cos;
            result.M23 = sin;
            result.M24 = 0;
            result.M31 = 0;
            result.M32 = -sin;
            result.M33 = cos;
            result.M34 = 0;
            result.M41 = 0;
            result.M42 = 0;
            result.M43 = 0;
            result.M44 = 1;
        }

        /// <summary>
        /// http://en.wikipedia.org/wiki/Rotation_matrix
        /// </summary>
        public static void CreateRotationY (
            ref <#= type #> radians,
            out Matrix44 result)
        {
            <#= type #> cos = RealMaths.Cos (radians);
            <#= type #> sin = RealMaths.Sin (radians);

            result.M11 = cos;
            result.M12 = 0;
            result.M13 = -sin;
            result.M14 = 0;
            result.M21 = 0;
            result.M22 = 1;
            result.M23 = 0;
            result.M24 = 0;
            result.M31 = sin;
            result.M32 = 0;
            result.M33 = cos;
            result.M34 = 0;
            result.M41 = 0;
            result.M42 = 0;
            result.M43 = 0;
            result.M44 = 1;
        }

        /// <summary>
        /// http://en.wikipedia.org/wiki/Rotation_matrix
        /// </summary>
        public static void CreateRotationZ (
            ref <#= type #> radians,
            out Matrix44 result)
        {
            <#= type #> cos = RealMaths.Cos (radians);
            <#= type #> sin = RealMaths.Sin (radians);

            result.M11 = cos;
            result.M12 = sin;
            result.M13 = 0;
            result.M14 = 0;
            result.M21 = -sin;
            result.M22 = cos;
            result.M23 = 0;
            result.M24 = 0;
            result.M31 = 0;
            result.M32 = 0;
            result.M33 = 1;
            result.M34 = 0;
            result.M41 = 0;
            result.M42 = 0;
            result.M43 = 0;
            result.M44 = 1;
        }

        /// <summary>
        /// todo
        /// </summary>
        public static void CreateFromAxisAngle (
            ref Vector3 axis,
            ref <#= type #> angle,
            out Matrix44 result)
        {
            <#= type #> one = 1;

            <#= type #> x = axis.X;
            <#= type #> y = axis.Y;
            <#= type #> z = axis.Z;

            <#= type #> sin = RealMaths.Sin (angle);
            <#= type #> cos = RealMaths.Cos (angle);

            <#= type #> xx = x * x;
            <#= type #> yy = y * y;
            <#= type #> zz = z * z;

            <#= type #> xy = x * y;
            <#= type #> xz = x * z;
            <#= type #> yz = y * z;

            result.M11 = xx + (cos * (one - xx));
            result.M12 = (xy - (cos * xy)) + (sin * z);
            result.M13 = (xz - (cos * xz)) - (sin * y);
            result.M14 = 0;

            result.M21 = (xy - (cos * xy)) - (sin * z);
            result.M22 = yy + (cos * (one - yy));
            result.M23 = (yz - (cos * yz)) + (sin * x);
            result.M24 = 0;

            result.M31 = (xz - (cos * xz)) + (sin * y);
            result.M32 = (yz - (cos * yz)) - (sin * x);
            result.M33 = zz + (cos * (one - zz));
            result.M34 = 0;

            result.M41 = 0;
            result.M42 = 0;
            result.M43 = 0;
            result.M44 = one;
        }

        /// <summary>
        /// todo
        /// </summary>
        public static void CreateFromAllAxis (
            ref Vector3 right,
            ref Vector3 up,
            ref Vector3 backward,
            out Matrix44 result)
        {
            Boolean isRightUnit; Vector3.IsUnit (ref right, out isRightUnit);
            Boolean isUpUnit; Vector3.IsUnit (ref up, out isUpUnit);
            Boolean isBackwardUnit; Vector3.IsUnit (ref backward, out isBackwardUnit);

            if(!isRightUnit || !isUpUnit || !isBackwardUnit )
            {
                throw new ArgumentException("The input vertors must be normalised.");
            }

            result.M11 = right.X;
            result.M12 = right.Y;
            result.M13 = right.Z;
            result.M14 = 0;
            result.M21 = up.X;
            result.M22 = up.Y;
            result.M23 = up.Z;
            result.M24 = 0;
            result.M31 = backward.X;
            result.M32 = backward.Y;
            result.M33 = backward.Z;
            result.M34 = 0;
            result.M41 = 0;
            result.M42 = 0;
            result.M43 = 0;
            result.M44 = 1;
        }

        /// <summary>
        /// todo  ???????????
        /// </summary>
        public static void CreateWorldNew (
            ref Vector3 position,
            ref Vector3 forward,
            ref Vector3 up,
            out Matrix44 result)
        {
            Vector3 backward; Vector3.Negate (ref forward, out backward);

            Vector3 right;

            Vector3.Cross (ref up, ref backward, out right);

            Vector3.Normalise(ref right, out right);

            Matrix44.CreateFromAllAxis(ref right, ref up, ref backward, out result);

            result.M41 = position.X;
            result.M42 = position.Y;
            result.M43 = position.Z;
        }

        /// <summary>
        /// todo
        /// </summary>
        public static void CreateWorld (
            ref Vector3 position,
            ref Vector3 forward,
            ref Vector3 up,
            out Matrix44 result)
        {
            Boolean isForwardUnit; Vector3.IsUnit (ref forward, out isForwardUnit);
            Boolean isUpUnit; Vector3.IsUnit (ref up, out isUpUnit);

            if(!isForwardUnit || !isUpUnit )
            {
                throw new ArgumentException("The input vertors must be normalised.");
            }

            Vector3 backward; Vector3.Negate (ref forward, out backward);

            Vector3 vector; Vector3.Normalise (ref backward, out vector);

            Vector3 cross; Vector3.Cross (ref up, ref vector, out cross);

            Vector3 vector2; Vector3.Normalise (ref cross, out vector2);

            Vector3 vector3; Vector3.Cross (ref vector, ref vector2, out vector3);

            result.M11 = vector2.X;
            result.M12 = vector2.Y;
            result.M13 = vector2.Z;
            result.M14 = 0;
            result.M21 = vector3.X;
            result.M22 = vector3.Y;
            result.M23 = vector3.Z;
            result.M24 = 0;
            result.M31 = vector.X;
            result.M32 = vector.Y;
            result.M33 = vector.Z;
            result.M34 = 0;
            result.M41 = position.X;
            result.M42 = position.Y;
            result.M43 = position.Z;
            result.M44 = 1;
        }

        /// <summary>
        /// todo
        /// </summary>
        public static void CreateFromQuaternion (
            ref Quaternion quaternion,
            out Matrix44 result)
        {
            Boolean quaternionIsUnit;
            Quaternion.IsUnit (ref quaternion, out quaternionIsUnit);
            if(!quaternionIsUnit)
            {
                throw new ArgumentException("Input quaternion must be normalised.");
            }

            <#= type #> zero = 0;
            <#= type #> one = 1;


            <#= type #> xs = quaternion.X + quaternion.X;
            <#= type #> ys = quaternion.Y + quaternion.Y;
            <#= type #> zs = quaternion.Z + quaternion.Z;
            <#= type #> wx = quaternion.W * xs;
            <#= type #> wy = quaternion.W * ys;
            <#= type #> wz = quaternion.W * zs;
            <#= type #> xx = quaternion.X * xs;
            <#= type #> xy = quaternion.X * ys;
            <#= type #> xz = quaternion.X * zs;
            <#= type #> yy = quaternion.Y * ys;
            <#= type #> yz = quaternion.Y * zs;
            <#= type #> zz = quaternion.Z * zs;

            result.M11 = one - (yy + zz);
            result.M21 = xy - wz;
            result.M31 = xz + wy;
            result.M41 = zero;

            result.M12 = xy + wz;
            result.M22 = one - (xx + zz);
            result.M32 = yz - wx;
            result.M42 = zero;

            result.M13 = xz - wy;
            result.M23 = yz + wx;
            result.M33 = one - (xx + yy);
            result.M43 = zero;

            result.M14 = zero;
            result.M24 = zero;
            result.M34 = zero;
            result.M44 = one;
        }

        /// <summary>
        /// todo
        /// </summary>
        public static void CreateFromYawPitchRoll (
            ref <#= type #> yaw,
            ref <#= type #> pitch,
            ref <#= type #> roll,
            out Matrix44 result)
        {
            Quaternion quaternion;

            Quaternion.CreateFromYawPitchRoll (ref yaw, ref pitch, ref roll, out quaternion);

            CreateFromQuaternion (ref quaternion, out result);
        }

































