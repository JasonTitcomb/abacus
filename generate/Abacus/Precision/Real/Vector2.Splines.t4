        // Splines //---------------------------------------------------------//

        /// <summary>
        /// Interpolates between two vectors using a cubic equation.
        /// </summary>
        public static void SmoothStep (
            ref Vector2 a,
            ref Vector2 b,
            <#= type #> amount,
            out Vector2 result)
        {
            <#= type #> zero = 0;
            <#= type #> one = 1;
            <#= type #> two = 2;
            <#= type #> three = 3;

            // Make sure that the weighting vector is within the supported range.
            if( amount < zero || amount > one )
            {
                throw new ArgumentOutOfRangeException();
            }

            amount = (amount * amount) * (three - (two * amount));

            result.X = a.X + ((b.X - a.X) * amount);
            result.Y = a.Y + ((b.Y - a.Y) * amount);
        }

        /// <summary>
        /// Performs a Catmull-Rom interpolation using the specified positions.
        /// Features:
        /// - The spline passes through all of the control points.
        /// - The spline is C^1 continuous, meaning that there are no
        ///   discontinuities in the tangent direction and magnitude.
        /// - The spline is not C^2 continuous.  The second derivative is
        ///   linearly interpolated within each segment, causing the curvature
        ///   to vary linearly over the length of the segment.
        /// </summary>
        public static void CatmullRom (
            ref Vector2 a,
            ref Vector2 b,
            ref Vector2 c,
            ref Vector2 d,
            <#= type #> amount,
            out Vector2 result)
        {
            <#= type #> zero = 0;
            <#= type #> one = 1;

            // Make sure that the weighting vector is within the supported range.
            if( amount < zero || amount > one )
            {
                throw new ArgumentOutOfRangeException();
            }

            <#= type #> half; RealMaths.Half(out half);
            <#= type #> two = 2;
            <#= type #> three = 3;
            <#= type #> four = 4;
            <#= type #> five = 5;

            <#= type #> squared = amount * amount;
            <#= type #> cubed = amount * squared;

            result.X =
                half * ((two * b.X) + ((-a.X + c.X) * amount) +
                (((two * a.X) - (five * b.X) + (four * c.X) - d.X) * squared) +
                ((-a.X + (three * b.X) - (three * c.X) + d.X) * cubed));

            result.Y = half * ((two * b.Y) + ((-a.Y + c.Y) * amount) +
                (((two * a.Y) - (five * b.Y) + (four * c.Y) - d.Y) * squared) +
                ((-a.Y + (three * b.Y) - (three * c.Y) + d.Y) * cubed));
        }

        /// <summary>
        /// Performs a Hermite spline interpolation.
        /// </summary>
        public static void Hermite (
            ref Vector2 vector1,
            ref Vector2 tangent1,
            ref Vector2 vector2,
            ref Vector2 tangent2,
            <#= type #> amount,
            out Vector2 result)
        {
            <#= type #> zero = 0;
            <#= type #> one = 1;
            <#= type #> two = 2;
            <#= type #> three = 3;

            // Make sure that the weighting vector is within the supported range.
            if( amount < zero || amount > one )
            {
                throw new ArgumentOutOfRangeException();
            }

            // Make sure that the tangents have been normalised.
            if( !tangent1.IsUnit() || !tangent2.IsUnit() )
            {
                throw new ArgumentOutOfRangeException();
            }

            <#= type #> squared = amount * amount;
            <#= type #> cubed = amount * squared;

            <#= type #> a = ((two * cubed) - (three * squared)) + one;
            <#= type #> b = (-two * cubed) + (three * squared);
            <#= type #> c = (cubed - (two * squared)) + amount;
            <#= type #> d = cubed - squared;

            result.X =
                (vector1.X * a) + (vector2.X * b) +
                (tangent1.X * c) + (tangent2.X * d);

            result.Y =
                (vector1.Y * a) + (vector2.Y * b) +
                (tangent1.Y * c) + (tangent2.Y * d);
        }

