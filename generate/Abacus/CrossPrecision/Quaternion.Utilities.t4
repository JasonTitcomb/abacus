        /// <summary>
        /// Perform a spherical linear interpolation between two Quaternions.
        /// Provides a constant-speed motion along a unit-radius great circle
        /// arc, given the ends and an interpolation parameter between 0 and 1.
        /// http://en.wikipedia.org/wiki/Slerp
        /// </summary>
        public static void Slerp (
            ref Quaternion quaternion1,
            ref Quaternion quaternion2,
            ref <#= type #> amount,
            out Quaternion result)
        {
            <#= type #> zero = 0;
            <#= type #> one = 1;
            <#= type #> epsilon; Maths.Epsilon (out epsilon);

            if( amount < zero || amount > one )
            {
                throw new ArgumentOutOfRangeException();
            }

            <#= type #> remaining = one - amount;

            <#= type #> angle;
            Dot (ref quaternion1, ref quaternion2, out angle);

            if (angle < zero)
            {
                Negate (ref quaternion1, out quaternion1);
                angle = -angle;
            }

            <#= type #> theta = Maths.ArcCos (angle);

            // To avoid division by 0 and by very small numbers the 
            // Lerp is used when theta is small.
            if (theta > epsilon)
            {
                <#= type #> x = Maths.Sin (remaining * theta);
                <#= type #> y = Maths.Sin (amount * theta);
                <#= type #> z = Maths.Sin (theta);

                result = (x / z * quaternion1) + (y / z * quaternion2);
            }
            else
            {
                // This is the same as performing a Lerp.
                result = (remaining * quaternion1) + (amount * quaternion2);
            }
        }

        /// <summary>
        /// Perform a linear interpolation between two Quaternions.
        /// </summary>
        public static void Lerp (
            ref Quaternion quaternion1,
            ref Quaternion quaternion2,
            ref <#= type #> amount,
            out Quaternion result)
        {
            <#= type #> zero = 0;
            <#= type #> one = 1;

            if (amount < zero || amount > one)
            {
                throw new ArgumentOutOfRangeException();
            }

            <#= type #> remaining = one - amount;

            result = (remaining * quaternion1) + (amount * quaternion2);
        }

        /// <summary>
        /// Detemines whether or not the Vector2 is of unit length.
        /// </summary>
        public static void IsUnit (
            ref Quaternion quaternion,
            out Boolean result)
        {
            <#= type #> one = 1;

            result = Maths.IsZero(
                one -
                quaternion.U * quaternion.U -
                quaternion.I * quaternion.I -
                quaternion.J * quaternion.J -
                quaternion.K * quaternion.K);
        }

