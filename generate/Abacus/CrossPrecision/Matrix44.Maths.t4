        /// <summary>
        /// Transposes the rows and columns of a matrix.  The transpose of a
        /// given matrix is the matrix which is formed by turning all the rows
        /// of a given matrix into columns and vice-versa.
        /// N.B. On a computer, one can often avoid explicitly transposing a
        /// matrix in memory by simply accessing the same data in a
        /// different order.
        /// </summary>
        public static void Transpose (ref Matrix44 input, out Matrix44 output)
        {
            output.R0C0 = input.R0C0;
            output.R1C1 = input.R1C1;
            output.R2C2 = input.R2C2;
            output.R3C3 = input.R3C3;

            <#=T#> temp = input.R0C1;
            output.R0C1 = input.R1C0;
            output.R1C0 = temp;

            temp = input.R0C2;
            output.R0C2 = input.R2C0;
            output.R2C0 = temp;

            temp = input.R0C3;
            output.R0C3 = input.R3C0;
            output.R3C0 = temp;

            temp = input.R1C2;
            output.R1C2 = input.R2C1;
            output.R2C1 = temp;

            temp = input.R1C3;
            output.R1C3 = input.R3C1;
            output.R3C1 = temp;

            temp =  input.R2C3;
            output.R2C3 = input.R3C2;
            output.R3C2 = temp;
        }

        /// <summary>
        /// Reference Implementation:
        /// Essential Mathemathics For Games & Interactive Applications
        /// </summary>
        public static void Decompose (
            ref Matrix44 matrix,
            out Vector3 scale,
            out Quaternion rotation,
            out Vector3 translation,
            out Boolean result)
        {
            translation.X = matrix.R3C0;
            translation.Y = matrix.R3C1;
            translation.Z = matrix.R3C2;

            Vector3 a = new Vector3(matrix.R0C0, matrix.R1C0, matrix.R2C0);
            Vector3 b = new Vector3(matrix.R0C1, matrix.R1C1, matrix.R2C1);
            Vector3 c = new Vector3(matrix.R0C2, matrix.R1C2, matrix.R2C2);

            <#=T#> aLen; Vector3.Length(ref a, out aLen); scale.X = aLen;
            <#=T#> bLen; Vector3.Length(ref b, out bLen); scale.Y = bLen;
            <#=T#> cLen; Vector3.Length(ref c, out cLen); scale.Z = cLen;

            if ( Maths.IsZero(scale.X) ||
                 Maths.IsZero(scale.Y) ||
                 Maths.IsZero(scale.Z) )
            {
                rotation = Quaternion.Identity;
                result = false;
            }

            <#=T#> epsilon; Maths.Epsilon(out epsilon);

            if (aLen < epsilon) a = Vector3.Zero;
            else Vector3.Normalise(ref a, out a);

            if (bLen < epsilon) b = Vector3.Zero;
            else Vector3.Normalise(ref b, out b);

            if (cLen < epsilon) c = Vector3.Zero;
            else Vector3.Normalise(ref c, out c);

            Vector3 right = new Vector3(a.X, b.X, c.X);
            Vector3 up = new Vector3(a.Y, b.Y, c.Y);
            Vector3 backward = new Vector3(a.Z, b.Z, c.Z);

            if (right == Vector3.Zero) right = Vector3.Right;
            if (up == Vector3.Zero) up = Vector3.Up;
            if (backward == Vector3.Zero) backward = Vector3.Backward;

            Vector3.Normalise(ref right, out right);
            Vector3.Normalise(ref up, out up);
            Vector3.Normalise(ref backward, out backward);

            Matrix44 rotMat;
            Matrix44.CreateFromAllAxis(
                ref right, ref up, ref backward, out rotMat);

            Quaternion.CreateFromRotationMatrix(ref rotMat, out rotation);

            result = true;
        }

        /// <summary>
        /// A determinant is a scalar number which is calculated from a matrix.
        /// This number can determine whether a set of linear equations are
        /// solvable, in other words whether the matrix can be inverted.
        /// </summary>
        public static void Determinant (ref Matrix44 m, out <#=T#> result)
        {
            result =
                + m.R0C3 * m.R1C2 * m.R2C1 * m.R3C0
                - m.R0C2 * m.R1C3 * m.R2C1 * m.R3C0
                - m.R0C3 * m.R1C1 * m.R2C2 * m.R3C0
                + m.R0C1 * m.R1C3 * m.R2C2 * m.R3C0
                + m.R0C2 * m.R1C1 * m.R2C3 * m.R3C0
                - m.R0C1 * m.R1C2 * m.R2C3 * m.R3C0
                - m.R0C3 * m.R1C2 * m.R2C0 * m.R3C1
                + m.R0C2 * m.R1C3 * m.R2C0 * m.R3C1
                + m.R0C3 * m.R1C0 * m.R2C2 * m.R3C1
                - m.R0C0 * m.R1C3 * m.R2C2 * m.R3C1
                - m.R0C2 * m.R1C0 * m.R2C3 * m.R3C1
                + m.R0C0 * m.R1C2 * m.R2C3 * m.R3C1
                + m.R0C3 * m.R1C1 * m.R2C0 * m.R3C2
                - m.R0C1 * m.R1C3 * m.R2C0 * m.R3C2
                - m.R0C3 * m.R1C0 * m.R2C1 * m.R3C2
                + m.R0C0 * m.R1C3 * m.R2C1 * m.R3C2
                + m.R0C1 * m.R1C0 * m.R2C3 * m.R3C2
                - m.R0C0 * m.R1C1 * m.R2C3 * m.R3C2
                - m.R0C2 * m.R1C1 * m.R2C0 * m.R3C3
                + m.R0C1 * m.R1C2 * m.R2C0 * m.R3C3
                + m.R0C2 * m.R1C0 * m.R2C1 * m.R3C3
                - m.R0C0 * m.R1C2 * m.R2C1 * m.R3C3
                - m.R0C1 * m.R1C0 * m.R2C2 * m.R3C3
                + m.R0C0 * m.R1C1 * m.R2C2 * m.R3C3;
        }

        /// <summary>
        /// The inverse of a matrix is another matrix that when multiplied
        /// by the original matrix yields the identity matrix.
        /// </summary>
        public static void Invert (ref Matrix44 m, out Matrix44 result)
        {
            <#=T#> one = 1;
            <#=T#> d;
            Determinant (ref m, out d);
            <#=T#> s = one / d;

            result.R0C0 =
                + m.R1C2 * m.R2C3 * m.R3C1 - m.R1C3 * m.R2C2 * m.R3C1
                + m.R1C3 * m.R2C1 * m.R3C2 - m.R1C1 * m.R2C3 * m.R3C2
                - m.R1C2 * m.R2C1 * m.R3C3 + m.R1C1 * m.R2C2 * m.R3C3;

            result.R0C1 =
                + m.R0C3 * m.R2C2 * m.R3C1 - m.R0C2 * m.R2C3 * m.R3C1
                - m.R0C3 * m.R2C1 * m.R3C2 + m.R0C1 * m.R2C3 * m.R3C2
                + m.R0C2 * m.R2C1 * m.R3C3 - m.R0C1 * m.R2C2 * m.R3C3;

            result.R0C2 =
                + m.R0C2 * m.R1C3 * m.R3C1 - m.R0C3 * m.R1C2 * m.R3C1
                + m.R0C3 * m.R1C1 * m.R3C2 - m.R0C1 * m.R1C3 * m.R3C2
                - m.R0C2 * m.R1C1 * m.R3C3 + m.R0C1 * m.R1C2 * m.R3C3;

            result.R0C3 =
                + m.R0C3 * m.R1C2 * m.R2C1 - m.R0C2 * m.R1C3 * m.R2C1
                - m.R0C3 * m.R1C1 * m.R2C2 + m.R0C1 * m.R1C3 * m.R2C2
                + m.R0C2 * m.R1C1 * m.R2C3 - m.R0C1 * m.R1C2 * m.R2C3;

            result.R1C0 =
                + m.R1C3 * m.R2C2 * m.R3C0 - m.R1C2 * m.R2C3 * m.R3C0
                - m.R1C3 * m.R2C0 * m.R3C2 + m.R1C0 * m.R2C3 * m.R3C2
                + m.R1C2 * m.R2C0 * m.R3C3 - m.R1C0 * m.R2C2 * m.R3C3;

            result.R1C1 =
                + m.R0C2 * m.R2C3 * m.R3C0 - m.R0C3 * m.R2C2 * m.R3C0
                + m.R0C3 * m.R2C0 * m.R3C2 - m.R0C0 * m.R2C3 * m.R3C2
                - m.R0C2 * m.R2C0 * m.R3C3 + m.R0C0 * m.R2C2 * m.R3C3;

            result.R1C2 =
                + m.R0C3 * m.R1C2 * m.R3C0 - m.R0C2 * m.R1C3 * m.R3C0
                - m.R0C3 * m.R1C0 * m.R3C2 + m.R0C0 * m.R1C3 * m.R3C2
                + m.R0C2 * m.R1C0 * m.R3C3 - m.R0C0 * m.R1C2 * m.R3C3;

            result.R1C3 =
                + m.R0C2 * m.R1C3 * m.R2C0 - m.R0C3 * m.R1C2 * m.R2C0
                + m.R0C3 * m.R1C0 * m.R2C2 - m.R0C0 * m.R1C3 * m.R2C2
                - m.R0C2 * m.R1C0 * m.R2C3 + m.R0C0 * m.R1C2 * m.R2C3;

            result.R2C0 =
                + m.R1C1 * m.R2C3 * m.R3C0 - m.R1C3 * m.R2C1 * m.R3C0
                + m.R1C3 * m.R2C0 * m.R3C1 - m.R1C0 * m.R2C3 * m.R3C1
                - m.R1C1 * m.R2C0 * m.R3C3 + m.R1C0 * m.R2C1 * m.R3C3;

            result.R2C1 =
                + m.R0C3 * m.R2C1 * m.R3C0 - m.R0C1 * m.R2C3 * m.R3C0
                - m.R0C3 * m.R2C0 * m.R3C1 + m.R0C0 * m.R2C3 * m.R3C1
                + m.R0C1 * m.R2C0 * m.R3C3 - m.R0C0 * m.R2C1 * m.R3C3;

            result.R2C2 =
                + m.R0C1 * m.R1C3 * m.R3C0 - m.R0C3 * m.R1C1 * m.R3C0
                + m.R0C3 * m.R1C0 * m.R3C1 - m.R0C0 * m.R1C3 * m.R3C1
                - m.R0C1 * m.R1C0 * m.R3C3 + m.R0C0 * m.R1C1 * m.R3C3;

            result.R2C3 =
                + m.R0C3 * m.R1C1 * m.R2C0 - m.R0C1 * m.R1C3 * m.R2C0
                - m.R0C3 * m.R1C0 * m.R2C1 + m.R0C0 * m.R1C3 * m.R2C1
                + m.R0C1 * m.R1C0 * m.R2C3 - m.R0C0 * m.R1C1 * m.R2C3;

            result.R3C0 =
                + m.R1C2 * m.R2C1 * m.R3C0 - m.R1C1 * m.R2C2 * m.R3C0
                - m.R1C2 * m.R2C0 * m.R3C1 + m.R1C0 * m.R2C2 * m.R3C1
                + m.R1C1 * m.R2C0 * m.R3C2 - m.R1C0 * m.R2C1 * m.R3C2;

            result.R3C1 =
                + m.R0C1 * m.R2C2 * m.R3C0 - m.R0C2 * m.R2C1 * m.R3C0
                + m.R0C2 * m.R2C0 * m.R3C1 - m.R0C0 * m.R2C2 * m.R3C1
                - m.R0C1 * m.R2C0 * m.R3C2 + m.R0C0 * m.R2C1 * m.R3C2;

            result.R3C2 =
                + m.R0C2 * m.R1C1 * m.R3C0 - m.R0C1 * m.R1C2 * m.R3C0
                - m.R0C2 * m.R1C0 * m.R3C1 + m.R0C0 * m.R1C2 * m.R3C1
                + m.R0C1 * m.R1C0 * m.R3C2 - m.R0C0 * m.R1C1 * m.R3C2;

            result.R3C3 =
                + m.R0C1 * m.R1C2 * m.R2C0 - m.R0C2 * m.R1C1 * m.R2C0
                + m.R0C2 * m.R1C0 * m.R2C1 - m.R0C0 * m.R1C2 * m.R2C1
                - m.R0C1 * m.R1C0 * m.R2C2 + m.R0C0 * m.R1C1 * m.R2C2;


            Multiply (ref result, ref s, out result);
        }

        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        // TODO: FROM XNA, NEEDS REVIEW
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        /// <summary>
        /// Transforms a Matrix by applying a Quaternion rotation.
        /// </summary>
        public static void Transform (ref Matrix44 value, ref Quaternion rotation, out Matrix44 result)
        {
            <#=T#> one = 1;

            <#=T#> num21 = rotation.I + rotation.I;
            <#=T#> num11 = rotation.J + rotation.J;
            <#=T#> num10 = rotation.K + rotation.K;

            <#=T#> num20 = rotation.U * num21;
            <#=T#> num19 = rotation.U * num11;
            <#=T#> num18 = rotation.U * num10;
            <#=T#> num17 = rotation.I * num21;
            <#=T#> num16 = rotation.I * num11;
            <#=T#> num15 = rotation.I * num10;
            <#=T#> num14 = rotation.J * num11;
            <#=T#> num13 = rotation.J * num10;
            <#=T#> num12 = rotation.K * num10;

            <#=T#> num9 = (one - num14) - num12;

            <#=T#> num8 = num16 - num18;
            <#=T#> num7 = num15 + num19;
            <#=T#> num6 = num16 + num18;

            <#=T#> num5 = (one - num17) - num12;

            <#=T#> num4 = num13 - num20;
            <#=T#> num3 = num15 - num19;
            <#=T#> num2 = num13 + num20;

            <#=T#> num = (one - num17) - num14;

            <#=T#> num37 = ((value.R0C0 * num9) + (value.R0C1 * num8)) + (value.R0C2 * num7);
            <#=T#> num36 = ((value.R0C0 * num6) + (value.R0C1 * num5)) + (value.R0C2 * num4);
            <#=T#> num35 = ((value.R0C0 * num3) + (value.R0C1 * num2)) + (value.R0C2 * num);

            <#=T#> num34 = value.R0C3;

            <#=T#> num33 = ((value.R1C0 * num9) + (value.R1C1 * num8)) + (value.R1C2 * num7);
            <#=T#> num32 = ((value.R1C0 * num6) + (value.R1C1 * num5)) + (value.R1C2 * num4);
            <#=T#> num31 = ((value.R1C0 * num3) + (value.R1C1 * num2)) + (value.R1C2 * num);

            <#=T#> num30 = value.R1C3;

            <#=T#> num29 = ((value.R2C0 * num9) + (value.R2C1 * num8)) + (value.R2C2 * num7);
            <#=T#> num28 = ((value.R2C0 * num6) + (value.R2C1 * num5)) + (value.R2C2 * num4);
            <#=T#> num27 = ((value.R2C0 * num3) + (value.R2C1 * num2)) + (value.R2C2 * num);

            <#=T#> num26 = value.R2C3;

            <#=T#> num25 = ((value.R3C0 * num9) + (value.R3C1 * num8)) + (value.R3C2 * num7);
            <#=T#> num24 = ((value.R3C0 * num6) + (value.R3C1 * num5)) + (value.R3C2 * num4);
            <#=T#> num23 = ((value.R3C0 * num3) + (value.R3C1 * num2)) + (value.R3C2 * num);

            <#=T#> num22 = value.R3C3;

            result.R0C0 = num37;
            result.R0C1 = num36;
            result.R0C2 = num35;
            result.R0C3 = num34;
            result.R1C0 = num33;
            result.R1C1 = num32;
            result.R1C2 = num31;
            result.R1C3 = num30;
            result.R2C0 = num29;
            result.R2C1 = num28;
            result.R2C2 = num27;
            result.R2C3 = num26;
            result.R3C0 = num25;
            result.R3C1 = num24;
            result.R3C2 = num23;
            result.R3C3 = num22;
        }

