        /// <summary>
        /// todo
        /// </summary>
        public static void CreateFromAxisAngle (
            ref Vector3 axis,
            ref <#= type #> angle,
            out Quaternion result)
        {
            <#= type #> half; Maths.Half(out half);
            <#= type #> theta = angle * half;

            <#= type #> sin = Maths.Sin (theta);
            <#= type #> cos = Maths.Cos (theta);

            result.I = axis.X * sin;
            result.J = axis.Y * sin;
            result.K = axis.Z * sin;

            result.U = cos;
        }

        /// <summary>
        /// todo
        /// </summary>
        public static void CreateFromYawPitchRoll (
            ref <#= type #> yaw,
            ref <#= type #> pitch,
            ref <#= type #> roll,
            out Quaternion result)
        {
            <#= type #> half; Maths.Half(out half);
            <#= type #> num9 = roll * half;

            <#= type #> num6 = Maths.Sin (num9);
            <#= type #> num5 = Maths.Cos (num9);

            <#= type #> num8 = pitch * half;

            <#= type #> num4 = Maths.Sin (num8);
            <#= type #> num3 = Maths.Cos (num8);

            <#= type #> num7 = yaw * half;

            <#= type #> num2 = Maths.Sin (num7);
            <#= type #> num = Maths.Cos (num7);

            result.I = ((num * num4) * num5) + ((num2 * num3) * num6);
            result.J = ((num2 * num3) * num5) - ((num * num4) * num6);
            result.K = ((num * num3) * num6) - ((num2 * num4) * num5);
            result.U = ((num * num3) * num5) + ((num2 * num4) * num6);
        }

        /// <summary>
        /// todo
        /// </summary>
        public static void CreateFromRotationMatrix (
            ref Matrix44 matrix,
            out Quaternion result)
        {
            <#= type #> zero = 0;
            <#= type #> half; Maths.Half(out half);
            <#= type #> one = 1;

            <#= type #> num8 = (matrix.R0C0 + matrix.R1C1) + matrix.R2C2;

            if (num8 > zero)
            {
                <#= type #> num = Maths.Sqrt (num8 + one);
                result.U = num * half;
                num = half / num;
                result.I = (matrix.R1C2 - matrix.R2C1) * num;
                result.J = (matrix.R2C0 - matrix.R0C2) * num;
                result.K = (matrix.R0C1 - matrix.R1C0) * num;
            }
            else if ((matrix.R0C0 >= matrix.R1C1) && (matrix.R0C0 >= matrix.R2C2))
            {
                <#= type #> num7 = Maths.Sqrt (((one + matrix.R0C0) - matrix.R1C1) - matrix.R2C2);
                <#= type #> num4 = half / num7;
                result.I = half * num7;
                result.J = (matrix.R0C1 + matrix.R1C0) * num4;
                result.K = (matrix.R0C2 + matrix.R2C0) * num4;
                result.U = (matrix.R1C2 - matrix.R2C1) * num4;
            }
            else if (matrix.R1C1 > matrix.R2C2)
            {
                <#= type #> num6 =Maths.Sqrt (((one + matrix.R1C1) - matrix.R0C0) - matrix.R2C2);
                <#= type #> num3 = half / num6;
                result.I = (matrix.R1C0 + matrix.R0C1) * num3;
                result.J = half * num6;
                result.K = (matrix.R2C1 + matrix.R1C2) * num3;
                result.U = (matrix.R2C0 - matrix.R0C2) * num3;
            }
            else
            {
                <#= type #> num5 = Maths.Sqrt (((one + matrix.R2C2) - matrix.R0C0) - matrix.R1C1);
                <#= type #> num2 = half / num5;
                result.I = (matrix.R2C0 + matrix.R0C2) * num2;
                result.J = (matrix.R2C1 + matrix.R1C2) * num2;
                result.K = half * num5;
                result.U = (matrix.R0C1 - matrix.R1C0) * num2;
            }
        }
