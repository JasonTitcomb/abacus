        /// <summary>
        /// Creates a Quaternion from a vector and an angle to rotate about
        /// the vector.
        /// </summary>
        public static void CreateFromAxisAngle (
            ref Vector3 axis, ref <#= type #> angle, out Quaternion result)
        {
            <#= type #> half; Maths.Half(out half);
            <#= type #> theta = angle * half;

            <#= type #> sin = Maths.Sin (theta);
            <#= type #> cos = Maths.Cos (theta);

            result.I = axis.X * sin;
            result.J = axis.Y * sin;
            result.K = axis.Z * sin;

            result.U = cos;
        }

        /// <summary>
        /// Creates a new Quaternion from specified yaw, pitch, and roll angles.
        /// </summary>
        public static void CreateFromYawPitchRoll (
            ref <#= type #> yaw, ref <#= type #> pitch,
            ref <#= type #> roll, out Quaternion result)
        {
            <#= type #> half; Maths.Half(out half);

            <#= type #> hr = roll * half;
            <#= type #> hp = pitch * half;
            <#= type #> hy = yaw * half;

            <#= type #> shr = Maths.Sin (hr);
            <#= type #> chr = Maths.Cos (hr);
            <#= type #> shp = Maths.Sin (hp);
            <#= type #> chp = Maths.Cos (hp);
            <#= type #> shy = Maths.Sin (hy);
            <#= type #> chy = Maths.Cos (hy);

            result.I = (chy * shp * chr) + (shy * chp * shr);
            result.J = (shy * chp * chr) - (chy * shp * shr);
            result.K = (chy * chp * shr) - (shy * shp * chr);
            result.U = (chy * chp * chr) + (shy * shp * shr);
        }

        /// <summary>
        /// Creates a Quaternion from a rotation Matrix44.
        /// </summary>
        public static void CreateFromRotationMatrix (
            ref Matrix44 m, out Quaternion result)
        {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/
            <#= type #> zero = 0;
            <#= type #> half; Maths.Half(out half);
            <#= type #> one = 1;

            <#= type #> num8 = (matrix.R0C0 + matrix.R1C1) + matrix.R2C2;

            if (num8 > zero)
            {
                <#= type #> num = Maths.Sqrt (num8 + one);
                result.U = num * half;
                num = half / num;
                result.I = (matrix.R1C2 - matrix.R2C1) * num;
                result.J = (matrix.R2C0 - matrix.R0C2) * num;
                result.K = (matrix.R0C1 - matrix.R1C0) * num;
            }
            else if ((matrix.R0C0 >= matrix.R1C1) && (matrix.R0C0 >= matrix.R2C2))
            {
                <#= type #> num7 = Maths.Sqrt (((one + matrix.R0C0) - matrix.R1C1) - matrix.R2C2);
                <#= type #> num4 = half / num7;
                result.I = half * num7;
                result.J = (matrix.R0C1 + matrix.R1C0) * num4;
                result.K = (matrix.R0C2 + matrix.R2C0) * num4;
                result.U = (matrix.R1C2 - matrix.R2C1) * num4;
            }
            else if (matrix.R1C1 > matrix.R2C2)
            {
                <#= type #> num6 =Maths.Sqrt (((one + matrix.R1C1) - matrix.R0C0) - matrix.R2C2);
                <#= type #> num3 = half / num6;
                result.I = (matrix.R1C0 + matrix.R0C1) * num3;
                result.J = half * num6;
                result.K = (matrix.R2C1 + matrix.R1C2) * num3;
                result.U = (matrix.R2C0 - matrix.R0C2) * num3;
            }
            else
            {
                <#= type #> num5 = Maths.Sqrt (((one + matrix.R2C2) - matrix.R0C0) - matrix.R1C1);
                <#= type #> num2 = half / num5;
                result.I = (matrix.R2C0 + matrix.R0C2) * num2;
                result.J = (matrix.R2C1 + matrix.R1C2) * num2;
                result.K = half * num5;
                result.U = (matrix.R0C1 - matrix.R1C0) * num2;
            }
        }
