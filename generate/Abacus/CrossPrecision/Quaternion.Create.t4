        /// <summary>
        /// Creates a Quaternion from a vector and an angle to rotate about
        /// the vector.
        /// </summary>
        public static void CreateFromAxisAngle (
            ref Vector3 axis, ref <#= type #> angle, out Quaternion result)
        {
            <#= type #> half; Maths.Half(out half);
            <#= type #> theta = angle * half;

            <#= type #> sin = Maths.Sin (theta);
            <#= type #> cos = Maths.Cos (theta);

            result.I = axis.X * sin;
            result.J = axis.Y * sin;
            result.K = axis.Z * sin;

            result.U = cos;
        }

        /// <summary>
        /// Creates a new Quaternion from specified yaw, pitch, and roll angles.
        /// </summary>
        public static void CreateFromYawPitchRoll (
            ref <#= type #> yaw, ref <#= type #> pitch,
            ref <#= type #> roll, out Quaternion result)
        {
            <#= type #> half; Maths.Half(out half);

            <#= type #> hr = roll * half;
            <#= type #> hp = pitch * half;
            <#= type #> hy = yaw * half;

            <#= type #> shr = Maths.Sin (hr);
            <#= type #> chr = Maths.Cos (hr);
            <#= type #> shp = Maths.Sin (hp);
            <#= type #> chp = Maths.Cos (hp);
            <#= type #> shy = Maths.Sin (hy);
            <#= type #> chy = Maths.Cos (hy);

            result.I = (chy * shp * chr) + (shy * chp * shr);
            result.J = (shy * chp * chr) - (chy * shp * shr);
            result.K = (chy * chp * shr) - (shy * shp * chr);
            result.U = (chy * chp * chr) + (shy * shp * shr);
        }

        /// <summary>
        /// Creates a Quaternion from a rotation Matrix44.
        /// </summary>
        public static void CreateFromRotationMatrix (
            ref Matrix44 m, out Quaternion result)
        {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/mToQuaternion/
            <#= type #> zero = 0;
            <#= type #> half; Maths.Half(out half);
            <#= type #> one = 1;

            <#= type #> tr = (m.R0C0 + m.R1C1) + m.R2C2;

            if (tr > zero)
            {
                <#= type #> s = Maths.Sqrt (tr + one);
                result.U = s * half;
                s = half / s;
                result.I = (m.R1C2 - m.R2C1) * s;
                result.J = (m.R2C0 - m.R0C2) * s;
                result.K = (m.R0C1 - m.R1C0) * s;
            }
            else if ((m.R0C0 >= m.R1C1) && (m.R0C0 >= m.R2C2))
            {
                <#= type #> s7 = Maths.Sqrt (((one + m.R0C0) - m.R1C1) - m.R2C2);
                <#= type #> s4 = half / s7;

                result.U = (m.R1C2 - m.R2C1) * s4;
                result.I = half * s7;
                result.J = (m.R0C1 + m.R1C0) * s4;
                result.K = (m.R0C2 + m.R2C0) * s4;
            }
            else if (m.R1C1 > m.R2C2)
            {
                <#= type #> s6 =Maths.Sqrt (((one + m.R1C1) - m.R0C0) - m.R2C2);
                <#= type #> s3 = half / s6;

                result.U = (m.R2C0 - m.R0C2) * s3;
                result.I = (m.R1C0 + m.R0C1) * s3;
                result.J = half * s6;
                result.K = (m.R2C1 + m.R1C2) * s3;
            }
            else
            {
                <#= type #> s5 = Maths.Sqrt (((one + m.R2C2) - m.R0C0) - m.R1C1);
                <#= type #> s2 = half / s5;

                result.U = (m.R0C1 - m.R1C0) * s2;
                result.I = (m.R2C0 + m.R0C2) * s2;
                result.J = (m.R2C1 + m.R1C2) * s2;
                result.K = half * s5;
            }
        }
