        /// <summary>
        /// Calculates the length² of a Quaternion.
        /// </summary>
        public static void LengthSquared (
            ref Quaternion quaternion, out <#=T#> result)
        {
            result =
                (quaternion.I * quaternion.I) +
                (quaternion.J * quaternion.J) +
                (quaternion.K * quaternion.K) +
                (quaternion.U * quaternion.U);
        }

        /// <summary>
        /// Calculates the length of a Quaternion.
        /// </summary>
        public static void Length (
            ref Quaternion quaternion, out <#=T#> result)
        {
            <#=T#> lengthSquared =
                (quaternion.I * quaternion.I) +
                (quaternion.J * quaternion.J) +
                (quaternion.K * quaternion.K) +
                (quaternion.U * quaternion.U);

            result = Maths.Sqrt (lengthSquared);
        }


        /// <summary>
        /// Calculates the conjugate of a Quaternion.
        /// </summary>
        public static void Conjugate (
            ref Quaternion value, out Quaternion result)
        {
            result.I = -value.I;
            result.J = -value.J;
            result.K = -value.K;
            result.U = value.U;
        }

        /// <summary>
        /// todo
        /// </summary>
        public static void Inverse (
            ref Quaternion quaternion, out Quaternion result)
        {
            <#=T#> one = 1;
            <#=T#> a =
                (quaternion.I * quaternion.I) +
                (quaternion.J * quaternion.J) +
                (quaternion.K * quaternion.K) +
                (quaternion.U * quaternion.U);

            <#=T#> b = one / a;

            result.I = -quaternion.I * b;
            result.J = -quaternion.J * b;
            result.K = -quaternion.K * b;
            result.U =  quaternion.U * b;
        }

        /// <summary>
        /// Calculates the dot product of two Quaternions.
        /// </summary>
        public static void Dot (
            ref Quaternion q1, ref Quaternion q2, out <#=T#> result)
        {
            result =
                (q1.I * q2.I) +
                (q1.J * q2.J) +
                (q1.K * q2.K) +
                (q1.U * q2.U);
        }

        /// <summary>
        /// Concatenates two Quaternions; the result represents the first
        /// rotation followed by the second rotation.
        /// </summary>
        public static void Concatenate (
            ref Quaternion q1, ref Quaternion q2, out Quaternion result)
        {
            <#=T#> i1 = q1.I;
            <#=T#> j1 = q1.J;
            <#=T#> k1 = q1.K;
            <#=T#> u1 = q1.U;

            <#=T#> i2 = q2.I;
            <#=T#> j2 = q2.J;
            <#=T#> k2 = q2.K;
            <#=T#> u2 = q2.U;

            <#=T#> a = (j2 * k1) - (k2 * j1);
            <#=T#> b = (k2 * i1) - (i2 * k1);
            <#=T#> c = (i2 * j1) - (j2 * i1);
            <#=T#> d = (i2 * i1) - (j2 * j1);

            result.I = (i2 * u1) + (i1 * u2) + a;
            result.J = (j2 * u1) + (j1 * u2) + b;
            result.K = (k2 * u1) + (k1 * u2) + c;
            result.U = (u2 * u1) - (k2 * k1) - d;
        }

        /// <summary>
        /// Divides each component of the quaternion by the length of the
        /// quaternion.
        /// </summary>
        public static void Normalise (
            ref Quaternion quaternion, out Quaternion result)
        {
            <#=T#> one = 1;

            <#=T#> a =
                (quaternion.I * quaternion.I) +
                (quaternion.J * quaternion.J) +
                (quaternion.K * quaternion.K) +
                (quaternion.U * quaternion.U);

            <#=T#> b = one / Maths.Sqrt (a);

            result.I = quaternion.I * b;
            result.J = quaternion.J * b;
            result.K = quaternion.K * b;
            result.U = quaternion.U * b;
        }

