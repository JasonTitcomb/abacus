		// Maths //-----------------------------------------------------------//

		/// <summary>
		/// Calculates the distance between two vectors.
		/// </summary>
		public static void Distance (
			ref Vector2 value1, ref Vector2 value2, out <#= type #> result)
		{
			<#= type #> a = value1.X - value2.X;
			<#= type #> b = value1.Y - value2.Y;
			
			<#= type #> c = (a * a) + (b * b);

			result = RealMaths.Sqrt (c);
		}

		/// <summary>
		/// Calculates the distance between two vectors squared.
		/// </summary>
		public static void DistanceSquared (
			ref Vector2 value1, ref Vector2 value2, out <#= type #> result)
		{
			<#= type #> a = value1.X - value2.X;
			<#= type #> b = value1.Y - value2.Y;
			
			result = (a * a) + (b * b);
		}

		/// <summary>
		/// Calculates the dot product of two vectors. If the two vectors are 
		/// unit vectors, the dot product returns a floating point value between
		/// -1 and 1 that can be used to determine some properties of the angle 
		/// between two vectors. For example, it can show whether the vectors 
		/// are orthogonal, parallel, or have an acute or obtuse angle between 
		/// them.
		/// </summary>
		public static void Dot (
			ref Vector2 value1, ref Vector2 value2, out <#= type #> result)
		{
			result = (value1.X * value2.X) + (value1.Y * value2.Y);
		}

		/// <summary>
		/// Creates a unit vector from the specified vector. The result is a 
		/// vector one unit in length pointing in the same direction as the 
		/// original vector.
		/// </summary>
		public static void Normalise (ref Vector2 value, out Vector2 result)
		{
			<#= type #> lengthSquared = 
				(value.X * value.X) + (value.Y * value.Y);

			<#= type #> epsilon; RealMaths.Epsilon(out epsilon);

			if( lengthSquared <= epsilon || 
				<#= type #>.IsInfinity(lengthSquared) )
			{
				throw new ArgumentOutOfRangeException();
			}

			<#= type #> one = 1;
			<#= type #> multiplier = one / RealMaths.Sqrt (lengthSquared);

			result.X = value.X * multiplier;
			result.Y = value.Y * multiplier;

		}

		/// <summary>
		/// Returns the reflection of a vector off a surface that has the specified normal.
		/// </summary>
		public static void Reflect (
			ref Vector2 vector, ref Vector2 normal, out Vector2 result)
		{
			if( !normal.IsUnit() )
			{
				throw new ArgumentOutOfRangeException();
			}

			<#= type #> dot; Dot(ref vector, ref normal, out dot);

			<#= type #> two = 2;

			result.X = vector.X - ((two * dot) * normal.X);
			result.Y = vector.Y - ((two * dot) * normal.Y);
		}

		/// <summary>
		/// Transforms a vector normal by a matrix.
		/// </summary>
		public static void TransformNormal (
			ref Vector2 normal, ref Matrix44 matrix, out Vector2 result)
		{
			if( !normal.IsUnit() )
			{
				throw new ArgumentOutOfRangeException();
			}

			<#= type #> a = (normal.X * matrix.M11) + (normal.Y * matrix.M21);
			<#= type #> b = (normal.X * matrix.M12) + (normal.Y * matrix.M22);
			
			result.X = a;
			result.Y = b;
		}

		/// <summary>
		/// Transforms a Vector3 by a specified Matrix.
		/// </summary>
		public static void Transform (
			ref Vector2 position, ref Matrix44 matrix, out Vector2 result)
		{
			<#= type #> a = 
				((position.X * matrix.M11) + (position.Y * matrix.M21)) + 
				matrix.M41;

			<#= type #> b = 
				((position.X * matrix.M12) + (position.Y * matrix.M22)) + 
				matrix.M42;
			
			result.X = a;
			result.Y = b;
		}

		/// <summary>
		/// Transforms a Vector3 by a specified Quaternion.
		/// </summary>
		public static void Transform (
			ref Vector2 value, ref Quaternion rotation, out Vector2 result)
		{
			<#= type #> one = 1;

			<#= type #> a = rotation.X + rotation.X;
			<#= type #> b = rotation.Y + rotation.Y;
			<#= type #> c = rotation.Z + rotation.Z;
			<#= type #> d = rotation.W * c;
			<#= type #> e = rotation.X * a;
			<#= type #> f = rotation.X * b;
			<#= type #> g = rotation.Y * b;
			<#= type #> h = rotation.Z * c;
			<#= type #> i = (value.X * ((one - g) - h)) + (value.Y * (f - d));
			<#= type #> j = (value.X * (f + d)) + (value.Y * ((one - e) - h));

			result.X = i;
			result.Y = j;
		}
		
