	internal static class PackUtils
	{
		static Double ClampAndRound (Single value, Single min, Single max)
		{
			if (Single.IsNaN (value)) 
			{
				return 0.0;
			}

			if (Single.IsInfinity (value))
			{
				return (Single.IsNegativeInfinity (value) ? ((Double)min) : ((Double)max));
			}

			if (value < min)
			{
				return (Double)min;
			}

			if (value > max)
			{
				return (Double)max;
			}

			return Math.Round ((Double)value);
		}

		public static UInt32 PackSigned (UInt32 bitmask, Single value)
		{
			Single max = bitmask >> 1;
			Single min = -max - 1f;
			return (((UInt32)((Int32)ClampAndRound (value, min, max))) & bitmask);
		}

		public static UInt32 PackUnsigned (Single bitmask, Single value)
		{
			return (UInt32)ClampAndRound (value, 0f, bitmask);
		}

		public static UInt32 PackSignedNormalised (UInt32 bitmask, Single value)
		{
			Single max = bitmask >> 1;
			value *= max;
			return (((UInt32)((Int32)ClampAndRound (value, -max, max))) & bitmask);
		}

		public static Single UnpackSignedNormalised (UInt32 bitmask, UInt32 value)
		{
			UInt32 num = (UInt32)((bitmask + 1) >> 1);
			if ((value & num) != 0) {
				if ((value & bitmask) == num) {
					return -1f;
				}
				value |= ~bitmask;
			} else {
				value &= bitmask;
			}
			Single num2 = bitmask >> 1;
			return (((Single)value) / num2);
		}

		public static UInt32 PackUnsignedNormalisedValue (Single bitmask, Single value)
		{
			value *= bitmask;
			return (UInt32)ClampAndRound (value, 0f, bitmask);
		}
		
		public static Single UnpackUnsignedNormalisedValue (UInt32 bitmask, UInt32 value)
		{
			value &= bitmask;
			return (((Single)value) / ((Single)bitmask));
		}
	}

