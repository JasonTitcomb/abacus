    /// <summary>
    ///This is a test class for Fixed32Test and is intended
    ///to contain all Fixed32Test Unit Tests
    ///</summary>
    [TestFixture]
    public class Fixed32Tests
    {
        [Test]
        public void TestMaxRange()
        {
            double max = System.Math.Pow(2.0, Fixed32.m) - System.Math.Pow(2.0, -Fixed32.n);
            Assert.That(Fixed32.MaxValue.ToDouble(), Is.EqualTo(max));
        }

        [Test]
        public void TestMinRange()
        {
            double min = -System.Math.Pow(2.0, Fixed32.m);
            Assert.That(Fixed32.MinValue.ToDouble(), Is.EqualTo(min));
        }

        [Test]
        public void TestResolution()
        {
            // we should be able to represent this exactly
            double res = (double)-System.Math.Pow(2.0, -Fixed32.n);
            Fixed32 f = (Fixed32) res;
            Assert.That((double)f, Is.EqualTo(res));
        
            // but not this
            double res2 = res / 2;
            Fixed32 f2 = (Fixed32) res2;
            Assert.That((double)f2, Is.Not.EqualTo(res2));
        }

        [Test]
        public void TestToDouble ()
        {
            double[] values = { 0.0, 1.0, 1.0 / 3, -1, -1.0 / 3 };

            foreach (double value in values) {
                Fixed32 f = new Fixed32 (value);
                double d = f.ToDouble ();
                double error = System.Math.Abs (d - value);
                Assert.That (error < 0.001);
            }
        }

        
        [Test]
        public void TestToString ()
        {
            Assert.That (new Fixed32 (0).ToString (), Is.EqualTo ("0"));
            Assert.That (new Fixed32 (3.03125).ToString (), Is.EqualTo ("3.03125"));
            Assert.That (string.Format ("{0:0.000}", new Fixed32 (3.141593)), Is.EqualTo ("3.142"));
        }

        [Test]
        public void TestConstructFromString ()
        {
            Fixed32 zero; global::Abacus.RealMaths.Zero(out zero);
            Fixed32 one; global::Abacus.RealMaths.One(out one);
            Assert.That (Fixed32.Parse("0"), Is.EqualTo (zero));
            Assert.That (Fixed32.Parse("-0"), Is.EqualTo (zero));
            Assert.That (Fixed32.Parse("0."), Is.EqualTo (zero));
            Assert.That (Fixed32.Parse("0.0"), Is.EqualTo (zero));
            Assert.That (Fixed32.Parse("0.00"), Is.EqualTo (zero));

            Assert.That (Fixed32.Parse("1"), Is.EqualTo (one));
            Assert.That (Fixed32.Parse("1."), Is.EqualTo (one));
            Assert.That (Fixed32.Parse("1.0"), Is.EqualTo (one));
            Assert.That (Fixed32.Parse("-1"), Is.EqualTo (new Fixed32 (-1)));
            Assert.That (Fixed32.Parse("-1."), Is.EqualTo (new Fixed32 (-1)));
            Assert.That (Fixed32.Parse("-1.0"), Is.EqualTo (new Fixed32 (-1)));

            Assert.That (Fixed32.Parse("0.500"), Is.EqualTo (one / new Fixed32(2)));
            Assert.That (Fixed32.Parse("-0.500"), Is.EqualTo (-one / new Fixed32(2)).Within(Fixed32.Epsilon));

            Assert.That (Fixed32.Parse("-0.005"), Is.EqualTo (-one / new Fixed32(200)));
            Assert.That (Fixed32.Parse("-0.344999432563782"), Is.EqualTo (new Fixed32 (-0.344999432563782d)));
            Assert.That (Fixed32.Parse("0.938602924346924"), Is.EqualTo (new Fixed32 (0.938602924346924d)));

            Assert.That (Fixed32.Parse("100.001"), Is.EqualTo (new Fixed32 (100) + one / new Fixed32(1000)));

            
        }

        [Test]
        public void TestSin ()
        {
            double t = 0.1;

            Fixed32 zero = 0;
            Fixed32 one = 1;
            Fixed32 two = 2;
            Fixed32 three = 3;
            Fixed32 pi; global::Abacus.RealMaths.Pi(out pi);
            Fixed32 tau; global::Abacus.RealMaths.Tau(out tau);

            double p1 = Fixed32.Sin(zero).ToDouble();
            double e1 = zero.ToDouble();
            Assert.That(p1, Is.EqualTo(e1).Within(t));

            double p2 = Fixed32.Sin(pi / two).ToDouble();
            double e2 = one.ToDouble();
            Assert.That(p2, Is.EqualTo(e2).Within(t));

            double p3 = Fixed32.Sin(pi).ToDouble();
            double e3 = zero.ToDouble();
            Assert.That(p3, Is.EqualTo(e3).Within(t));

            double p4 = Fixed32.Sin(three * pi / two).ToDouble();
            double e4 = -one.ToDouble();
            Assert.That(p4, Is.EqualTo(e4).Within(t));

            double p5 = Fixed32.Sin(tau).ToDouble();
            double e5 = zero.ToDouble();
            Assert.That(p5, Is.EqualTo(e5).Within(t));

            for (float f = 0.0f; f < System.Math.PI * 2.0f; f += 0.1f)
            {
                Assert.That(System.Math.Sin(f), Is.EqualTo(Fixed32.Sin(new Fixed32(f)).ToDouble()).Within(t));
            }
        }

        [Test]
        public void TestCos ()
        {
            Fixed32 zero = 0;
            Fixed32 one = 1;
            Fixed32 two = 2;
            Fixed32 three = 3;
            Fixed32 pi; global::Abacus.RealMaths.Pi(out pi);
            Fixed32 tau; global::Abacus.RealMaths.Tau(out tau);

            Assert.That (Fixed32.Cos (zero), Is.EqualTo (one));
            Assert.That (Fixed32.Cos (pi / two), Is.EqualTo (zero));
            Assert.That (Fixed32.Cos (pi), Is.EqualTo (-one));
            Assert.That(Fixed32.Cos(three * pi / two), Is.EqualTo(zero));
            Assert.That (Fixed32.Cos (tau), Is.EqualTo (one));

            const float epsilon = 0.0001f;
            for (float f = 0.0f; f < System.Math.PI * 2.0f; f += 0.1f) {
                float singleResult = (float) System.Math.Cos(f);
                float fixedResult = Fixed32.Cos(new Fixed32(f)).ToSingle();

                Assert.That(
                    singleResult, 
                    Is.EqualTo(fixedResult).Within(epsilon),
                    string.Format("was: {0}, should have been: {1}", fixedResult, singleResult));
            }
        }

<#@ include file="Fixed.Operators.Tests.t4"#>
    }

