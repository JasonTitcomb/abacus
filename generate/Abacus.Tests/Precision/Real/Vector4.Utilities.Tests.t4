		/// <summary>
		/// Assert that, running the Min function on a number of randomly
		/// generated pairs of Vector4 objects, yields the same results as those
		/// obtained from performing a manual Min calculation.
		/// </summary>
		[Test]
		public void TestStaticFn_Min ()
		{
			for(Int32 i = 0; i < 100; ++i)
			{
				Vector4 a = GetNextRandomVector4();
				Vector4 b = a * 2;

				Vector4 result;
				Vector4.Min (ref a, ref b, out result);

				Assert.That(result.X, Is.EqualTo(a.X < b.X ? a.X : b.X ));
				Assert.That(result.Y, Is.EqualTo(a.Y < b.Y ? a.Y : b.Y ));
				Assert.That(result.Z, Is.EqualTo(a.Z < b.Z ? a.Z : b.Z ));
				Assert.That(result.W, Is.EqualTo(a.W < b.W ? a.W : b.W ));
			}
		}

		/// <summary>
		/// Assert that, running the Max function on a number of randomly
		/// generated pairs of Vector4 objects, yields the same results as those
		/// obtained from performing a manual Max calculation.
		/// </summary>
		[Test]
		public void TestStaticFn_Max ()
		{
			for(Int32 i = 0; i < 100; ++i)
			{
				Vector4 a = GetNextRandomVector4();
				Vector4 b = GetNextRandomVector4();

				Vector4 result;
				Vector4.Max (ref a, ref b, out result);

				Assert.That(result.X, Is.EqualTo(a.X > b.X ? a.X : b.X ));
				Assert.That(result.Y, Is.EqualTo(a.Y > b.Y ? a.Y : b.Y ));
				Assert.That(result.Z, Is.EqualTo(a.Z > b.Z ? a.Z : b.Z ));
				Assert.That(result.W, Is.EqualTo(a.W > b.W ? a.W : b.W ));
			}
		}

		/// <summary>
		/// Assert that, running the Clamp function on a number of randomly
		/// generated Vector4 objects for a given min-max range, yields
		/// results that fall within that range.
		/// </summary>
		[Test]
		public void TestStaticFn_Clamp_i ()
		{
			Vector4 min = new Vector4(-30, 1, 18, -22);
			Vector4 max = new Vector4(32, 130, 47, -2);

			for(Int32 i = 0; i < 100; ++i)
			{
				Vector4 a = GetNextRandomVector4();

				Vector4 result;
				Vector4.Clamp (ref a, ref min, ref max, out result);

				Assert.That(result.X, Is.LessThanOrEqualTo(max.X));
				Assert.That(result.Y, Is.LessThanOrEqualTo(max.Y));
				Assert.That(result.X, Is.GreaterThanOrEqualTo(min.X));
				Assert.That(result.Y, Is.GreaterThanOrEqualTo(min.Y));
			}
		}

		/// <summary>
		/// Assert that, running the Clamp function on an a Vector4 object known
		/// to fall outside of a given min-max range, yields a result that fall 
		/// within that range.
		/// </summary>
		[Test]
		public void TestStaticFn_Clamp_ii ()
		{
			Vector4 min = new Vector4(-30, 1, 18, -22);
			Vector4 max = new Vector4(32, 130, 47, -2);

			Vector4 a = new Vector4(-100, 1113, 50, 14);

			Vector4 expected = new Vector4(-30, 130, 47, -2);

			Vector4 result;
			Vector4.Clamp (ref a, ref min, ref max, out result);

			Assert.That(result.X, Is.LessThanOrEqualTo(max.X));
			Assert.That(result.Y, Is.LessThanOrEqualTo(max.Y));
			Assert.That(result.Z, Is.LessThanOrEqualTo(max.Z));
			Assert.That(result.W, Is.LessThanOrEqualTo(max.W));
			Assert.That(result.X, Is.GreaterThanOrEqualTo(min.X));
			Assert.That(result.Y, Is.GreaterThanOrEqualTo(min.Y));
			Assert.That(result.Z, Is.GreaterThanOrEqualTo(min.Z));
			Assert.That(result.W, Is.GreaterThanOrEqualTo(min.W));

			AssertEqualWithinReason(result, expected);

		}

		/// <summary>
		/// Assert that, running the Lerp function on a number of randomly
		/// generated pairs of Vector4 objects for a range of weighting amounts, 
		/// yields the same results as those obtained from performing a manual 
		/// Lerp calculation.
		/// </summary>
		[Test]
		public void TestStaticFn_Lerp_i ()
		{
			for(Int32 j = 0; j < 100; ++j)
			{
				<#= type #> delta = j;

				delta = delta / 100;

				for(Int32 i = 0; i < 100; ++i)
				{
					Vector4 a = GetNextRandomVector4();
					Vector4 b = GetNextRandomVector4();

					Vector4 result;
					Vector4.Lerp (ref a, ref b, delta, out result);

					Vector4 expected = a + ( ( b - a ) * delta );

					AssertEqualWithinReason(result, expected);
				}
			}
		}

		/// <summary>
		/// Assert that, for a known examples where the weighting parameter is
		/// is outside the allowed range, the correct exception is thrown.
		/// </summary>
		[Test]
		public void TestStaticFn_Lerp_ii ()
		{
			Vector4 a = GetNextRandomVector4();
			Vector4 b = GetNextRandomVector4();

			<#= type #> half; RealMaths.Half(out half);

			var tests = new <#= type #>[] { 2, half + 1, -half, -1 };

			foreach( var weighting in tests )
			{
				Vector4 result; 
				Assert.Throws(
					typeof(ArgumentOutOfRangeException), 
					() => 
						Vector4.Lerp (
							ref a, ref b, weighting, out result)
					);
			}
		}

