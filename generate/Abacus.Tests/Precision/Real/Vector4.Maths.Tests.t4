        // Test Static Fn: Distance //----------------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the Distance method
        /// yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_Distance_i ()
        {
            {
                Vector4 a = new Vector4(0, 4, 12, 0);
                Vector4 b = new Vector4(3, 0, 0, 84);

                <#= type #> expected = 85;
                <#= type #> result;

                Vector4.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector4 a = new Vector4(0, -4, 12, 0);
                Vector4 b = new Vector4(3, 0, 0, 84);

                <#= type #> expected = 85;
                <#= type #> result;

                Vector4.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector4 a = new Vector4(0, -4, -12, 0);
                Vector4 b = new Vector4(-3, 0, 0, -84);

                <#= type #> expected = 85;
                <#= type #> result;

                Vector4.Distance(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector4 a = Vector4.Zero;

                <#= type #> expected = 0;
                <#= type #> result;

                Vector4.Distance(ref a, ref a, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Distance method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Distance_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector4 a = GetNextRandomVector4();

                <#= type #> expected =
                    RealMaths.Sqrt((a.X * a.X) + (a.Y * a.Y) + (a.Z * a.Z) + (a.W * a.W));

                Assert.That(a.Length(), Is.EqualTo(expected));
            }
        }

        // Test Static Fn: DistanceSquared //---------------------------------//

        /// <summary>
        /// Assert that, for a number of known examples, the DistanceSquared
        /// method yeilds the correct results.
        /// </summary>
        [Test]
        public void TestStaticFn_DistanceSquared_i ()
        {
            {
                Vector4 a = new Vector4(0, 4, 12, 0);
                Vector4 b = new Vector4(3, 0, 0, 84);

                <#= type #> expected = 7225;
                <#= type #> result;

                Vector4.DistanceSquared(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }

            {
                Vector4 a = Vector4.Zero;

                <#= type #> expected = 0;
                <#= type #> result;

                Vector4.DistanceSquared(ref a, ref a, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }


        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// DistanceSquared method yeilds the same results as those obtained
        /// from performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_DistanceSquared_ii ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector4 a = GetNextRandomVector4();
                Vector4 b = GetNextRandomVector4();

                Vector4 c = b - a;

                <#= type #> expected = (c.X * c.X) + (c.Y * c.Y) + (c.Z * c.Z) + (c.W * c.W);
                <#= type #> result;

                Vector4.DistanceSquared(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        // Test Static Fn: Dot //---------------------------------------------//

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Dot method yeilds the same results as those obtained from
        /// performing a manual calculation.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_i ()
        {
            for(Int32 i = 0; i < 100; ++i)
            {
                Vector4 a = GetNextRandomVector4();
                Vector4 b = GetNextRandomVector4();

                <#= type #> expected = (a.X * b.X) + (a.Y * b.Y) + (a.Z * b.Z) + (a.W * b.W);
                <#= type #> result; Vector4.Dot(ref a, ref b, out result);

                Assert.That(result, Is.EqualTo(expected));
            }
        }

        /// <summary>
        /// Assert that two unit vectors pointing in opposing directions yeild a
        /// dot product of negative one.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_ii ()
        {
            Vector4 a = new Vector4(0, 0, 0, 1);
            Vector4 b = new Vector4(0, 0, 0, -1);

            <#= type #> expected = -1;
            <#= type #> result; Vector4.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that two unit vectors pointing in the same direction yeild a
        /// dot product of one.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_iii ()
        {
            Vector4 a = new Vector4(0, 0, 0, 1);
            Vector4 b = new Vector4(0, 0, 0, 1);

            <#= type #> expected = 1;
            <#= type #> result; Vector4.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        /// <summary>
        /// Assert that two perpendicular unit vectors yeild a dot product of
        /// zero.
        /// </summary>
        [Test]
        public void TestStaticFn_Dot_iv ()
        {
            Vector4 a = new Vector4(0, 0, 1, 0);
            Vector4 b = new Vector4(0, 0, 0, 1);

            <#= type #> expected = 0;
            <#= type #> result; Vector4.Dot(ref a, ref b, out result);

            Assert.That(result, Is.EqualTo(expected));
        }

        // Test Static Fn: Normalise //---------------------------------------//

        /// <summary>
        /// Assert that, for a known examples where the weighting parameter is
        /// is outside the allowed range, the correct exception is thrown.
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_i()
        {
            {
                Vector4 a = Vector4.Zero;

                Vector4 b;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException),
                    () =>
                    Vector4.Normalise(ref a, out b)
                );
            }

            {
                Vector4 a = new Vector4(
                    <#= type #>.MaxValue,
                    <#= type #>.MaxValue,
                    <#= type #>.MaxValue,
                    <#= type #>.MaxValue);

                Vector4 b;

                Assert.Throws(
                    typeof(ArgumentOutOfRangeException),
                    () =>
                    Vector4.Normalise(ref a, out b)
                );
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Normalise method yeilds a unit vector (with length equal to one);
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_ii ()
        {
            <#= type #> epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector4 a = GetNextRandomVector4();

                Vector4 b; Vector4.Normalise(ref a, out b);
                <#= type #> expected = 1;
                <#= type #> result1 = b.Length();
                Assert.That(result1, Is.EqualTo(expected).Within(epsilon));

                // The normalise function takes both a ref and out parameter,
                // need to check that if we pass in the same value as both
                // parameters we get the same results.
                Vector4 c = a;
                Vector4.Normalise(ref c, out c);
                <#= type #> result2 = c.Length();
                Assert.That(result2, Is.EqualTo(expected).Within(epsilon));
            }
        }

        /// <summary>
        /// Assert that, for a number of randomly generated examples, the
        /// Normalise method yeilds a vector, which when multipled by the
        /// length of the original vector results in the same vector as the
        /// original vector;
        /// </summary>
        [Test]
        public void TestStaticFn_Normalise_iii ()
        {
            <#= type #> epsilon; RealMaths.Epsilon(out epsilon);

            for( Int32 i = 0; i < 100; ++ i)
            {
                Vector4 a = GetNextRandomVector4();
                <#= type #> l = a.Length();
                Vector4 expected = a;

                Vector4 b; Vector4.Normalise(ref a, out b);
                Vector4 result1 = b * l;
                AssertEqualWithinReason(result1, expected);

                Vector4 c = a;

                // The normalise function takes both a ref and out parameter,
                // need to check that if we pass in the same value as both
                // parameters we get the same results.
                Vector4.Normalise(ref c, out c);
                Vector4 result2 = c * l;
                AssertEqualWithinReason(result2, expected);
            }
        }

        // Test Static Fn: TransformMatrix44 //-------------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformMatix44_i ()
        {
            Vector4 position = new Vector4 (-40, -20, 10, 20);

            Single pi; RealMaths.Pi (out pi);
            Single piOver2 = pi / (<#= type #>) 2;

            Matrix44 rotmati = Matrix44.Identity;
            Matrix44 rotmatx; Matrix44.CreateRotationX(piOver2, out rotmatx);
            Matrix44 rotmaty; Matrix44.CreateRotationY(pi, out rotmaty);
            Matrix44 rotmatz; Matrix44.CreateRotationZ(-piOver2, out rotmatz);
            Matrix44 rotmatxyz = rotmatx * rotmaty * rotmatz;

            Vector4 expected1 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected2 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected3 = new Vector4 ( 40, -20, -10, 20);
            Vector4 expected4 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected5 = new Vector4 ( 40, -20, -10, 20);

            Vector4 test1; Vector4.Transform (ref position, ref rotmati, out test1);
            Vector4 test2; Vector4.Transform (ref position, ref rotmatx, out test2);
            Vector4 test3; Vector4.Transform (ref position, ref rotmaty, out test3);
            Vector4 test4; Vector4.Transform (ref position, ref rotmatz, out test4);
            Vector4 test5; Vector4.Transform (ref position, ref rotmatxyz, out test5);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
            AssertEqualWithinReason(test5, expected5);
        }

        // Test Static Fn: TransformNormal //---------------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformNormal_i ()
        {
            Vector4 position = new Vector4 (-3, -0, 0, 4);
            Vector4.Normalise (ref position, out position);

            <#= type #> a = (<#= type #>) 6 / (<#= type #>) 10;
            <#= type #> b = 0;
            <#= type #> c = 0;
            <#= type #> d = (<#= type #>) 8 / (<#= type #>) 10;

            Single pi; RealMaths.Pi (out pi);
            Single piOver2 = pi / (<#= type #>) 2;

            Matrix44 rotmati = Matrix44.Identity;
            Matrix44 rotmatx; Matrix44.CreateRotationX(pi, out rotmatx);
            Matrix44 rotmaty; Matrix44.CreateRotationY(piOver2, out rotmaty);
            Matrix44 rotmatz; Matrix44.CreateRotationZ(-pi, out rotmatz);
            Matrix44 rotmatxyz = rotmatx * rotmaty * rotmatz;

            Vector4 expected1 = new Vector4 (-a, -b,  c, d);
            Vector4 expected2 = new Vector4 (-a, -b,  c, d);
            Vector4 expected3 = new Vector4 ( a, -b, -c, d);
            Vector4 expected4 = new Vector4 (-a, -b,  c, d);
            Vector4 expected5 = new Vector4 ( a, -b, -c, d);

            Vector4 test1; Vector4.TransformNormal (ref position, ref rotmati, out test1);
            Vector4 test2; Vector4.TransformNormal (ref position, ref rotmatx, out test2);
            Vector4 test3; Vector4.TransformNormal (ref position, ref rotmaty, out test3);
            Vector4 test4; Vector4.TransformNormal (ref position, ref rotmatz, out test4);
            Vector4 test5; Vector4.TransformNormal (ref position, ref rotmatxyz, out test5);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
            AssertEqualWithinReason(test5, expected5);

            // should also work with the standard transform fn
            Vector4 test1n; Vector4.Transform (ref position, ref rotmati, out test1n);
            Vector4 test2n; Vector4.Transform (ref position, ref rotmatx, out test2n);
            Vector4 test3n; Vector4.Transform (ref position, ref rotmaty, out test3n);
            Vector4 test4n; Vector4.Transform (ref position, ref rotmatz, out test4n);
            Vector4 test5n; Vector4.Transform (ref position, ref rotmatxyz, out test5n);

            AssertEqualWithinReason(test1n, expected1);
            AssertEqualWithinReason(test2n, expected2);
            AssertEqualWithinReason(test3n, expected3);
            AssertEqualWithinReason(test4n, expected4);
            AssertEqualWithinReason(test5n, expected5);
        }

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformNormal_ii ()
        {
            Matrix44 rotmat = Matrix44.Identity;
            Vector4 normal = new Vector4 (21, -532, 0, 91);
            Vector4 result;
            Assert.Throws(
                typeof(ArgumentOutOfRangeException),
                () =>
                Vector4.TransformNormal(ref normal, ref rotmat, out result)
            );
        }

        // Test Static Fn: TransformQuaternion //-----------------------------//

        /// <summary>
        ///
        /// </summary>
        [Test]
        public void TestStaticFn_TransformQuaternion_i ()
        {
            Vector4 position = new Vector4 (-40, -20, 10, 20);

            Single pi;
            RealMaths.Pi (out pi);

            Quaternion quatmati = new Quaternion (0, 0, 0, 1);
            Quaternion quatmatx = new Quaternion (0, 0, 0, 1);
            Quaternion quatmaty = new Quaternion (0, 1, 0, 0);
            Quaternion quatmatz = new Quaternion (0, 0, 0, 1);
            Quaternion quatmatxyz = new Quaternion (0, 1, 0, 0);

            Vector4 expected1 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected2 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected3 = new Vector4 ( 40, -20, -10, 20);
            Vector4 expected4 = new Vector4 (-40, -20,  10, 20);
            Vector4 expected5 = new Vector4 ( 40, -20, -10, 20);

            Vector4 test1; Vector4.Transform (ref position, ref quatmati, out test1);
            Vector4 test2; Vector4.Transform (ref position, ref quatmatx, out test2);
            Vector4 test3; Vector4.Transform (ref position, ref quatmaty, out test3);
            Vector4 test4; Vector4.Transform (ref position, ref quatmatz, out test4);
            Vector4 test5; Vector4.Transform (ref position, ref quatmatxyz, out test5);

            AssertEqualWithinReason(test1, expected1);
            AssertEqualWithinReason(test2, expected2);
            AssertEqualWithinReason(test3, expected3);
            AssertEqualWithinReason(test4, expected4);
            AssertEqualWithinReason(test5, expected5);
        }

